<!DOCTYPE HTML>
<html lang="zh-TW" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>閉包：獲取其環境的匿名函式 - Rust 程式設計語言</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust 程式設計語言</a></li><li class="chapter-item expanded affix "><a href="foreword.html">前言</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">介紹</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 開始入門</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 安裝教學</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 設計猜謎遊戲程式</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 常見程式設計概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 變數與可變性</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 資料型別</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 函式</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 註解</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 控制流程</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 理解所有權</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 什麼是所有權？</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 參考與借用</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> 切片型別</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 透過結構體組織相關資料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 定義與實例化結構體</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 使用結構體的程式範例</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 方法語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 列舉與模式配對</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 定義列舉</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 控制流建構子</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> 透過 if let 簡化控制流</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 透過套件、Crate 與模組管理成長中的專案</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 套件與 Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 定義模組來控制作用域與隱私權</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 參考模組項目的路徑</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> 透過 use 關鍵字引入路徑</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 將模組拆成不同檔案</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 常見集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 透過向量儲存列表</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 透過字串儲存 UTF-8 編碼的文字</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 透過雜湊映射儲存鍵值配對</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 錯誤處理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! 與無法復原的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result 與可復原的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> 要 panic! 還是不要 panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 泛型型別、特徵與生命週期</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 泛型資料型別</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 特徵：定義共同行為</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 透過生命週期驗證參考</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 編寫自動化測試</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 如何寫測試</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 控制程式如何執行</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 測試組織架構</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> I/O 專案：建立一個命令列程式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 接受命令列引數</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 讀取檔案</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 透過重構來改善模組性與錯誤處理</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 透過測試驅動開發完善函式庫功能</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 處理環境變數</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 將錯誤訊息寫入標準錯誤而非標準輸出</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 函式語言功能：疊代器與閉包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html" class="active"><strong aria-hidden="true">13.1.</strong> 閉包：獲取其環境的匿名函式</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 使用疊代器來處理一系列的項目</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 改善我們的 I/O 專案</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 比較效能：迴圈 vs. 疊代器</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 更多關於 Cargo 與 Crates.io 的內容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 透過發佈設定檔自訂建構</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> 發佈 Crate 到 Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 工作空間</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> 透過 cargo install 安裝執行檔</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 透過自訂命令來擴展 Cargo 的功能</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 智慧指標</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> 使用 Box&lt;T&gt; 指向堆積上的資料</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 透過 Deref 特徵將智慧指標視為一般參考</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> 透過 Drop 特徵執行清除程式碼</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt; 參考計數智慧指標</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; 與內部可變性模式</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 參考循環會導致記憶體泄漏</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 無懼並行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 使用執行緒同時執行程式碼</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 使用訊息傳遞在執行緒間傳送資料</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 共享狀態並行</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 透過 Sync 與 Send 特徵擴展並行性</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust 的物件導向程式設計特色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 物件導向語言的特色</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 允許不同型別數值的特徵物件</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 實作物件導向設計模式</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 模式與配對</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 所有能使用模式的地方</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 可反駁性：何時模式可能會配對失敗</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 模式語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 進階特色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 不安全的 Rust</a></li><li class="chapter-item expanded "><a href="ch19-02-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 進階特徵</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 進階型別</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 進階函式與閉包</a></li><li class="chapter-item expanded "><a href="ch19-05-macros.html"><strong aria-hidden="true">19.5.</strong> 巨集</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最終專案：建立多執行緒網頁伺服器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 建立單一執行緒的網頁伺服器</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 將單一執行緒伺服器轉換為多執行緒伺服器</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 正常關機與清理</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 附錄</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 關鍵字</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 運算子與符號</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 可推導的特徵</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - 實用開發工具</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - 版號</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - 本書的翻譯本</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust 的開發流程與「每夜版 Rust」</a></li><li class="chapter-item expanded "><a href="appendix-08-terminology.html"><strong aria-hidden="true">21.8.</strong> H - 中英術語對照表</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 程式設計語言</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-tw/book-tw" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="閉包獲取其環境的匿名函式"><a class="header" href="#閉包獲取其環境的匿名函式">閉包：獲取其環境的匿名函式</a></h2>
<p>Rust 的閉包（closures）是個你能賦值給變數或作為其他函式引數的匿名函式。你可以在某處建立閉包，然後在不同的地方呼叫閉包並執行它。而且不像函式，閉包可以從它們所定義的作用域中獲取數值。我們將會解釋這些閉包功能如何允許程式碼重用以及自訂行為。</p>
<h3 id="透過閉包獲取環境"><a class="header" href="#透過閉包獲取環境">透過閉包獲取環境</a></h3>
<p>我們首先會來研究我們如何用閉包來獲取定義在環境的數值並在之後使用。讓我們考慮以下假設情境：每隔一段時間，我們的襯衫公司會送出獨家限量版襯衫給郵寄清單的某位顧客來作為宣傳手段。郵寄清單的顧客可以在他們的設定中加入他們最愛的顏色。如果被選中的人有設定最愛顏色的話，他們就會獲得該顏色的襯衫。如果他們沒有指定任何最愛顏色的話，公司就會選擇目前顏色最多的選項。</p>
<p>要實作的方式有很多種。舉例來說，我們可以使用一個列舉叫做 <code>ShirtColor</code> 然後其變體有 <code>Red</code> 和 <code>Blue</code>（為了簡潔我們限制顏色的種類）。我們用 <code>Inventory</code> 來代表公司的庫存，然後用 <code>shirts</code> 欄位來包含 <code>Vec&lt;ShirtColor&gt;</code> 來代表目前庫存有的襯衫顏色。定義在 <code>Inventory</code> 的 <code>giveaway</code> 方法會取得免費襯衫得主的選擇性襯衫顏色偏好，然後回傳他們會拿到的襯衫顏色。如範例 13-1 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;偏好 {:?} 的使用者獲得 {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;偏好 {:?} 的使用者獲得 {:?}&quot;,
        user_pref2, giveaway2
    );
}
</code></pre>
<p><span class="caption">範例 13-1：襯衫公司送禮的情境</span></p>
<p>定義在 <code>main</code> 中的 <code>store</code> 在這次的限量版宣傳中的庫存有兩件藍色襯衫與一件紅色襯衫。我們呼叫了 <code>giveaway</code> 方法兩次，一次是給偏好紅色襯衫的使用者，另一次則是給無任何偏好的使用者。</p>
<p>再次強調這可以用各種方式實作，只是在此我們想專注在閉包，所以除了用到我們已經學過的概念以外，<code>giveaway</code> 方法中還使用了閉包。在 <code>giveaway</code> 方法中，我們從參數型別 <code>Option&lt;ShirtColor&gt;</code> 取得使用者偏好，然後對 <code>user_preference</code> 呼叫 <code>unwrap_or_else</code> 方法。<a href="../std/option/enum.Option.html#method.unwrap_or_else"><code>Option&lt;T&gt;</code> 的 <code>unwrap_or_else</code> 方法</a><!-- ignore -->定義在標準函式庫中。它接收一個引數：一個沒有任何引數的閉包然後會回傳數值 <code>T</code>（該型別為 <code>Option&lt;T&gt;</code> 的 <code>Some</code> 儲存的型別，在此例中就是 <code>ShirtColor</code>）。如果 <code>Option&lt;T&gt;</code> 是 <code>Some</code> 變體，<code>unwrap_or_else</code> 就會回傳 <code>Some</code> 裡的數值。如果 <code>Option&lt;T&gt;</code> 是 <code>None</code> 變體，<code>unwrap_or_else</code> 會呼叫閉包並回傳閉包回傳的數值。</p>
<p>我們寫上閉包表達式 <code>|| self.most_stocked()</code> 作為 <code>unwrap_or_else</code> 的引數。這是個沒有任何參數的閉包（如果閉包有參數的話，它們會出現在兩條直線中間）。閉包本體會呼叫 <code>self.most_stocked()</code>。我們直接在此定義閉包，然後 <code>unwrap_or_else</code> 的實作就會在需要結果時執行閉包。</p>
<p>執行此程式的話就會印出：</p>
<pre><code class="language-console">$ cargo r
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company) 
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/shirt-company`
偏好 Some(Red) 的使用者獲得 Red
偏好 None 的使用者獲得 Blue
</code></pre>
<p>這裡值得注意的是我們對當前 <code>Inventory</code> 實例傳入的是一個呼叫 <code>self.most_stocked()</code> 的閉包。標準函式庫不需要知道我們定義的任何型別像  <code>Inventory</code> 與 <code>ShirtColor</code>，或是在此情境中我們需要使用的任何邏輯，閉包就會獲取 <code>Inventory</code> 實例的不可變參考 <code>self</code>，然後傳給我們在 <code>unwrap_or_else</code> 方法中指定的程式碼。反之，函式就無法像這樣獲取它們周圍的環境。</p>
<h3 id="閉包型別推導與詮釋"><a class="header" href="#閉包型別推導與詮釋">閉包型別推導與詮釋</a></h3>
<p>函式與閉包還有更多不同的地方。閉包通常不必像 <code>fn</code> 函式那樣要求你要詮釋參數或回傳值的型別。函式需要型別詮釋是因為它們是顯式公開給使用者的介面。嚴格定義此介面是很重要的，這能確保每個人同意函式使用或回傳的數值型別為何。但是閉包並不是為了對外公開使用，它們儲存在變數且沒有名稱能公開給我們函式庫的使用者。</p>
<p>閉包通常很短，而且只與小範圍內的程式碼有關，而非適用於任何場合。有了這樣限制的環境，編譯器能可靠地推導出參數與回傳值的型別，如同其如何推導出大部分的變數型別一樣。（但在有些例外情形下編譯器還是需要閉包的型別詮釋）</p>
<p>至於變數的話，雖然不是必要的，但如果我們希望能夠增加閱讀性與清楚程度，我們還是可以加上型別詮釋。要在閉包詮釋型別的話，就會如範例 13-2 的定義所示。在此範例中，我們定義一個閉包並儲存至一個變數中，而非像範例 13-1 我們將閉包作為引數傳入。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;緩慢計算中...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;今天請做 {} 下伏地挺身！&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;然後請做 {} 下仰臥起坐！&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;今天休息！別忘了多喝水！&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;今天請慢跑 {} 分鐘！&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-2：對閉包加上選擇性的參數與回傳值型別詮釋</span></p>
<p>加上型別詮釋後，閉包的語法看起來就更像函式的語法了。我們在此定義了一個對參數加 1 的函式，以及一個有相同行為的閉包做為比較。我們加了一些空格來對齊相對應的部分。這顯示了閉包語法和函式語法有多類似，只是改用直線以及有些語法是選擇性的。</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>第一行顯示的是函式定義，而第二行則顯示有完成型別詮釋的閉包定義。在第三行我們移除了閉包定義的型別詮釋，然後在第四行我們移除了大括號，因為閉包本體只有一個表達式，所以這是選擇性的。這些都是有效的定義，並會在被呼叫時產生相同行為。而 <code>add_one_v3</code> 和 <code>add_one_v4</code> 一定要被呼叫，這樣編譯器才能從它們的使用方式中推導出型別。這就像 <code>let v = Vec::new();</code> 需要型別詮釋，或是有某種型別的數值插入 <code>Vec</code> 中，Rust 才能推導出型別。</p>
<p>對於閉包定義，編譯器會對每個參數與它們的回傳值推導出一個實際型別。舉例來說，範例 13-3 展示一支只會將收到的參數作為回傳值的閉包定義。此閉包並沒有什麼意義，純粹作為範例解釋。注意到我們沒有在定義中加上任何型別詮釋。由於沒有型別詮釋，我們可以用任何型別來呼叫閉包，像我們第一次呼叫就用 <code>String</code>。如果我們接著嘗試用整數呼叫 <code>example_closure</code>，我們就會得到錯誤。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;哈囉&quot;));
    let n = example_closure(5);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-3：嘗試呼叫被推導出兩個不同型別的閉包</span></p>
<p>編譯器會給我們以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |             --------------- ^- help: try using a conversion method: `.to_string()`
  |             |               |
  |             |               expected struct `String`, found integer
  |             arguments to this function are incorrect
  |
note: closure parameter defined here
 --&gt; src/main.rs:3:28
  |
2 |     let example_closure = |x| x;
  |                            ^

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<p>當我們第一次使用 <code>String</code> 數值呼叫 <code>example_closure</code> 時，編譯器會推導 <code>x</code> 與閉包回傳值的型別為 <code>String</code>。這樣 <code>example_closure</code> 閉包內的型別就會鎖定，然後我們如果對同樣的閉包嘗試使用不同的型別的話，我們就會得到型別錯誤。</p>
<h3 id="獲取參考或移動所有權"><a class="header" href="#獲取參考或移動所有權">獲取參考或移動所有權</a></h3>
<p>閉包要從它們周圍環境取得數值有三種方式，這能直接對應於函式取得參數的三種方式：不可變借用、可變借用，與取得所有權。閉包會依照函式本體如何使用獲取的數值，來決定要用哪種方式。</p>
<p>在範例 13-4 中，我們定義一個閉包來獲取 <code>list</code> 向量的不可變參考，因為它只需要不可變參考就能印出數值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;定義閉包前：{:?}&quot;, list);

    let only_borrows = || println!(&quot;來自閉包：{:?}&quot;, list);

    println!(&quot;呼叫閉包前：{:?}&quot;, list);
    only_borrows();
    println!(&quot;呼叫閉包後：{:?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">範例 13-4：定義並呼叫會獲取不可變參考的閉包</span></p>
<p>此範例還示範了變數能綁定閉包的定義，然後我們之後就可以用變數名稱加上括號來呼叫閉包，這樣變數名稱就像函式名稱一樣。</p>
<p>由於我們可以同時擁有 <code>list</code> 的多重不可變參考，<code>list</code> 在閉包定義前、在閉包定義後閉包呼叫前以及閉包呼叫時的程式碼中都是能使用的。此程式碼就會編譯、執行並印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example
定義閉包前：[1, 2, 3]
呼叫閉包前：[1, 2, 3]
來自閉包：[1, 2, 3]
呼叫閉包後：[1, 2, 3]
</code></pre>
<p>接著在範例 13-5 中我們改變閉包本體，對 <code>list</code> 向量加上一個元素。這樣閉包現在就會獲取可變參考：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;呼叫閉包前{:?}&quot;, list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;呼叫閉包後：{:?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">範例 13-11：定義並呼叫會獲取可變參考的閉包</span></p>
<p>此程式碼會編譯、執行並印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
呼叫閉包前[1, 2, 3]
呼叫閉包後：[1, 2, 3, 7]
</code></pre>
<p>注意到在 <code>borrows_mutably</code> 閉包的定義與呼叫之間的 <code>println!</code> 不見了：當 <code>borrows_mutably</code> 定義時，它會獲取 <code>list</code> 的可變參考。我們在閉包呼叫之後沒有再使用閉包，所以可變參考就結束。在閉包定義與呼叫之間，利用不可變參考印出輸出是不允許的，因為在可變參考期間不能再有其他參考。你可以試試看在那加上 <code>println!</code> 然後看看會收到什麼錯誤訊息！</p>
<p>如果你想要強迫閉包取得周圍環境數值的所有權的話，你可以在參數列表前使用 <code>move</code> 關鍵字。</p>
<p>此技巧適用於將閉包傳給新執行緒來移動資料，讓新的執行緒能擁有該資料。我們會在第十六章討論並行時，介紹為何你會想使用它們。但現在讓我們簡單探索怎麼在閉包使用 <code>move</code> 關鍵字開個新的執行緒就好。範例 13-6 更改了範例 13-4 讓向量在新的執行緒印出而非原本的主執行緒：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;呼叫閉包前：{:?}&quot;, list);

    thread::spawn(move || println!(&quot;來自執行緒：{:?}&quot;, list))
        .join()
        .unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 13-6：使用 <code>move</code> 來迫使執行緒的閉包取得 <code>list</code> 的所有權</span></p>
<p>我們開了一個新的執行緒，將閉包作為引數傳入，閉包本體會印出 <code>list</code>。在範例 13-4 中，閉包只用不可變參考獲取 <code>list</code>，因為要印出 <code>list</code> 的需求只要這樣就好。而在此例中，儘管閉包本體仍然只需要不可變參考就好，我們在閉包定義時想要指定 <code>list</code> 應該要透過 <code>move</code> 關鍵字移入閉包。新的執行緒可能會在主執行緒之前結束，或者主執行緒也有可能會先結束。如果主執行緒持有 <code>list</code> 的所有權卻在新執行緒之前結束並釋放 <code>list</code> 的話，執行緒拿到的不可變參考就會無效了。因此編譯器會要求 <code>list</code> 移入新執行緒的閉包中，這樣參考才會有效。嘗試看看將 <code>move</code> 關鍵字刪掉，或是在主執行緒的閉包定義之後使用 <code>list</code>，看看你會收到什麼編譯器錯誤訊息！</p>
<h3 id="fn-特徵以及將獲取的數值移出閉包"><a class="header" href="#fn-特徵以及將獲取的數值移出閉包"><code>Fn</code> 特徵以及將獲取的數值移出閉包</a></h3>
<p>一旦閉包從其定義的周圍環境獲取了數值的參考或所有權（也就是說被<strong>移入</strong>閉包中），閉包本體的程式碼會定義閉包在執行結束後要對參考或數值做什麼事情（也就是說被<strong>移出</strong>閉包）。閉包本體可以做以下的事情：將獲取的數值移出閉包、改變獲取的數值、不改變且不移動數值，或是一開始就不從環境獲取任何值。</p>
<p>閉包從周圍環境獲取並處理數值的方式會影響閉包會實作哪種特徵，而這些特徵能讓函式與結構體決定它們想使用哪種閉包。閉包會依照閉包本體處理數值的方式，自動實作一種或多種 <code>Fn</code> 特徵：</p>
<ol>
<li><code>FnOnce</code> 適用於可以呼叫一次的閉包。所有閉包至少都會有此特徵，因為所有閉包都能被呼叫。會將獲取的數值移出本體的閉包只會實作 <code>FnOnce</code> 而不會再實作其他 <code>Fn</code> 特徵，因為這樣它只能被呼叫一次。</li>
<li><code>FnMut</code> 適用於不會將獲取數值移出本體，而且可能會改變獲取數值的閉包。這種閉包可以被呼叫多次。</li>
<li><code>Fn</code> 適用於不會將獲取數值移出本體，而且不會改變獲取數值或是甚至不從環境獲取數值的閉包。這種閉包可以被呼叫多次，而且不會改變周圍環境，這對於並行呼叫閉包多次來說非常重要。</li>
</ol>
<p>讓我們來觀察範例 13-1 中 <code>Option&lt;T&gt;</code> 用到的 <code>unwrap_or_else</code> 方法定義：</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}
</code></pre>
<p>回想一下 <code>T</code> 是一個泛型型別，代表著 <code>Option</code> 的 <code>Some</code> 變體內的數值型別。型別 <code>T</code> 同時也是函式 <code>unwrap_or_else</code> 的回傳型別：比如說對 <code>Option&lt;String&gt;</code> 呼叫  <code>unwrap_or_else</code> 的話就會取得 <code>String</code>。</p>
<p>接著注意到函式 <code>unwrap_or_else</code> 有個額外的泛型型別參數 <code>F</code>。型別 <code>F</code> 是參數 <code>f</code> 的型別，也正是當我們呼叫 <code>unwrap_or_else</code> 時的閉包。</p>
<p>泛型型別 <code>F</code> 指定的特徵界限是 <code>FnOnce() -&gt; T</code>，也就是說 <code>F</code> 必須要能夠呼叫一次、不帶任何引數然後回傳 <code>T</code>。在特徵界限中使用 <code>FnOnce</code> 限制了 <code>unwrap_or_else</code> 只能呼叫 <code>f</code> 最多一次。在 <code>unwrap_or_else</code> 本體中，如果 <code>Option</code> 是 <code>Some</code> 的話，<code>f</code> 就不會被呼叫。如果 <code>Option</code> 是 <code>None</code> 的話，<code>f</code> 就會被呼叫一次。由於所有閉包都有實作 <code>FnOnce</code>，<code>unwrap_or_else</code> 能接受大多數各種不同的閉包，讓它的用途非常彈性。</p>
<blockquote>
<p>注意：函式也可以實作這三種 <code>Fn</code> 特徵。如果我們不必獲取環境數值，在我們需要有實作其中一種 <code>Fn</code> 特徵的項目時，我們可以使用函式名稱而不必用到閉包。舉例來說，對於 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 的數值，我們可以呼叫 <code>unwrap_or_else(Vec::new)</code> 在數值為 <code>None</code> 時取得新的空向量。</p>
</blockquote>
<p>現在讓我們來看看標準函式庫中切片定義的 <code>sort_by_key</code> 方法，來觀察它和 <code>unwrap_or_else</code> 有什麼不同，以及為何 <code>sort_by_key</code> 的特徵界限使用的是 <code>FnMut</code> 而不是 <code>FnOnce</code>。閉包會取得一個引數，這會是該切片當下項目的參考，然後回傳型別 <code>K</code> 的數值以供排序。當你想透過切片項目的特定屬性做排序時，此函式會很實用。在範例 13-7 中，我們有個 <code>Rectangle</code> 實例的列表，然後我們使用 <code>sort_by_key</code> 透過 <code>width</code> 屬性由低至高排序它們：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{:#?}&quot;, list);
}
</code></pre></pre>
<p><span class="caption">範例 13-7：使用 <code>sort_by_key</code> 依據寬度來排序長方形</span></p>
<p>此程式碼會印出：</p>
<pre><code class="language-console">
$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p><code>sort_by_key</code> 的定義會需要 <code>FnMut</code> 閉包的原因是因為它得呼叫閉包好幾次，對切片的每個項目都要呼叫一次。閉包 <code>|r| r.width</code> 沒有獲取、改變或移動周圍環境的任何值，所以它符合特徵界限的要求。</p>
<p>反之，範例 13-8 示範了一個只實作 <code>FnOnce</code> 特徵的閉包，因為它有將數值移出環境。編譯器不會允許我們將此閉包用在 <code>sort_by_key</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;by key called&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{:#?}&quot;, list);
}
</code></pre>
<p><span class="caption">範例 13-8：嘗試在 <code>sort_by_key</code> 使用 <code>FnOnce</code> 閉包</span></p>
<p>這裡嘗試用很糟糕且令人費解的方式計算 <code>list</code> 在排序時 <code>sort_by_key</code> 被呼叫了幾次。此程式碼嘗試計數的方式是把閉包周圍環境中型別為 <code>String</code> 的 <code>value</code> 變數放入 <code>sort_operations</code> 向量中。閉包會獲取 <code>value</code>，然後將 <code>value</code> 移出閉包，也就是將 <code>value</code> 的所有權轉移到 <code>sort_operations</code> 向量裡。此向量只能呼叫一次，嘗試呼叫第二次是無法成功的，因為 <code>value</code> 已經不存在於環境中了，無法再次放入 <code>sort_operations</code>！因此，此閉包僅實作了 <code>FnOnce</code>。當我們嘗試編譯此程式碼時，我們會收到錯誤訊息說明 <code>value</code> 無法移出閉包，因為閉包必須實作 <code>FnMut</code>：</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (/Users/wuwayne/Desktop/book-tw/listings/ch13-functional-features/listing-13-08)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |     let value = String::from(&quot;by key called&quot;);
   |         ----- captured outer variable
16 |
17 |     list.sort_by_key(|r| {
   |                      --- captured by this `FnMut` closure
18 |         sort_operations.push(value);
   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` due to previous error
</code></pre>
<p>錯誤訊息指出閉包本體將 <code>value</code> 移出環境的地方。要修正此問題的話，我們需要改變閉包本體，讓它不再將數值移出環境。要計算 <code>sort_by_key</code> 呼叫次數的話，在環境中放置一個計數器，然後在閉包本體增加其值是更直觀的計算方法。範例 13-9 的閉包就能用在 <code>sort_by_key</code>，因為它只獲取了 <code>num_sort_operations</code> 計數器的可變參考，因此可以被呼叫不只一次：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{:#?} 的排序經過 {num_sort_operations} 次運算&quot;, list);
}
</code></pre></pre>
<p><span class="caption">範例 13-9：在 <code>sort_by_key</code> 使用 <code>FnMut</code> 閉包是允許的</span></p>
<p>當我們要在函式或型別中定義與使用閉包時，<code>Fn</code> 特徵是很重要的。在下個段落中，我們將討論疊代器。疊代器有許多方法都需要閉包引數，所以隨著我們繼續下去別忘了複習閉包的用法！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>
    </body>
</html>
