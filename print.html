<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Programming Language</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 開始入門</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 安裝教學</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 常見程式設計概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 變數與可變性</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 資料型別</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 函式</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 註解</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 控制流程</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 理解所有權</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 什麼是所有權？</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 引用與借用</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slice 型別</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 透過結構體組織相關資料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 定義與實例化結構體</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 使用結構體的程式範例</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 方法語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 枚舉與模式配對</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 定義枚舉</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 控制流運算子</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> 透過 if let 簡化控制流</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 透過套件、Crate與模組管理成長中的專案</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 套件與 Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 定義模組來控制作用域與隱私權</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 引用模組項目的路徑</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> 透過 use 關鍵字引入路徑</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 將模組拆成不同檔案</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 常見集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> 透過 Vector 儲存列表</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 透過字串儲存 UTF-8 編碼的文字</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 透過雜湊映射儲存鍵值配對</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 錯誤處理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! 與無法復原的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result 與可復原的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> 要 panic! 還是不要 panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 泛型型別、特徵與生命週期</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 泛型資料型別</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> 特徵：定義共同行爲</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 透過生命週期驗證引用</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 編寫自動化測試</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 如何寫測試</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 控制程式如何執行</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 測試組織架構</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 函式語言功能：疊代器與閉包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 閉包：能獲取其環境的匿名函式</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 使用疊代器來處理一系列的項目</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 改善我們的 I/O 專案</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 比較效能：迴圈 vs. 疊代器</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 更多關於 Cargo 與 Crates.io 的內容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 透過發佈設定檔自訂建構</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> 發佈 Crate 到 Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 工作空間</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> 透過 cargo install 從 Crates.io 安裝二進制執行檔</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 透過自訂命命來擴展 Cargo 的功能</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 智慧指標</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> 使用 Box<T> 指向堆積上的資料</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 透過 Deref 特徵將智慧指標視為一般引用</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> 透過 Drop 特徵執行清除程式碼</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T> 引用計數智慧指標</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> 與內部可變性模式</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 引用循環會導致記憶體泄漏</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 無懼並行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 使用執行緒同時執行程式碼</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 使用訊息傳遞在執行緒間傳送資料</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 共享狀態並行</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 透過 Sync 與 Send 特徵擴展並行性</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust 的物件導向程式設計特色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 物件導向語言的特色</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 允許不同型別數值的特徵物件</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 實作物件導向設計模式</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 模式與配對</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 所有能使用模式的地方</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 可反駁性：何時模式可能會配對失敗</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 模式語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 進階特色</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> 不安全的 Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 進階特徵</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 進階型別</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 進階函式與閉包</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> 巨集</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 可推導的特徵</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li><li class="chapter-item expanded "><a href="appendix-08-terminology.html"><strong aria-hidden="true">21.8.</strong> H - 中英術語對照表</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-rust-programming-language" id="the-rust-programming-language">The Rust Programming Language</a></h1>
<p><em>by Steve Klabnik and Carol Nichols, with contributions from the Rust Community</em></p>
<p>This version of the text assumes you’re using Rust 1.41.0 or later with
<code>edition=&quot;2018&quot;</code> in <em>Cargo.toml</em> of all projects to use Rust 2018 Edition
idioms. See the <a href="ch01-01-installation.html">“Installation” section of Chapter 1</a><!-- ignore -->
to install or update Rust, and see the new <a href="appendix-05-editions.html">Appendix E</a><!-- ignore
--> for information on editions.</p>
<p>The 2018 Edition of the Rust language includes a number of improvements that
make Rust more ergonomic and easier to learn. This iteration of the book
contains a number of changes to reflect those improvements:</p>
<ul>
<li>Chapter 7, “Managing Growing Projects with Packages, Crates, and Modules,”
has been mostly rewritten. The module system and the way paths work in the
2018 Edition were made more consistent.</li>
<li>Chapter 10 has new sections titled “特徵作爲參數” and “Returning
Types that Implement Traits” that explain the new <code>impl Trait</code> syntax.</li>
<li>Chapter 11 has a new section titled “Using <code>Result&lt;T, E&gt;</code> in Tests” that
shows how to write tests that use the <code>?</code> operator.</li>
<li>The “Advanced Lifetimes” section in Chapter 19 was removed because compiler
improvements have made the constructs in that section even rarer.</li>
<li>The previous Appendix D, “Macros,” has been expanded to include procedural
macros and was moved to the “Macros” section in Chapter 19.</li>
<li>Appendix A, “Keywords,” also explains the new raw identifiers feature that
enables code written in the 2015 Edition and the 2018 Edition to interoperate.</li>
<li>Appendix D is now titled “Useful Development Tools” and covers recently
released tools that help you write Rust code.</li>
<li>We fixed a number of small errors and imprecise wording throughout the book.
Thank you to the readers who reported them!</li>
</ul>
<p>Note that any code in earlier iterations of <em>The Rust Programming Language</em>
that compiled will continue to compile without <code>edition=&quot;2018&quot;</code> in the
project’s <em>Cargo.toml</em>, even as you update the Rust compiler version you’re
using. That’s Rust’s backward compatibility guarantees at work!</p>
<p>The HTML format is available online at
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>
and offline with installations of Rust made with <code>rustup</code>; run <code>rustup docs --book</code> to open.</p>
<p>This text is available in <a href="https://nostarch.com/rust">paperback and ebook format from No Starch
Press</a>.</p>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>It wasn’t always so clear, but the Rust programming language is fundamentally
about <em>empowerment</em>: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.</p>
<p>Take, for example, “systems-level” work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.</p>
<p>Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to “dip down” into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.</p>
<p>Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won’t accidentally introduce crashes or vulnerabilities.</p>
<p>But Rust isn’t limited to low-level systems programming. It’s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write — you’ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.</p>
<p>This book fully embraces the potential of Rust to empower its users. It’s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn—and welcome to the Rust community!</p>
<p>— Nicholas Matsakis and Aaron Turon</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<blockquote>
<p>Note: This edition of the book is the same as <a href="https://nostarch.com/rust">The Rust Programming
Language</a> available in print and ebook format from <a href="https://nostarch.com/">No Starch
Press</a>.</p>
</blockquote>
<p>Welcome to <em>The Rust Programming Language</em>, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.</p>
<h2><a class="header" href="#who-rust-is-for" id="who-rust-is-for">Who Rust Is For</a></h2>
<p>Rust is ideal for many people for a variety of reasons. Let’s look at a few of
the most important groups.</p>
<h3><a class="header" href="#teams-of-developers" id="teams-of-developers">Teams of Developers</a></h3>
<p>Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program’s
logic rather than chasing down bugs.</p>
<p>Rust also brings contemporary developer tools to the systems programming world:</p>
<ul>
<li>Cargo, the included dependency manager and build tool, makes adding,
compiling, and managing dependencies painless and consistent across the Rust
ecosystem.</li>
<li>Rustfmt ensures a consistent coding style across developers.</li>
<li>The Rust Language Server powers Integrated Development Environment (IDE)
integration for code completion and inline error messages.</li>
</ul>
<p>By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.</p>
<h3><a class="header" href="#students" id="students">Students</a></h3>
<p>Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.</p>
<h3><a class="header" href="#companies" id="companies">Companies</a></h3>
<p>Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.</p>
<h3><a class="header" href="#open-source-developers" id="open-source-developers">Open Source Developers</a></h3>
<p>Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We’d love to have you contribute to the Rust
language.</p>
<h3><a class="header" href="#people-who-value-speed-and-stability" id="people-who-value-speed-and-stability">People Who Value Speed and Stability</a></h3>
<p>Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compiler’s checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.</p>
<p>The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust’s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety <em>and</em> productivity, speed <em>and</em> ergonomics. Give
Rust a try and see if its choices work for you.</p>
<h2><a class="header" href="#who-this-book-is-for" id="who-this-book-is-for">Who This Book Is For</a></h2>
<p>This book assumes that you’ve written code in another programming language but
doesn’t make any assumptions about which one. We’ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don’t spend a lot of time talking about what programming <em>is</em> or how to think
about it. If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.</p>
<h2><a class="header" href="#how-to-use-this-book" id="how-to-use-this-book">How to Use This Book</a></h2>
<p>In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.</p>
<p>You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of Rust. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.</p>
<p>Chapter 1 explains how to install Rust, how to write a “Hello, world!” program,
and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rust’s ownership system. However, if you’re a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
you’d like to work on a project applying the details you’ve learned.</p>
<p>Chapter 5 discusses structs and methods, and Chapter 6 covers enums, <code>match</code>
expressions, and the <code>if let</code> control flow construct. You’ll use structs and
enums to make custom types in Rust.</p>
<p>In Chapter 7, you’ll learn about Rust’s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust’s error-handling philosophy and techniques.</p>
<p>Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust’s safety guarantees is necessary to ensure your program’s
logic is correct. In Chapter 12, we’ll build our own implementation of a subset
of functionality from the <code>grep</code> command line tool that searches for text
within files. For this, we’ll use many of the concepts we discussed in the
previous chapters.</p>
<p>Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we’ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.</p>
<p>In Chapter 16, we’ll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.</p>
<p>Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.</p>
<p>In Chapter 20, we’ll complete a project in which we’ll implement a low-level
multithreaded web server!</p>
<p>Finally, some appendixes contain useful information about the language in a
more reference-like format. Appendix A covers Rust’s keywords, Appendix B
covers Rust’s operators and symbols, Appendix C covers 可推導的特徵
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.</p>
<p>There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.</p>
<p><span id="ferris"></span></p>
<p>An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:</p>
<table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>This code does not compile!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>This code panics!</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>This code block contains unsafe code.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>This code does not produce the desired behavior.</td></tr>
</tbody></table>
<p>In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.</p>
<h2><a class="header" href="#source-code" id="source-code">Source Code</a></h2>
<p>The source files from which this book is generated can be found on
<a href="https://github.com/rust-lang/book/tree/master/src">GitHub</a>.</p>
<h1><a class="header" href="#開始入門" id="開始入門">開始入門</a></h1>
<p>讓我們開始你的 Rust 旅途吧！千里之行始於足下，在此章節我們將討論：</p>
<ul>
<li>在 Linux、macOS 和 Windows 上安裝 Rust</li>
<li>寫一支印出 <code>Hello, world!</code> 的程式</li>
<li>使用 Rust 的套件管理工具暨建構系統 <code>cargo</code></li>
</ul>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/1fedfc4b96c2017f64ecfcf41a0a07e2e815f24f/src/ch01-00-getting-started.md">1fedfc4</a></li>
<li>updated: 2020-09-05</li>
</ul>
</blockquote>
<h2><a class="header" href="#安裝教學" id="安裝教學">安裝教學</a></h2>
<p>第一步是安裝 Rust，我們將會透過 <code>rustup</code> 安裝 Rust，這是個管理 Rust 版本及相關工具的命令列工具。你將會需要網路連線才能下載。</p>
<blockquote>
<p>注意：如果你基於某些原因不想使用 <code>rustup</code> 的話，請前往<a href="https://www.rust-lang.org/zh-TW/tools/install">安裝 Rust 頁面</a>尋求其他選項。</p>
</blockquote>
<p>以下步驟將會安裝最新的穩定版 Rust 編譯器。Rust 的穩定性能確保本書的所有範例在更新的 Rust 版本仍然能繼續編譯出來。輸出的結果可能會在不同版本間而有些微的差異，因爲 Rust 時常會改善錯誤與警告訊息。換句話說，任何你所安裝的最新穩定版 Rust 都應該能夠正常運行本書的內容。</p>
<blockquote>
<h3><a class="header" href="#命令列標記" id="命令列標記">命令列標記</a></h3>
<p>在本章節到整本書爲止，我們講會顯示一些終端機會用到的命令。任一你會用到的命令都會始於 <code>$</code>。但你不需要去輸入 <code>$</code>，因爲這通常代表每一命令列的起始位置。而沒有出現 <code>$</code> 的行數，通常則代表前一行命列輸出的結果。除此之外，針對 PowerShell 的範例則將會使用 <code>&gt;</code> 而不是 <code>$</code>。</p>
</blockquote>
<h3><a class="header" href="#在-linux-或-macos-上安裝-rustup" id="在-linux-或-macos-上安裝-rustup">在 Linux 或 macOS 上安裝 <code>rustup</code></a></h3>
<p>如果你使用的是 Linux 或 macOS，請開啟終端機然後輸入以下命令：</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>這道命令會下載一支腳本然後開始安裝 <code>rusup</code> 工具，接著安裝最新的穩定版 Rust。下載過程中可能會要求你輸入你的密碼。如果下載成功的話，將會出現以下內容：</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>除此之外，你還會需要某種類型的連結器（linker）。這通常在你的系統上都已經安裝了，但如果你嘗試編譯 Rust 程式卻遇到連結器無法執行的錯誤時，這代表你的系統並未安裝，而你需要自行安裝一個。C 編譯器通常都會帶有一個正確的連結器，你可以檢查你的平台文件，查看如何下載 C 編譯器。此外，一些常見的 Rust 套件也會依賴 C 的程式，所以也需要 C 編譯器。因此現在最好還是有安裝一個比較好。</p>
<h3><a class="header" href="#在-windows-上安裝-rustup" id="在-windows-上安裝-rustup">在 Windows 上安裝 <code>rustup</code></a></h3>
<p>在 Windows 上請前往<a href="https://www.rust-lang.org/zh-TW/tools/install">下載頁面</a>並依照指示安裝 Rust。在安裝的某個過程中，你將會看到一個訊息要求你還需要 C++ build tools for Visual Studio 2013 或更新的版本。取得這項工具最簡單的辦法是下載 <a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Build Tools for Visual Studio</a>。當你被問到要安裝哪些項目時，請確認有選擇「C++ build tools」，以及 Windows 10 SDK 和 英文語言包套件有包含在內。</p>
<p>本書接下來使用的命令都相容於 <em>cmd.exe</em> 和 PowerShell。如果有特別不同的地方，我們會解釋該怎麼使用。</p>
<h3><a class="header" href="#更新與解除安裝" id="更新與解除安裝">更新與解除安裝</a></h3>
<p>當你透過 <code>rustup</code> 安裝完 Rust 後，要更新到最新版本的方法非常簡單。在你的 shell 中執行以下更新腳本即可：</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>要解除安裝 Rust 與 <code>rustup</code> 的話，則在 shell 輸入以下解除安裝腳本：</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<h3><a class="header" href="#疑難排除" id="疑難排除">疑難排除</a></h3>
<p>想簡單你是否有正確安裝 Rust 的話，請開啟 shell 然後輸入此命令：</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<p>你應該會看到已發佈的最新穩定版本號、提交雜湊數以及提交日期如以下格式所示：</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>如果你看到這則訊息代表你成功安裝 Rust 了！如果你沒有看到且你是在 Windows 上的話，請檢查 Rust 是否在你的 <code>%PATH%</code> 系統變數裡。如果都正確無誤，但還是無法執行 Rust 的話，你可以前往一些地方尋求協助。最簡單的辦法是前往<a href="https://discord.gg/rust-lang">官方 Rust Discord</a> 的 #beginners 頻道詢問。在那裡你可以與其他 Rustaceans（這是我們常用稱呼自己取的暱稱）交談並取得協助。另外也有其他不錯的資源像是<a href="https://users.rust-lang.org/">使用者討論區</a> 和 <a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>。正體中文社群的話可以前往 rust-lang.tw，底下有 Facebook 或 Telegram 的連結一樣可以尋求協助。</p>
<h3><a class="header" href="#本地端技術文件" id="本地端技術文件">本地端技術文件</a></h3>
<p>安裝 Rust 的同時也會包含一份本地的技術文件副本，讓你可以離線閱讀。執行 <code>rustup doc</code> 就可以用你的瀏覽器開啟本地文件。</p>
<p>每當有任何型態或函式出現而你卻不清楚如何使用時，你就可以使用應用程式介面（API）技術文件來知道！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/bad683bb7dcd06ef7f5f83bad3a25b1706b7b230/src/ch01-01-installation.md">bad683b</a></li>
<li>updated: 2020-09-05</li>
</ul>
</blockquote>
<h2><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h2>
<p>現在你已經安裝好 Rust，讓我們開始來寫你的第一支 Rust 程式吧。當我們學習一門新的語言時，有一個習慣是寫一支印出「Hello, world!」到螢幕上的小程式，此章節將教你做一樣的事！</p>
<blockquote>
<p>注意：本書將預設你已經知道命令列最基本的使用方法。Rust 對於你的編輯器、工具以及程式碼位於何處沒有特殊的要求，所以如果你更傾向於使用整合開發環境（IDE）的話，請儘管使用你最愛的 IDE。許多 IDE 都已經針對 Rust 提供某種程度的支援，請查看你所使用的 IDE 技術文件以瞭解詳情。最近，Rust 團隊正在積極專注在提升 IDE 的支援，而且進展十分迅速且出色！</p>
</blockquote>
<h3><a class="header" href="#建立專案目錄" id="建立專案目錄">建立專案目錄</a></h3>
<p>你將先建立一個目錄來儲存你的 Rust 程式碼。程式碼位於何處並不重要，但爲了能好好練習書中的範例和專案，我們建議你可以在你的 home 目錄建立一個 <em>projects</em> 目錄然後將你所有的專案保存在此。</p>
<p>請開啟終端機然後輸入以下命令來建立 <em>projects</em> 目錄和另一個在 <em>projects</em> 目錄底下的真正要寫「Hello, world!」專案的目錄。</p>
<p>對於 Linux、macOS 和 Windows 的 PowerShell，請輸入：</p>
<pre><code class="language-console">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>對於 Windows CMD，請輸入：</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3><a class="header" href="#編寫並執行-rust-程式" id="編寫並執行-rust-程式">編寫並執行 Rust 程式</a></h3>
<p>接著，請產生一個原始文件並叫做 <em>main.rs</em>。Rust 的文件檔案都會以 <em>.rs</em> 副檔名稱作爲結尾。如果你用到不止一個單字的話，請用底線區隔開來。比方說，請使用 <em>hello_world.rs</em> 而不是 <em>helloworld.rs</em>。</p>
<p>現在請開啟 <em>main.rs</em> 文件然而後輸入範例 1-1 中的程式碼。</p>
<p><span class="filename">檔案名稱：main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 1-1：印出「Hello, world!」的程式</span></p>
<p>儲存檔案然後回到你的終端機螢幕。在 Linux 或 macOS 上，請輸入以下命令來編譯並執行檔案：</p>
<pre><code class="language-console">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>在 Windows 上則輸入 <code>.\main.exe</code> 而非 <code>./main</code>：</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>不管你的作業系統維和，終端機上應該都會出現 <code>Hello, world!</code>。如果你沒有看到，可以回到安裝章節中的<a href="ch01-01-installation.html#troubleshooting">「疑難排除」</a><!-- ignore -->尋求協助。</p>
<p>如果 <code>Hello, world!</code> 有印出來，那麼恭喜你！你正式寫了一支 Rust 程式，所以你也正式成爲 Rust 開發者——歡迎加入！</p>
<h3><a class="header" href="#分析這支-rust-程式" id="分析這支-rust-程式">分析這支 Rust 程式</a></h3>
<p>讓我們來仔細瞧瞧你的「Hello, world!」程式實際上發生了什麼事。這是第一塊拼圖：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>這幾行在 Rust 中定義了一個函式。<code>main</code> 是一個特別的函式：它是每個可執行的 Rust 程式永遠第一個執行的程式碼。第一行宣告了一個函式 <code>main</code>，它沒有參數也不回傳任何東西。如果有參數的話，它們會被加進括號 <code>()</code> 內。</p>
<p>再來，請注意到函式本體被囊括在大括號 <code>{}</code> 內，Rust 要求所有函式都用大括號包起來。一般來說，良好的程式碼風格會要求將前大括號置於宣告函式的同一行，並用一個空格區隔開來。</p>
<p>在本書撰寫的期間，有一支自動格式化的工具叫做 <code>rustfmt</code> 正在開發中。如果你想要在不同 Rust 專案之間統一標準風格的話，<code>rustfmt</code> 可以格式化你的程式成特定的風格。Rust 團隊計劃最終將此工具納入標準 Rust 發行版中，就像 <code>rustc</code> 一樣。所以依照你閱讀此書的時間點，它很可能已經安裝到你的電腦上了！請查看線上技術文件以瞭解詳情。</p>
<p>在 <code>main</code> 函式內有以下程式碼：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>此行負責了整支程式要做的事：它將文字顯示在螢幕上。這邊有四個細節要注意。</p>
<p>首先，Rust 的排版風格是 4 個空格而非一個 tab。</p>
<p>第二，<code>println!</code> 會呼叫一支 Rust 巨集（macro）。如果是呼叫函式的話，那則會是 <code>println</code>（去掉 <code>!</code>）。我們會在第 19 章討論更多巨集的細節。現在你只需要知道使用 <code>!</code> 代表呼叫一支巨集而非一個正常的函式。</p>
<p>第三，<code>&quot;Hello, world!&quot;</code> 是一個字串，我們將此字串作爲引數傳遞給 <code>println!</code>，然後該字串就會被顯示到螢幕上。</p>
<p>第四，我們用分號（<code>;</code>）作爲該行結尾，代表此表達式的結束和下一個表達式的開始。多數的 Rust 程式碼都以分號做結尾。</p>
<h3><a class="header" href="#編譯和執行是不同的步驟" id="編譯和執行是不同的步驟">編譯和執行是不同的步驟</a></h3>
<p>你剛剛執行了一個薪建立的程式，讓我們來檢查過程中的每一個步驟吧。</p>
<p>在你執行一支 Rust 程式前，你必須用 Rust 編譯器來編譯它，也就是輸入 <code>rustc</code> 命令然後加上你的原始文件，像這樣子：</p>
<pre><code class="language-console">$ rustc main.rs
</code></pre>
<p>如果你已經有 C 或 C++ 的背景，你應該就會發現這和 <code>gcc</code> 或 <code>clang</code> 非常相似。編譯成功後，Rust 編譯器會輸出一個二進制執行檔（binary executable）。</p>
<p>在 Linux、macOS 和 Windows 上的 PowerShell，你可以在你的 shell 輸入 <code>ls</code> 來查看你的執行檔。在 Linux 和 macOS，你會看到兩個檔案。而在 Windows 上的 PowerShell，你會和使用 CMD 一樣看到三個檔案。</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>在 Windows 上的 CMD，你需要輸入：</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>這顯示了副檔名爲 <em>.rs</em>  的原始程式碼檔案、執行檔（在 Winddows 上爲 <em>main.exe</em>；其他則爲 <em>main</em>），然後在 Windows 上會再出現一個副檔名爲 <em>.pdb</em> 的除錯資訊文件。在這裡，你就可以像這樣執行 <em>main</em> 或 <em>main.exe</em> 檔案：</p>
<pre><code class="language-console">$ ./main # or .\main.exe on Windows
</code></pre>
<p>如果 <em>main.rs</em> 正是你的 “Hello, world!” 程式，這命令就會顯示 <code>Hello, world!</code> 到你的終端機。</p>
<p>如果你比較熟悉動態語言，像是 Ruby、Python 或 JavaScript，你可能會比較不習慣將編譯與執行程式分爲兩個不同的步驟。Rust 是一門 <em>預先編譯（ahead-of-time compiled）</em> 的語言，代表你可以編譯完成後將執行檔送到其他地方，然後他們就算沒有安裝 Rust 一樣可以執行起來。但如果你給某個人 <em>.rb</em>、<em>.py</em> 或 <em>.js</em> 檔案，他們就需要 Ruby、Python 或 Javascript 分別都有安裝好。當然你在這些語言只需要一行命令就可以執行，在語言設計中這一切都只是取捨。</p>
<p>在簡單的程式使用 <code>rustc</code> 來編譯不會有什麼問題，但當你的專案成長時，你將會需要管理所有選擇並讓程式碼易於分享。接下來我們將介紹 Cargo 這項工具給你，它將協助你寫出真正的 Rust 程式。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/fce7281061fd4b18a87075f43c17fc3168230a21/src/ch01-02-hello-world.md">fce7281</a></li>
<li>updated: 2020-09-05</li>
</ul>
</blockquote>
<h2><a class="header" href="#hello-cargo" id="hello-cargo">Hello, Cargo!</a></h2>
<p>Cargo 是 Rust 的建構系統與套件管理工具。大部分的 Rustaceans 都會用此工具來管理他們的專案，因爲 Cargo 能幫你處理很多任務，像是建構你的程式碼、下載你程式碼所需要的依賴函式庫並建構它們。我們常簡稱程式碼所需要用到的函式庫爲<em>依賴（dependencies）</em>。</p>
<p>簡單的 Rust 程式像是我們目前所寫的不會有任何依賴。所以當我們用 Cargo 建構「Hello, world!」專案時，Cargo 只會用到建構程式碼的那部分。隨著你寫的 Rust 程式越來越複雜，你將會加入一些依賴函式庫來幫助你。而如果你使用 Cargo 的話，加入這些依賴就會簡單很多。</p>
<p>既然大多數的 Rust 專案都是用 Cargo，所以接下來本書也將預設你也使用 Cargo。Cargo 在你使用<a href="ch01-01-installation.html#installation">「安裝教學」</a><!-- ignore --> 的官方安裝連結來安裝 Rust 時就已經連同安裝好了。如果你是用其他方式下載 Rust 的話，想要檢查 Cargo 有沒有下載好可以透過你的終端機輸入：</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<p>如果你有看到版本號，那就代表你有安裝了！如果你看到錯誤訊息，像是 <code>command not found</code>，請查看你的安裝辦法的技術文件，尋找如何分別下載 Cargo。</p>
<h3><a class="header" href="#使用-cargo-建立專案" id="使用-cargo-建立專案">使用 Cargo 建立專案</a></h3>
<p>讓我們來用 Cargo 建立一個專案，並來比較他和我們原本的「Hello, world!」專案有什麼差別。請回到你的 <em>projects</em>  目錄（或者任何你決定存放程式碼的地方），然後在任何作業系統上輸入：</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>第一道命令會建立一個新的目錄叫做 <em>hello_cargo</em>。我們將我們的專案命名爲 <em>hello_cargo</em>，然後 Cargo 就會產生相同名稱的目錄並產生所需的檔案。</p>
<p>進入 <em>hello_cargo</em> 然後顯示檔案的話，你會看到 Cargo 產生了兩個檔案和一個目錄： <em>Cargo.toml</em> 檔案以及一個 <em>src</em> 目錄，其內包含一個 <em>main.rs</em> 檔案。</p>
<p>它還會初始化成一個新的 Git repository 並附上 <em>.gitignore</em> 檔案。如果已經在 Git repository 內的話，執行 <code>cargo new</code> 則不會產生 Git 的檔案。你可以用 <code>cargo new --vcs=git</code> 覆寫這項行爲。</p>
<blockquote>
<p>注意：Git 是一個常見的版本控制系統。你可以加上 <code>--vcs</code> 來變更 <code>cargo new</code> 去使用不同的版本控制系統，或是不用任何版本控制系統。請執行 <code>cargo new --help</code> 來查看更多可使用的選項。</p>
</blockquote>
<p>請用任何你喜歡的編輯器開啟 <em>Cargo.toml</em>，它應該會看起來和範例 1-2 差不多。</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p><span class="caption">範例 1-2：用 <code>cargo new</code> 產生的 <em>Cargo.toml</em></span></p>
<p>此檔案用的是 <a href="https://toml.io"><em>TOML</em></a><!-- ignore --> （<em>Tom’s Obvious, Minimal Language</em>）格式，這是 Cargo 配置文件的格式。</p>
<p>第一行的 <code>[package]</code> 是一個段落（section）標題，說明以下的陳述語句會配置這個套件。隨著我們加入更多資訊到此文件，我們也會加上更多段落。</p>
<p>接下來四行就是 Cargo 編譯你的程式所需的配置資訊：名稱、版本、誰寫的以及哪個 Rust <code>edition</code> 會用到。Cargo 會透過環境取得你的名字和電子郵件資訊，所以要是資訊不對的話，請現在編輯然後儲存檔案。我們會在附錄 E 介紹什麼是 <code>edition</code>。</p>
<p>最後一行 <code>[dependencies]</code> 是用來列出你的專案會用到哪些依賴的段落。在 Rust 中，程式碼套件會被稱爲 <em>crates</em>。我們在此專案還不需要任何其他 crate。但是我們會在第二章開始用到，屆時我們會再來介紹。</p>
<p>現在請開啟 <em>src/main.rs</em> 來看看：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo 預設會爲你產生一個「Hello, world!」程式，就像我們範例 1-1 寫得一樣！目前我們之前寫的專案與 Cargo 產生的程式碼不同的地方在於 Cargo 將程式碼放在 <em>src</em> 目錄底下，而且我們還有一個 <em>Cargo.toml</em> 配置文件在根目錄。</p>
<p>Cargo 預期你的原始文件都會放在 <em>src</em> 目錄底下。專案的根目錄是用來放 README 文件、授權條款、配置文件以及其他與你的程式碼不相關的文件。使用 Cargo 能夠幫助你組織你的專案，讓一切井然有序。</p>
<p>如果你的專案還沒開始使用 Cargo 的話，像是我們剛剛寫得「Hello, world!」專案，你只要將程式碼移入 <em>src</em> 然後產生正確的 <em>Cargo.toml</em> 文件，就可以將它轉換成能夠使用 Cargo 的專案。</p>
<h3><a class="header" href="#建構並執行-cargo-專案" id="建構並執行-cargo-專案">建構並執行 Cargo 專案</a></h3>
<p>現在讓我們看看用 Cargo 產生的「Hello, world!」程式在建構和執行時有什麼差別！請在你的 <em>hello_cargo</em> 目錄下輸入以下命令來建構專案：</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>此命令會產生一個執行檔 <em>target/debug/hello_cargo</em>（在 Windows 上則是 <em>target\debug\hello_cargo.exe</em>），而不是在你目前的目錄。你可以用以下命令運行執行檔：</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>如果一切順利，<code>Hello, world!</code> 就會顯示在終端機上。第一次執行 <code>cargo build</code> 的話，還會在根目錄產生另一個新檔案：<em>Cargo.lock</em>。此檔案用來追蹤依賴函式庫的確切版本。不過此專案沒有任何依賴，所以目前這個檔案看起來內容會有點少。你不會需要去手動更改此檔案，Cargo 會幫你管理這個檔案的內容。</p>
<p>我們剛用 <code>cargo build</code> 建構完專案並用 <code>./target/debug/hello_cargo</code> 執行它。不過我們其實也可以只用一道命令 <code>cargo run</code> 來編譯程式碼並接著運行產生的執行檔：</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>請注意到這次輸出的結果我們沒有看到 Cargo 有在編譯 <code>hello_cargo</code> 的跡象，這是因爲 Cargo 可以知道檔案完全沒被更改過，所以它選擇直接執行二進制檔案。如果你有變更你的原始程式碼的話，Cargo 才會在執行前重新建構專案，你才會看到這樣的輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo 還提供一道命令 <code>cargo check</code>，此命令會快速檢查你的程式碼，確保它能編譯不過不會產生執行檔。：</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>爲啥你會不想要產生執行檔呢？這是因爲 <code>cargo check</code> 省略了產生執行檔的步驟，所以它執行的速度比 <code>cargo build</code> 還來的快。如果你在寫程式時需要持續檢查的話，使用 <code>cargo check</code> 可以加快整體過程！所以許多 Rustaceans 都會在寫程式的過程中時不時執行 <code>cargo check</code> 來確保它能編譯。最後當他們準備好要使用執行檔時，才會用 <code>cargo build</code>。</p>
<p>讓我們來回顧我們目前學到的 Cargo 內容：</p>
<ul>
<li>我們可以用 <code>cargo build</code> 建構專案。</li>
<li>我們可以用 <code>cargo run</code> 一次建構並執行專案。</li>
<li>我們可以用 <code>cargo check</code> 建構專案來檢查錯誤，但不會產生執行檔。</li>
<li>Cargo 會儲存建構結果在 <em>target/debug</em> 目錄底下，而不是放在與我們程式碼相同的目錄。</li>
</ul>
<p>使用 Cargo 還有一項好處是在任何作業系統所使用的命令都是相同的，所以到這邊開始我們不再需要特別提供 Linux 和 macOS 相對於 Windows 不同的特殊命令。</p>
<h3><a class="header" href="#建構發佈版本release" id="建構發佈版本release">建構發佈版本（Release）</a></h3>
<p>當你的專案正式準備好要發佈的話，你可以使用 <code>cargo build --release</code> 來最佳化編譯結果。此命令會產生執行檔到 <em>target/release</em> 而不是 <em>target/debug</em>。最佳化可以讓你的 Rust 程式碼跑得更快，不過也會讓編譯的時間變得更久。這也是爲何 Cargo 提供兩種不同的設定檔（profile）：一個用來作爲開發使用，讓你可以快速並經常重新建構；另一個用來最終產生你要給使用者運行的程式用，它通常不會需要重新建構且能盡所能地跑得越快越好。如果你要做基準化分析（benchmarking）來檢測程式運行時間的話，請確認執行的是 <code>cargo build --release</code> 並使用 <em>target/release</em> 底下的執行檔做檢測。</p>
<h3><a class="header" href="#將-cargo-視爲常規" id="將-cargo-視爲常規">將 Cargo 視爲常規</a></h3>
<p>雖然在簡單的專案下，與 <code>rustc</code> 相比 Cargo 的確沒辦法突顯出什麼價值。但是當你的程式變得越來越複雜時，它將證明它的用途。在擁有一堆 crate 的龐大專案下，讓 Cargo 來協調你的專案會來的簡單許多。</p>
<p>儘管 <code>hello_cargo</code> 是個小專案，但它使用了你未來的 Rust 生涯中真實情況下會用到的工具。事實上，所有存在的專案，你幾乎都可以用以下命令完成：使用 Git 下載專案、更改至專案目錄然後建構完成。</p>
<pre><code class="language-console">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>有關 Cargo 的更多資訊，請查看它的<a href="https://doc.rust-lang.org/cargo/">技術文件</a>。</p>
<h2><a class="header" href="#總結" id="總結">總結</a></h2>
<p>你已經完成你的 Rust 旅途的第一步了！在本章節你學到了：</p>
<ul>
<li>使用 <code>rustup</code> 安裝最新穩定版 Rust</li>
<li>更新到最新 Rust 版本</li>
<li>開啟本地端安裝的技術文件</li>
<li>直接使用 <code>rustup</code> 編寫並執行一支「Hello, world!」程式</li>
<li>使用 Cargo 建立並執行一個新專案</li>
</ul>
<p>接下來是時候來建立一個更實際的程式來熟悉 Rust 程式碼的讀寫了。所以在第二章我們將寫出一支猜謎遊戲的程式。如果你想直接學習 Rust 的常見程式設計概念的話，你可直接閱讀第三章，之後再回來看第二章。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/a2e4bbfdfbdb195bf134e5a53174d7d4ab027b1f/src/ch01-03-hello-cargo.md">a2e4bbf</a></li>
<li>updated: 2020-09-05</li>
</ul>
</blockquote>
<h1><a class="header" href="#programming-a-guessing-game" id="programming-a-guessing-game">Programming a Guessing Game</a></h1>
<p>Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about <code>let</code>, <code>match</code>, methods, associated
functions, using external crates, and more! The following chapters will explore
these ideas in more detail. In this chapter, you’ll practice the fundamentals.</p>
<p>We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.</p>
<h2><a class="header" href="#setting-up-a-new-project" id="setting-up-a-new-project">Setting Up a New Project</a></h2>
<p>To set up a new project, go to the <em>projects</em> directory that you created in
Chapter 1 and make a new project using Cargo, like so:</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>The first command, <code>cargo new</code>, takes the name of the project (<code>guessing_game</code>)
as the first argument. The second command changes to the new project’s
directory.</p>
<p>Look at the generated <em>Cargo.toml</em> file:</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>If the author information that Cargo obtained from your environment is not
correct, fix that in the file and save it again.</p>
<p>As you saw in Chapter 1, <code>cargo new</code> generates a “Hello, world!” program for
you. Check out the <em>src/main.rs</em> file:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Now let’s compile this “Hello, world!” program and run it in the same step
using the <code>cargo run</code> command:</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>The <code>run</code> command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.</p>
<p>Reopen the <em>src/main.rs</em> file. You’ll be writing all the code in this file.</p>
<h2><a class="header" href="#processing-a-guess" id="processing-a-guess">Processing a Guess</a></h2>
<p>The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
<em>src/main.rs</em>.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">範例 2-1: Code that gets a guess from the user and
prints it</span></p>
<p>This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
<code>io</code> (input/output) library into scope. The <code>io</code> library comes from the
standard library (which is known as <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>By default, Rust brings only a few types into the scope of every program in
<a href="../std/prelude/index.html">the <em>prelude</em></a><!-- ignore -->. If a type you want to use isn’t in the
prelude, you have to bring that type into scope explicitly with a <code>use</code>
statement. Using the <code>std::io</code> library provides you with a number of useful
features, including the ability to accept user input.</p>
<p>As you saw in Chapter 1, the <code>main</code> function is the entry point into the
program:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>The <code>fn</code> syntax declares a new function, the parentheses, <code>()</code>, indicate there
are no parameters, and the curly bracket, <code>{</code>, starts the body of the function.</p>
<p>As you also learned in Chapter 1, <code>println!</code> is a macro that prints a string to
the screen:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>This code is printing a prompt stating what the game is and requesting input
from the user.</p>
<h3><a class="header" href="#storing-values-with-variables" id="storing-values-with-variables">Storing Values with Variables</a></h3>
<p>Next, we’ll create a place to store the user input, like this:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>Now the program is getting interesting! There’s a lot going on in this little
line. Notice that this is a <code>let</code> statement, which is used to create a
<em>variable</em>. Here’s another example:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>This line creates a new variable named <code>foo</code> and binds it to the value of the
<code>bar</code> variable. In Rust, variables are immutable by default. We’ll be
discussing this concept in detail in the <a href="ch03-01-variables-and-mutability.html#variables-and-mutability">“Variables and
Mutability”</a><!-- ignore --> section in Chapter 3.
The following example shows how to use <code>mut</code> before the variable name to make
a variable mutable:</p>
<pre><code class="language-rust ignore">let foo = 5; // immutable
let mut bar = 5; // mutable
</code></pre>
<blockquote>
<p>Note: The <code>//</code> syntax starts a comment that continues until the end of the
line. Rust ignores everything in comments, which are discussed in more detail
in Chapter 3.</p>
</blockquote>
<p>Let’s return to the guessing game program. You now know that <code>let mut guess</code>
will introduce a mutable variable named <code>guess</code>. On the other side of the equal
sign (<code>=</code>) is the value that <code>guess</code> is bound to, which is the result of
calling <code>String::new</code>, a function that returns a new instance of a <code>String</code>.
<a href="../std/string/struct.String.html"><code>String</code></a><!-- ignore --> is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.</p>
<p>The <code>::</code> syntax in the <code>::new</code> line indicates that <code>new</code> is an <em>associated
function</em> of the <code>String</code> type. An associated function is implemented on a type,
in this case <code>String</code>, rather than on a particular instance of a <code>String</code>. Some
languages call this a <em>static method</em>.</p>
<p>This <code>new</code> function creates a new, empty string. You’ll find a <code>new</code> function
on many types, because it’s a common name for a function that makes a new value
of some kind.</p>
<p>To summarize, the <code>let mut guess = String::new();</code> line has created a mutable
variable that is currently bound to a new, empty instance of a <code>String</code>. Whew!</p>
<p>Recall that we included the input/output functionality from the standard
library with <code>use std::io;</code> on the first line of the program. Now we’ll call
the <code>stdin</code> function from the <code>io</code> module:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>If we hadn’t put the <code>use std::io</code> line at the beginning of the program, we
could have written this function call as <code>std::io::stdin</code>. The <code>stdin</code> function
returns an instance of <a href="../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, which is a
type that represents a handle to the standard input for your terminal.</p>
<p>The next part of the code, <code>.read_line(&amp;mut guess)</code>, calls the
<a href="../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> method on the standard input handle to
get input from the user. We’re also passing one argument to <code>read_line</code>: <code>&amp;mut guess</code>.</p>
<p>The job of <code>read_line</code> is to take whatever the user types into standard input
and place that into a string, so it takes that string as an argument. The
string argument needs to be mutable so the method can change the string’s
content by adding the user input.</p>
<p>The <code>&amp;</code> indicates that this argument is a <em>reference</em>, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write <code>&amp;mut guess</code> rather than
<code>&amp;guess</code> to make it mutable. (Chapter 4 will explain references more
thoroughly.)</p>
<h3><a class="header" href="#使用-result-型別處理可能的錯誤" id="使用-result-型別處理可能的錯誤">使用 <code>Result</code> 型別處理可能的錯誤</a></h3>
<p>We’re still working on this line of code. Although we’re now discussing a third
line of text, it’s still part of a single logical line of code. The next part
is this method:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">}
</span></code></pre>
<p>When you call a method with the <code>.foo()</code> syntax, it’s often wise to introduce a
newline and other whitespace to help break up long lines. We could have
written this code as:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>However, one long line is difficult to read, so it’s best to divide it. Now
let’s discuss what this line does.</p>
<p>As mentioned earlier, <code>read_line</code> puts what the user types into the string
we’re passing it, but it also returns a value—in this case, an
<a href="../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust has a number of types named
<code>Result</code> in its standard library: a generic <a href="../std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->
as well as specific versions for submodules, such as <code>io::Result</code>.</p>
<p>The <code>Result</code> types are <a href="ch06-00-enums.html"><em>enumerations</em></a><!-- ignore -->, often referred
to as <em>enums</em>. An enumeration is a type that can have a fixed set of values,
and those values are called the enum’s <em>variants</em>. Chapter 6 will cover enums
in more detail.</p>
<p>For <code>Result</code>, the variants are <code>Ok</code> or <code>Err</code>. The <code>Ok</code> variant indicates the
operation was successful, and inside <code>Ok</code> is the successfully generated value.
The <code>Err</code> variant means the operation failed, and <code>Err</code> contains information
about how or why the operation failed.</p>
<p>The purpose of these <code>Result</code> types is to encode error-handling information.
Values of the <code>Result</code> type, like values of any type, have methods defined on
them. An instance of <code>io::Result</code> has an <a href="../std/result/enum.Result.html#method.expect"><code>expect</code> method</a><!-- ignore
--> that you can call. If this instance of <code>io::Result</code> is an <code>Err</code> value,
<code>expect</code> will cause the program to crash and display the message that you
passed as an argument to <code>expect</code>. If the <code>read_line</code> method returns an <code>Err</code>,
it would likely be the result of an error coming from the underlying operating
system. If this instance of <code>io::Result</code> is an <code>Ok</code> value, <code>expect</code> will take
the return value that <code>Ok</code> is holding and return just that value to you so you
can use it. In this case, that value is the number of bytes in what the user
entered into standard input.</p>
<p>If you don’t call <code>expect</code>, the program will compile, but you’ll get a warning:</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` that must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Rust warns that you haven’t used the <code>Result</code> value returned from <code>read_line</code>,
indicating that the program hasn’t handled a possible error.</p>
<p>The right way to suppress the warning is to actually write error handling, but
because you just want to crash this program when a problem occurs, you can use
<code>expect</code>. You’ll learn about recovering from errors in Chapter 9.</p>
<h3><a class="header" href="#printing-values-with-println-placeholders" id="printing-values-with-println-placeholders">Printing Values with <code>println!</code> Placeholders</a></h3>
<p>Aside from the closing curly bracket, there’s only one more line to discuss in
the code added so far, which is the following:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>    println!(&quot;You guessed: {}&quot;, guess);
<span class="boring">}
</span></code></pre>
<p>This line prints the string we saved the user’s input in. The set of curly
brackets, <code>{}</code>, is a placeholder: think of <code>{}</code> as little crab pincers that
hold a value in place. You can print more than one value using curly brackets:
the first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to <code>println!</code> would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>This code would print <code>x = 5 and y = 10</code>.</p>
<h3><a class="header" href="#testing-the-first-part" id="testing-the-first-part">Testing the First Part</a></h3>
<p>Let’s test the first part of the guessing game. Run it using <code>cargo run</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.</p>
<h2><a class="header" href="#generating-a-secret-number" id="generating-a-secret-number">Generating a Secret Number</a></h2>
<p>Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. Let’s use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>.</p>
<h3><a class="header" href="#using-a-crate-to-get-more-functionality" id="using-a-crate-to-get-more-functionality">Using a Crate to Get More Functionality</a></h3>
<p>Remember that a crate is a collection of Rust source code files.
The project we’ve been building is a <em>binary crate</em>, which is an executable.
The <code>rand</code> crate is a <em>library crate</em>, which contains code intended to be
used in other programs.</p>
<p>Cargo’s use of external crates is where it really shines. Before we can write
code that uses <code>rand</code>, we need to modify the <em>Cargo.toml</em> file to include the
<code>rand</code> crate as a dependency. Open that file now and add the following line to
the bottom beneath the <code>[dependencies]</code> section header that Cargo created for
you:</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>In the <em>Cargo.toml</em> file, everything that follows a header is part of a section
that continues until another section starts. The <code>[dependencies]</code> section is
where you tell Cargo which external crates your project depends on and which
versions of those crates you require. In this case, we’ll specify the <code>rand</code>
crate with the semantic version specifier <code>0.5.5</code>. Cargo understands <a href="http://semver.org">Semantic
Versioning</a><!-- ignore --> (sometimes called <em>SemVer</em>), which is a
standard for writing version numbers. The number <code>0.5.5</code> is actually shorthand
for <code>^0.5.5</code>, which means “any version that has a public API compatible with
version 0.5.5.”</p>
<p>Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo clean
cargo build -->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
  Downloaded libc v0.2.62
  Downloaded rand_core v0.2.2
  Downloaded rand_core v0.3.1
  Downloaded rand_core v0.4.2
   Compiling rand_core v0.4.2
   Compiling libc v0.2.62
   Compiling rand_core v0.3.1
   Compiling rand_core v0.2.2
   Compiling rand v0.5.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<p><span class="caption">範例 2-2: The output from running <code>cargo build</code> after
adding the rand crate as a dependency</span></p>
<p>You may see different version numbers (but they will all be compatible with
the code, thanks to SemVer!), different lines (depending on the operating system), and the lines may be in a different order.</p>
<p>Now that we have an external dependency, Cargo fetches the latest versions of
everything from the <em>registry</em>, which is a copy of data from
<a href="https://crates.io/">Crates.io</a>. Crates.io is where people in the Rust ecosystem post
their open source Rust projects for others to use.</p>
<p>After updating the registry, Cargo checks the <code>[dependencies]</code> section and
downloads any crates you don’t have yet. In this case, although we only listed
<code>rand</code> as a dependency, Cargo also grabbed <code>libc</code> and <code>rand_core</code>, because
<code>rand</code> depends on those to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.</p>
<p>If you immediately run <code>cargo build</code> again without making any changes, you
won’t get any output aside from the <code>Finished</code> line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your <em>Cargo.toml</em> file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.</p>
<p>If you open up the <em>src/main.rs</em> file, make a trivial change, and then save it
and build again, you’ll only see two lines of output:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>These lines show Cargo only updates the build with your tiny change to the
<em>src/main.rs</em> file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those. It just rebuilds
your part of the code.</p>
<h4><a class="header" href="#ensuring-reproducible-builds-with-the-cargolock-file" id="ensuring-reproducible-builds-with-the-cargolock-file">Ensuring Reproducible Builds with the <em>Cargo.lock</em> File</a></h4>
<p>Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, what
happens if next week version 0.5.6 of the <code>rand</code> crate comes out and
contains an important bug fix but also contains a regression that will break
your code?</p>
<p>The answer to this problem is the <em>Cargo.lock</em> file, which was created the
first time you ran <code>cargo build</code> and is now in your <em>guessing_game</em> directory.
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the <em>Cargo.lock</em> file. When you build your project in the future, Cargo will
see that the <em>Cargo.lock</em> file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at <code>0.5.5</code> until you explicitly upgrade, thanks to the <em>Cargo.lock</em>
file.</p>
<h4><a class="header" href="#updating-a-crate-to-get-a-new-version" id="updating-a-crate-to-get-a-new-version">Updating a Crate to Get a New Version</a></h4>
<p>When you <em>do</em> want to update a crate, Cargo provides another command, <code>update</code>,
which will ignore the <em>Cargo.lock</em> file and figure out all the latest versions
that fit your specifications in <em>Cargo.toml</em>. If that works, Cargo will write
those versions to the <em>Cargo.lock</em> file.</p>
<p>But by default, Cargo will only look for versions greater than <code>0.5.5</code> and less
than <code>0.6.0</code>. If the <code>rand</code> crate has released two new versions, <code>0.5.6</code> and
<code>0.6.0</code>, you would see the following if you ran <code>cargo update</code>:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.5.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    Updating rand v0.5.5 -&gt; v0.5.6
</code></pre>
<p>At this point, you would also notice a change in your <em>Cargo.lock</em> file noting
that the version of the <code>rand</code> crate you are now using is <code>0.5.6</code>.</p>
<p>If you wanted to use <code>rand</code> version <code>0.6.0</code> or any version in the <code>0.6.x</code>
series, you’d have to update the <em>Cargo.toml</em> file to look like this instead:</p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.6.0&quot;
</code></pre>
<p>The next time you run <code>cargo build</code>, Cargo will update the registry of crates
available and reevaluate your <code>rand</code> requirements according to the new version
you have specified.</p>
<p>There’s a lot more to say about <a href="http://doc.crates.io">Cargo</a><!-- ignore --> and <a href="http://doc.crates.io/crates-io.html">its
ecosystem</a><!-- ignore --> which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.</p>
<h3><a class="header" href="#generating-a-random-number" id="generating-a-random-number">Generating a Random Number</a></h3>
<p>Now that you’ve added the <code>rand</code> crate to <em>Cargo.toml</em>, let’s start using
<code>rand</code>. The next step is to update <em>src/main.rs</em>, as shown in Listing 2-3.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">範例 2-3: Adding code to generate a random
number</span></p>
<p>First, we add a <code>use</code> line: <code>use rand::Rng</code>. The <code>Rng</code> trait defines
methods that random number generators implement, and this trait must be in
scope for us to use those methods. Chapter 10 will cover traits in detail.</p>
<p>Next, we’re adding two lines in the middle. The <code>rand::thread_rng</code> function
will give us the particular random number generator that we’re going to use:
one that is local to the current thread of execution and seeded by the
operating system. Then we call the <code>gen_range</code> method on the random number
generator. This method is defined by the <code>Rng</code> trait that we brought into
scope with the <code>use rand::Rng</code> statement. The <code>gen_range</code> method takes two
numbers as arguments and generates a random number between them. It’s inclusive
on the lower bound but exclusive on the upper bound, so we need to specify <code>1</code>
and <code>101</code> to request a number between 1 and 100.</p>
<blockquote>
<p>Note: You won’t just know which traits to use and which methods and functions
to call from a crate. Instructions for using a crate are in each crate’s
documentation. Another neat feature of Cargo is that you can run the <code>cargo doc --open</code> command, which will build documentation provided by all of your
dependencies locally and open it in your browser. If you’re interested in
other functionality in the <code>rand</code> crate, for example, run <code>cargo doc --open</code>
and click <code>rand</code> in the sidebar on the left.</p>
</blockquote>
<p>The second line that we added to the middle of the code prints the secret
number. This is useful while we’re developing the program to be able to test
it, but we’ll delete it from the final version. It’s not much of a game if the
program prints the answer as soon as it starts!</p>
<p>Try running the program a few times:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>You should get different random numbers, and they should all be numbers between
1 and 100. Great job!</p>
<h2><a class="header" href="#將猜測的數字與祕密數字做比較" id="將猜測的數字與祕密數字做比較">將猜測的數字與祕密數字做比較</a></h2>
<p>Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile quite yet, as we
will explain.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">範例 2-4: Handling the possible return values of
comparing two numbers</span></p>
<p>The first new bit here is another <code>use</code> statement, bringing a type called
<code>std::cmp::Ordering</code> into scope from the standard library. Like <code>Result</code>,
<code>Ordering</code> is another enum, but the variants for <code>Ordering</code> are <code>Less</code>,
<code>Greater</code>, and <code>Equal</code>. These are the three outcomes that are possible when you
compare two values.</p>
<p>Then we add five new lines at the bottom that use the <code>Ordering</code> type. The
<code>cmp</code> method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing the <code>guess</code> to the <code>secret_number</code>. Then it returns a variant of the
<code>Ordering</code> enum we brought into scope with the <code>use</code> statement. We use a
<a href="ch06-02-match.html"><code>match</code></a><!-- ignore --> expression to decide what to do next based on
which variant of <code>Ordering</code> was returned from the call to <code>cmp</code> with the values
in <code>guess</code> and <code>secret_number</code>.</p>
<p>A <code>match</code> expression is made up of <em>arms</em>. An arm consists of a <em>pattern</em> and
the code that should be run if the value given to the beginning of the <code>match</code>
expression fits that arm’s pattern. Rust takes the value given to <code>match</code> and
looks through each arm’s pattern in turn. The <code>match</code> construct and patterns
are powerful features in Rust that let you express a variety of situations your
code might encounter and make sure that you handle them all. These features
will be covered in detail in Chapter 6 and Chapter 18, respectively.</p>
<p>Let’s walk through an example of what would happen with the <code>match</code> expression
used here. Say that the user has guessed 50 and the randomly generated secret
number this time is 38. When the code compares 50 to 38, the <code>cmp</code> method will
return <code>Ordering::Greater</code>, because 50 is greater than 38. The <code>match</code>
expression gets the <code>Ordering::Greater</code> value and starts checking each arm’s
pattern. It looks at the first arm’s pattern, <code>Ordering::Less</code>, and sees that
the value <code>Ordering::Greater</code> does not match <code>Ordering::Less</code>, so it ignores
the code in that arm and moves to the next arm. The next arm’s pattern,
<code>Ordering::Greater</code>, <em>does</em> match <code>Ordering::Greater</code>! The associated code in
that arm will execute and print <code>Too big!</code> to the screen. The <code>match</code>
expression ends because it has no need to look at the last arm in this scenario.</p>
<p>However, the code in Listing 2-4 won’t compile yet. Let’s try it:</p>
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.51
   Compiling rand_core v0.4.0
   Compiling rand_core v0.3.1
   Compiling rand v0.5.6
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integer
   |
   = note: expected reference `&amp;std::string::String`
              found reference `&amp;{integer}`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing_game`.

To learn more, run the command again with --verbose.
</code></pre>
<p>The core of the error states that there are <em>mismatched types</em>. Rust has a
strong, static type system. However, it also has type inference. When we wrote
<code>let mut guess = String::new()</code>, Rust was able to infer that <code>guess</code> should be
a <code>String</code> and didn’t make us write the type. The <code>secret_number</code>, on the other
hand, is a number type. A few number types can have a value between 1 and 100:
<code>i32</code>, a 32-bit number; <code>u32</code>, an unsigned 32-bit number; <code>i64</code>, a 64-bit
number; as well as others. Rust defaults to an <code>i32</code>, which is the type of
<code>secret_number</code> unless you add type information elsewhere that would cause Rust
to infer a different numerical type. The reason for the error is that Rust
cannot compare a string and a number type.</p>
<p>Ultimately, we want to convert the <code>String</code> the program reads as input into a
real number type so we can compare it numerically to the secret number. We can
do that by adding another line to the <code>main</code> function body:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>The line is:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</code></pre>
<p>We create a variable named <code>guess</code>. But wait, doesn’t the program already have
a variable named <code>guess</code>? It does, but Rust allows us to <em>shadow</em> the previous
value of <code>guess</code> with a new one. This feature is often used in situations in
which you want to convert a value from one type to another type. Shadowing lets
us reuse the <code>guess</code> variable name rather than forcing us to create two unique
variables, such as <code>guess_str</code> and <code>guess</code> for example. (Chapter 3 covers
shadowing in more detail.)</p>
<p>We bind <code>guess</code> to the expression <code>guess.trim().parse()</code>. The <code>guess</code> in the
expression refers to the original <code>guess</code> that was a <code>String</code> with the input in
it. The <code>trim</code> method on a <code>String</code> instance will eliminate any whitespace at
the beginning and end. Although <code>u32</code> can contain only numerical characters,
the user must press <span class="keystroke">enter</span> to satisfy
<code>read_line</code>. When the user presses <span class="keystroke">enter</span>, a
newline character is added to the string. For example, if the user types <span
class="keystroke">5</span> and presses <span class="keystroke">enter</span>,
<code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents “newline,” the result of
pressing <span class="keystroke">enter</span>. The <code>trim</code> method eliminates
<code>\n</code>, resulting in just <code>5</code>.</p>
<p>The <a href="../std/primitive.str.html#method.parse"><code>parse</code> method on strings</a><!-- ignore --> parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using <code>let guess: u32</code>. The
colon (<code>:</code>) after <code>guess</code> tells Rust we’ll annotate the variable’s type. Rust
has a few built-in number types; the <code>u32</code> seen here is an unsigned, 32-bit
integer. It’s a good default choice for a small positive number. You’ll learn
about other number types in Chapter 3. Additionally, the <code>u32</code> annotation in
this example program and the comparison with <code>secret_number</code> means that Rust
will infer that <code>secret_number</code> should be a <code>u32</code> as well. So now the
comparison will be between two values of the same type!</p>
<p>The call to <code>parse</code> could easily cause an error. If, for example, the string
contained <code>A👍%</code>, there would be no way to convert that to a number. Because it
might fail, the <code>parse</code> method returns a <code>Result</code> type, much as the <code>read_line</code>
method does (discussed earlier in <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“Handling Potential Failure with the
<code>Result</code> Type”</a><!-- ignore
-->). We’ll treat this <code>Result</code> the same way by using the <code>expect</code> method
again. If <code>parse</code> returns an <code>Err</code> <code>Result</code> variant because it couldn’t create
a number from the string, the <code>expect</code> call will crash the game and print the
message we give it. If <code>parse</code> can successfully convert the string to a number,
it will return the <code>Ok</code> variant of <code>Result</code>, and <code>expect</code> will return the
number that we want from the <code>Ok</code> value.</p>
<p>Let’s run the program now!</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
cargo run
  76
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.</p>
<p>We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!</p>
<h2><a class="header" href="#allowing-multiple-guesses-with-looping" id="allowing-multiple-guesses-with-looping">Allowing Multiple Guesses with Looping</a></h2>
<p>The <code>loop</code> keyword creates an infinite loop. We’ll add that now to give users
more chances at guessing the number:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>As you can see, we’ve moved everything into a loop from the guess input prompt
onward. Be sure to indent the lines inside the loop another four spaces each
and run the program again. Notice that there is a new problem because the
program is doing exactly what we told it to do: ask for another guess forever!
It doesn’t seem like the user can quit!</p>
<p>The user could always interrupt the program by using the keyboard shortcut <span
class="keystroke">ctrl-c</span>. But there’s another way to escape this
insatiable monster, as mentioned in the <code>parse</code> discussion in <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the
Guess to the Secret Number”</a><!--
ignore -->: if the user enters a non-number answer, the program will crash. The
user can take advantage of that in order to quit, as shown here:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:999:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Typing <code>quit</code> actually quits the game, but so will any other non-number input.
However, this is suboptimal to say the least. We want the game to automatically
stop when the correct number is guessed.</p>
<h3><a class="header" href="#猜對後離開" id="猜對後離開">猜對後離開</a></h3>
<p>Let’s program the game to quit when the user wins by adding a <code>break</code> statement:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adding the <code>break</code> line after <code>You win!</code> makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of <code>main</code>.</p>
<h3><a class="header" href="#handling-invalid-input" id="handling-invalid-input">Handling Invalid Input</a></h3>
<p>To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where <code>guess</code>
is converted from a <code>String</code> to a <code>u32</code>, as shown in Listing 2-5.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span></p>
<p>Switching from an <code>expect</code> call to a <code>match</code> expression is how you generally
move from crashing on an error to handling the error. Remember that <code>parse</code>
returns a <code>Result</code> type and <code>Result</code> is an enum that has the variants <code>Ok</code> or
<code>Err</code>. We’re using a <code>match</code> expression here, as we did with the <code>Ordering</code>
result of the <code>cmp</code> method.</p>
<p>If <code>parse</code> is able to successfully turn the string into a number, it will
return an <code>Ok</code> value that contains the resulting number. That <code>Ok</code> value will
match the first arm’s pattern, and the <code>match</code> expression will just return the
<code>num</code> value that <code>parse</code> produced and put inside the <code>Ok</code> value. That number
will end up right where we want it in the new <code>guess</code> variable we’re creating.</p>
<p>If <code>parse</code> is <em>not</em> able to turn the string into a number, it will return an
<code>Err</code> value that contains more information about the error. The <code>Err</code> value
does not match the <code>Ok(num)</code> pattern in the first <code>match</code> arm, but it does
match the <code>Err(_)</code> pattern in the second arm. The underscore, <code>_</code>, is a
catchall value; in this example, we’re saying we want to match all <code>Err</code>
values, no matter what information they have inside them. So the program will
execute the second arm’s code, <code>continue</code>, which tells the program to go to the
next iteration of the <code>loop</code> and ask for another guess. So, effectively, the
program ignores all errors that <code>parse</code> might encounter!</p>
<p>Now everything in the program should work as expected. Let’s try it:</p>
<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the <code>println!</code> that outputs the
secret number. Listing 2-6 shows the final code.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">範例 2-6: Complete guessing game code</span></p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>At this point, you’ve successfully built the guessing game. Congratulations!</p>
<p>This project was a hands-on way to introduce you to many new Rust concepts:
<code>let</code>, <code>match</code>, methods, associated functions, the use of external crates, and
more. In the next few chapters, you’ll learn about these concepts in more
detail. Chapter 3 covers concepts that most programming languages have, such as
variables, data types, and functions, and shows how to use them in Rust.
Chapter 4 explores ownership, a feature that makes Rust different from other
languages. Chapter 5 discusses structs and method syntax, and Chapter 6
explains how enums work.</p>
<h1><a class="header" href="#常見程式設計概念" id="常見程式設計概念">常見程式設計概念</a></h1>
<p>此章節涵蓋了幾乎所有程式語言都會出現的概念，以及如何在 Rust 使用。許多程式語言的核心概念都是相同的，所以此章節所介紹的概念也不是 Rust 所特有的。不過我們會用 Rust 的程式碼來討論它們，並解釋使用這些概念的慣例。</p>
<p>更明確來說，你將會學習到變數、基本型別、註釋以及控制流程。這些基本概念會出現在每個 Rust 程式中，所以提早學習這些概念可以爲你打下穩健的基礎。</p>
<blockquote>
<h4><a class="header" href="#關鍵字keywords" id="關鍵字keywords">關鍵字（Keywords）</a></h4>
<p>Rust 程式語言和其他語言一樣會保留一系列的 <em>關鍵字（keywords）</em>。請注意你將無法用這些字作爲變數或函式名稱。大多數關鍵字都有特別意義，而你將會在你的 Rust 程式使用它們在做不同的任務；而有一些目前則還沒有任何用途，但是在未來可能會被 Rust 加入所以作爲保留。你可以在<a href="appendix-01-keywords.html">附錄 A</a> 查看關鍵字列表。</p>
</blockquote>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/f5a00f4d5107d5e69f556dcae9e91685c9f414d8/src/ch03-00-common-programming-concepts.md">f5a00f4</a></li>
<li>updated: 2020-09-05</li>
</ul>
</blockquote>
<h2><a class="header" href="#變數與可變性" id="變數與可變性">變數與可變性</a></h2>
<p>如同第二章提到的，變數預設是不可變的。這是 Rust 推動你能充分利用 Rust 提供的安全性和簡單地並行性來寫程式的許多方法之一。不過，你還是有辦法能讓你的變數成爲可變的。讓我們來探討爲何 Rust 鼓勵你多多使用不可變，以及何時你會想要改爲可變的。</p>
<p>當一個變數是不可變的，只要有數值綁定在一個名字上，你就無法改變其值。爲了方便說明，讓我們使用 <code>cargo new variables</code> 在 <em>projects</em> 目錄下產生一個新專案叫做 <em>variables</em>。</p>
<p>再來在你的新 <em>variables</em> 目錄下開啟 <em>src/main.rs</em> 然後覆蓋程式碼爲以下內容，這是段還無法編譯的程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>儲存然後使用 <code>cargo run</code> 執行程式。你應該會收到一則錯誤訊息，如下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables`.

To learn more, run the command again with --verbose.
</code></pre>
<p>此範例顯示了編譯器如何協助你找到你程式碼的錯誤。雖然看到編譯器錯誤訊息總是令人感到沮喪，但這通常是爲了讓你知道你的程式無法安全地完成你想讓它完成的任務。它們 <em>不代表</em> 你不是個優秀的程式設計師！有經驗的 Rustaceans 時常會與編譯器錯誤訊息打交道。</p>
<p>這則錯誤訊息表示錯誤發生的原因：「cannot assign twice to immutable variable x」，因爲你嘗試第二次賦值給 <code>x</code> 變數。</p>
<p>當我們嘗試改變一個原先設計爲不可變的變數時，能夠產生編譯時錯誤是很重要的。因爲這樣的情況很容易導致程式錯誤。如果我們有一部分的程式碼在執行時認爲某個數值絕對不會改變，但另一部分的程式碼卻更改了其值，那麼這就有可能讓前一部分的程式碼就可能以無法預測的方式運行。這樣的程式錯誤的起因是很難追蹤的，尤其是當第二部分的程式碼<em>偶而</em>才會改變其值。</p>
<p>在 Rust 中，編譯器會保證當你宣告一個數值不會被改變時，它就絕對不會被改變。這代表當你讀寫程式碼時，你不需要去追蹤該值可能會被改變，讓你的程式碼更容易推導。</p>
<p>但同時可變性也是非常有用的，變數只有預設是不可變的，就如同第二章一樣你可以在變數名稱前面加上 <code>mut</code> 讓它們可以成爲可變的。除了允許改變其值之外，<code>mut</code> 像未來的讀取者表明了其他部分的程式碼將會改變此變數的數值。</p>
<p>舉例來說，讓我們改變 <em>src/main.rs</em>  成以下程式碼：</p>
<p><span class="filename">檔案內容：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>當你執行程式的話，我們會得到：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>當使用 <code>mut</code> 時，我們可以將 <code>x</code> 的數值錯從 <code>5</code> 改變爲 <code>6</code>。有時候比起只有不可變變數，你會想要將某些變數改爲可變的，讓它更容易編寫。</p>
<p>當然除了防止程式錯誤以外，這還有很多權衡取捨。舉例來說，當你擁有一個大型資料結構時，變更其值通常會比複製然後返回重新分配的實例還來的快。不過在比較小的資料結構，用函式程式語言的風格產生新的實例會比較容易思考，所以損失一些效能會比損失閱讀性來得好。</p>
<h3><a class="header" href="#變數與常數的差異" id="變數與常數的差異">變數與常數的差異</a></h3>
<p>不能夠變更數值的情況可能會讓你聯想到其他程式語言都有的概念：<em>常數（constants）</em>。和不可變變數一樣，常數會讓數值與名稱綁定且不允許被改變，但是不可變變數與常數還是有些差異。</p>
<p>首先，你無法在使用常數使用 <code>mut</code>，常數不是預設不可變，它們永遠都不可變。</p>
<p>如果你使用 <code>const</code> 宣告而非 <code>let</code> 的話，你<em>必須</em>指明型別。我們會在下一章<a href="ch03-02-data-types.html#data-types">「資料型別」</a><!-- ignore -->詳細解釋型別與型別詮釋，所以現在先別擔心細節。你只需要先知道你永遠必須先詮釋常數的型別。</p>
<p>常數可以被定義在任一有效範圍，包含全域有效範圍。這讓它們非常有用，讓許多部分的程式碼都能夠知道它們。</p>
<p>最後一個差別是常數只能被常數表達式設置，而不能用函式的結果或任一在運行時產生的其他數值設置。</p>
<p>以下爲一個常數名稱被宣告爲 <code>MAX_POINTS</code> 的範例，它的數值被設爲 100,000。（Rust 的常數命名規則爲使用全部英文大寫並用底寫區隔每個單字，數值可以用底下區隔來改善可讀性）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<p>常數砸愛整支程式運行時在它們的有效範圍都是有效的，讓它們可以作爲處理許多程式碼部分的全域範圍數值，像是一款遊戲中玩家能夠得到的最高分數或者光速的數值。</p>
<p>將會擴散到你所有程式碼的數值定義爲常數，對於幫助未來程式碼的維護者理解是非常好的選擇。這也讓未來需要更新數值的話，你知道需要修改寫死的地方就好。</p>
<h3><a class="header" href="#遮蔽shadowing" id="遮蔽shadowing">遮蔽（Shadowing）</a></h3>
<p>如同你在猜謎遊戲教學所看到的，在第二章<a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">「將猜測的數字與祕密數字做比較」</a><!-- ignore --> 你可以用之前的變數再次宣告新的變數，然後新的變數就會遮蔽之前的變數。Rustaceans 會說第一個變數被第二個變數所<em>遮蔽</em>了，這代表該變數被使用時會拿到第二個變數的數值。我們可以用 <code>let</code> 關鍵字來重複宣告相同的變數名稱來遮蔽一個變數：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>此程式首先將 <code>x</code> 給與 <code>5</code>，然後它用 <code>let x =</code> 遮蔽了 <code>x</code> 變數取代了原本的變數變爲 <code>6</code>。第三次的 <code>let</code> 陳述式一樣遮蔽了 <code>x</code> 讓它將原本的值乘與 <code>2</code>，讓 <code>x</code> 最終的數值爲 <code>12</code>。當我們運行此程式時，當會輸出以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x is: 12
</code></pre>
<p>遮蔽與標記變數爲 <code>mut</code> 是不一樣的，因爲如果我們不小心重新賦值而沒有加上 <code>let</code> 關鍵字的話，是會產生編譯期錯誤的。使用 <code>let</code> 的話，我們可以作出一些改變，然後在這之後該變數仍然是不可變的。</p>
<p>另一個 <code>mut</code> 與遮蔽不同的地方是，爲我們能有效地再次運用 <code>let</code> 產生新的變數，我們可以在重新運用相同名稱時改變它的型別。舉例來說，當我們希望程式要求使用者顯示出字串間應該顯示多少空格，但同時我們又希望它被存爲一個數字，我們可以這樣做：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>這個範例是被允許的是因爲第一次宣告 <code>spaces</code> 的變數雖然是一個字串型別，但在第二次宣告儘管用了同樣的名稱，但是我們卻能遮蔽成數字型別。遮蔽這項功能讓我們不必去宣告像是 <code>spaces_str</code> 與 <code>spaces_num</code>，我們可以重複使用 <code>spaces</code> 這個變數名稱。不過，可變變數仍然是無法變更變數型別的，如果這樣做的話我們就會拿到編譯期錯誤：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
<span class="boring">}
</span></code></pre>
<p>此錯誤訊息告訴我們我們不與許改變變數的型別：</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Now that we’ve explored how variables work, let’s look at more data types they
can have.</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch03-01-variables-and-mutability.md">d44317c</a></li>
<li>updated: 2020-09-05</li>
</ul>
</blockquote>
<h2><a class="header" href="#資料型別" id="資料型別">資料型別</a></h2>
<p>每個數值在 Rust 中都屬於某種<em>資料型別</em>，這告訴 Rust 何種資料被指定，好讓它能妥善處理資料。我們講討論講種資料型別子集：純量（scalar）與複合（compound）。</p>
<p>請記住 Rust 是一門<em>靜態型別</em>語言，這代表它必須在編譯時知道所有變數的型別。編譯器通常能依據數值與我們使用的方式推導出我們想使用的型別。但有時後如果多種型別都有可能時，像是第二章的<a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">「將猜測的數字與祕密數字做比較」</a><!-- ignore -->用到的 <code>parse</code> 將 <code>String</code> 轉換成數字時，我們就需要像這樣加上型別詮釋： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>如果我們沒有加上型別詮釋的話，Rust 將會顯示以下錯誤訊息。這表示編譯器需要我們給予更多資訊才能夠知道我們想用何種型別：</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`.

To learn more, run the command again with --verbose.
</code></pre>
<p>你將會看到其他資料型別的各種型別詮釋。</p>
<h3><a class="header" href="#純量型別" id="純量型別">純量型別</a></h3>
<p><em>純量</em>型別代表單一數值。Rust 有四種主要純量型別：整數、浮點數、布林以及字元。你應該在其他程式語言就看過它們了，讓我們來看看它們在 Rust 是怎麼使用的：</p>
<h4><a class="header" href="#整數型別" id="整數型別">整數型別</a></h4>
<p><em>整數</em>是沒有小數點的數字。我們在第二章用到了一個整數型別 <code>u32</code>，此型別表示其擁有的數值應該是一個佔 32 位元大小的非帶號整數（帶號整數的話則是用 <code>i</code> 起頭而非 <code>u</code>）。表格 3-1 展示了 Rust 中內建的整數型別。帶號與非帶號的每一變體（比如 <code>i16</code>）都可以用來宣告一個整數數值。</p>
<p><span class="caption">表格 3-1：Rust 中的整數型別</span></p>
<table><thead><tr><th>長度</th><th>帶號</th><th>非帶號</th></tr></thead><tbody>
<tr><td>8 位元</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 位元</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 位元</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 位元</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128 位元</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>系統架構</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>每個變體都可以是帶號或非帶號的，並且都有明確的大小。<em>帶號</em>與<em>非帶號</em>的區別是數字能不能有負數，換句話說就是數字能否帶有正負符號，如果沒有的話那就只會出現正整數而已。就像在紙上寫數字一樣：當我們需要考慮符號時，我們就會在數字前面加上正負號；但如果我們只在意正整數的話，那它可以不帶符號。帶號數字是以<a href="https://zh.wikipedia.org/zh-tw/%E4%BA%8C%E8%A3%9C%E6%95%B8">二補數</a>的方式儲存。</p>
<p>每一帶號變體可以儲存的數字範圍包含從 -(2<sup>n - 1</sup>) 到 2<sup>n - 1</sup> - 1 以內的數字，<em>n</em> 就是該變體佔用的位元大小。所以一個 <code>i8</code> 可以儲存的數字範圍就是錯誤從 -(2<sup>7</sup>) 到 2<sup>7</sup> - 1，有就是 -128 到 127。而非帶號可以儲存的數字範圍則是從 0 到 2<sup>n</sup> - 1，所以 <code>u8</code> 可以儲存的範圍是從 0 到 2<sup>8</sup> - 1，也就是 0 到 255。</p>
<p>另外，<code>isize</code> 與 <code>usize</code> 型別則是依據你程式運行的電腦架構來決定大小：如果你在 64 位元架構上的話就是 64 位元；如果你是 32 位元架構的話就是 32 位元。</p>
<p>你可以用表格 3-2 列的格式來寫出整數字面值。注意除了位元組（Byte）的方式以外，所有的數字字面值都允許在最後面加上型別，比如說 <code>57u8</code>。另外也可以加上底線 <code>_</code> 分隔方便閱讀，比如說 <code>1_000</code>。</p>
<p><span class="caption">表格 3-2：Rust 中的整數字面值</span></p>
<table><thead><tr><th>數字字面值</th><th>範例</th></tr></thead><tbody>
<tr><td>十進制</td><td><code>98_222</code></td></tr>
<tr><td>十六進制</td><td><code>0xff</code></td></tr>
<tr><td>八進制</td><td><code>0o77</code></td></tr>
<tr><td>二進制</td><td><code>0b1111_0000</code></td></tr>
<tr><td>位元組（僅限<code>u8</code>）</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>所以你該用哪些整數型別呢？如果你不確定的話，Rust 預設的型別通常就很好了，整數型別預設是 <code>i32</code>：此型別通常是最快的，甚至在 62 位元系統上也是。而你會用到 <code>isize</code> 或 <code>usize</code> 的主要時機是作爲某些集合的索引。</p>
<blockquote>
<h5><a class="header" href="#整數溢位" id="整數溢位">整數溢位</a></h5>
<p>假設你有個變數型別是 <code>u8</code> 可以儲存 0 到 255 的數值。如果你想要改變變數的值超出這個範圍的話，比方說像是 256，那麼就會發生<em>整數溢位</em>。Rust 有一些有趣的規則來處理這項行爲。如果你是在除錯模式編譯的話，Rust 會包含整數溢位的檢查，造成你的程式在運行時<em>恐慌（panic）</em>。Rust 使用恐慌來表示程式因錯誤而結束，我們會在第九章的<a href="ch09-01-unrecoverable-errors-with-panic.html">「對無法復原的錯誤使用 <code>panic!</code>」</a><!-- ignore -->段落討論更多造成恐慌的細節。</p>
<p>當你是在發佈模式下用 <code>--release</code> 來編譯的話，Rsut 則<em>不會</em>加上整數溢位的檢查而造成恐慌。相反地，如果發生整數溢位的話，Rust 會作出<em>二補數包裝</em>的動作。簡單來說，超出最大值的數值可以被<em>包裝</em>成該型別的最低數值。以 <code>u8</code> 爲例的話，256 會變成 0、257 會變成 1，以此類推。程式不會恐慌，但是該變數可能會得到一個不是你原本預期的數值。通常依靠整數溢位的行爲仍然會被視爲邏輯錯誤，如果你想要安全顯式表達這種行爲的話，你可以使用標準函式庫的型別 <a href="../std/num/struct.Wrapping.html"><code>Wrapping</code></a>。</p>
</blockquote>
<h4><a class="header" href="#浮點數型別" id="浮點數型別">浮點數型別</a></h4>
<p>Rust 還有針對有小數點的<em>浮點數</em>提供兩種基本型別：<code>f32</code> 和 <code>f64</code>，分別佔有 32 位元與 64 位元的大小。而與設的型別爲 <code>f64</code>，因爲現代的電腦處理的速度幾乎和 <code>f32</code> 一樣卻還能擁有更高的精準度。</p>
<p>以下爲展示浮點數的範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>浮點數是依照 IEEE-754 所定義的，<code>f32</code> 型別是單精度浮點數，而 <code>f64</code> 是倍精度浮點數。</p>
<h4><a class="header" href="#數值運算" id="數值運算">數值運算</a></h4>
<p>Rust 支援你所有想得到的數值型別基本運算：加法、減法、乘法、除法和取餘。以下程式碼展示出如何在 <code>let</code> 陳述式使用這些運算：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>每一個陳述式中的表達式都使用了一個數學運算符號並計算出一個數值出來，賦值給該變數。附錄 B 有提供列表列出 Rust 所提供的所有運算子。</p>
<h4><a class="header" href="#布林型別" id="布林型別">布林型別</a></h4>
<p>如同其他多數程式語言一樣，Rust 中的布林型別有兩個可能的值：<code>true</code> 和 <code>false</code>。布林值的大小爲一個位元組。要在 Rust 中定義布林型別的話用 <code>bool</code>，如範例所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre></pre>
<p>布林值最常使用的方式之一是作爲條件判斷，像是在 <code>if</code> 表達式中使用。我們將會在<a href="ch03-05-control-flow.html#control-flow">「控制流程」</a><!-- ignore -->段落介紹如何在 Rust 使用 <code>if</code> 表達式。</p>
<h4><a class="header" href="#字元型別" id="字元型別">字元型別</a></h4>
<p>目前我們只討論了數字，但是 Rust 一樣也有支援字母。Rust 的 <code>char</code> 型別是最基本的字母型別，以下程式碼顯示了使用它的方法。（請注意到 <code>char</code> 字面值是用單撇號賦值，宣告字串字面值時才是用雙撇號）</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Rust 的 <code>cahr</code> 型別大小爲四個位元組並表示爲一個 Unicode 純量數值，這代表它能擁有的字元比 ASCII 還來的多。舉凡標音字母（Accented letters）、中文、日文、韓文、表情符號以及零長度空格都 Rust <code>cahr</code> 的有效字元。Unicode 純量數值的範圍包含從 <code>U+0000</code> 到 <code>U+D7FF</code> 以及 <code>U+E000</code> 到 <code>U+10FFFF</code>。但是一個「字元」並不是真正的 Unicode 概念，所以你對於什麼是一個「字元」的看法可能會和 Rust 的 <code>char</code> 不一樣。我們將會在第八章的<a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">「透過字串儲存 UTF-8 編碼的文字」</a><!-- ignore -->來討論此議題。</p>
<h3><a class="header" href="#複合型別" id="複合型別">複合型別</a></h3>
<p><em>複合型別</em>可以組合數個數值爲一個型別，Rust 有兩個基本複合型別：元組（tuples）和陣列（arrays）。</p>
<h4><a class="header" href="#元組型別" id="元組型別">元組型別</a></h4>
<p>元組是個將許多不同型別的數值合成一個複合型別的常見方法。元組擁有固定長度：一旦宣告好後，它們就無法增長或縮減。</p>
<p>我們建立一個元組的方法是寫一個用括號囊刮起來的數值列表，每個值再用逗號分隔開來。元組的每一格都是一個獨立型別，不同數值不必是相同型別。以下範例我們也加上了型別詮釋，平時不一定要加上：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>此變數 <code>tup</code> 就是整個元組，因爲一個元組就被視爲單一複合元素。要拿到元組中的每個獨立數值的話，我們可以用模式配對（pattern matching）來解構一個元組的數值，如以下所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>此程式先是建立了一個元組然後賦值給 <code>tup</code>，接著它用模式配對和 <code>let</code> 將 <code>tup</code> 拆成三個個別的變數 <code>x</code>、<code>y</code> 和 <code>z</code>。這就叫做<em>解構（destructuring）</em>，因爲它將單一元組拆成了三個部分。最後程式將 <code>y</code> 的值印出來，也就是 <code>6.4</code>。</p>
<p>除了用模式配對解構元組以外，我們也可以直接用句號（<code>.</code>）在加上數值的索引來取得元組內的元素。舉例來說：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>此程式建立了元組 <code>x</code>，然後用它們個別的索引產生新的變數。和多數程式語言一樣，元組的第一個索引是 0。</p>
<h4><a class="header" href="#陣列型別" id="陣列型別">陣列型別</a></h4>
<p>另一種取得數個數值集合的方法是使用<em>陣列</em>。和元組不一樣的是，陣列中的每個型別必須是一樣的。Rust 中的陣列和一些其他語言的陣列會有點不同，因爲 Rust 的陣列是固定長度的，就和元組一樣。</p>
<p>在 Rust 中，陣列的寫法是將數值寫在中括號內，每個數值再用逗號區隔開來：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>當你想要你的資料被分配在堆疊（stack）而不是堆積（heap）的話，使用陣列是很好的選擇（我們會在第四章討論堆疊與堆積的內容）。或者當你想確定你永遠會取得固定長度的元素也是。所以陣列不像 Vector 型別那麼有彈性， Vector 是標準函式庫提供的集合型別，類似於陣列但<em>允許</em>變更長度大小。如果你不確定該用陣列或 Vector 的話，通常你應該用 Vector 就好。第八章將會討論更多 Vector 的細節。</p>
<p>你會想用到陣列而非 Vector 的時機，可能會像是以下要取得一年之中的每個月份的例子這樣。這樣的列表很可能永遠不需要新增或刪除月份，所以你可以選擇用陣列宣告，因爲永遠只會有 12 個月份：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>要詮釋陣列型別的話，你可以在中括號寫出型別和元素數量，並用分號區隔開來，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p><code>i32</code> 在此是每個元素的型別，在分號後面的數字 <code>5</code> 指的是此陣列有五個元素。</p>
<p>這種寫法和初始化陣列數值的另一種寫法很像：如果你想建立的陣列中每個元素數值都一樣的話，你可以指定一個數值後加上分號，最後寫出元素數量。如以下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>陣列 <code>a</code> 會包含 <code>5</code> 個元素，然後每個元素的初始化數值均爲 <code>3</code>。這樣寫與 <code>let a = [3, 3, 3, 3, 3];</code> 的寫法一樣，但比較簡潔。</p>
<h5><a class="header" href="#獲取陣列元素" id="獲取陣列元素">獲取陣列元素</a></h5>
<p>一個陣列是被分配載堆疊上的一整塊記憶體，你可以用索引來取得陣列的元素，比如：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>在此範例中，變數 <code>first</code> 會得到數值 <code>1</code>，因爲這是陣列索引 <code>[0]</code> 的數值。變數 <code>second</code> 則會從陣列索引 <code>[1]</code> 得到數值 <code>2</code>。</p>
<h5><a class="header" href="#無效的陣列元素存取" id="無效的陣列元素存取">無效的陣列元素存取</a></h5>
<p>如果我們存取陣列之後的元素會發生什麼事呢？假設你修改範例成以下程式碼的話，雖然可以編譯通過但是在執行時則會出現錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore panics">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre>
<p>使用 <code>cargo run</code> 執行程式會產生以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:5:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>編譯期間沒有產生任何錯誤，但程式會產生*執行時（runtime）*錯誤並無法正確離開。當你嘗試使用索引存取元素時，Rust 會檢查你的索引是否小於陣列長度，如果索引大於或等於陣列長度的話，Rust 就會恐慌。</p>
<p>這是你第一個在實例中看到 Rust 安全原則給予的保障。在許多低階語言並不會提供這樣的檢查，所以當你提供不正確的索引時，無效的記憶體可能會被存取。Rust 會保護你免於這樣的錯誤風險，並立即離開程式，而不是允許記憶體存取並繼續。第九章將會討論更多有關 Rust 的錯誤處理方式。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/88250d663d5288a7f643ffca2f2c999190f3d4ae/src/ch03-02-data-types.md">88250d6</a></li>
<li>updated: 2020-09-05</li>
</ul>
</blockquote>
<h2><a class="header" href="#函式" id="函式">函式</a></h2>
<p>函式在 Rust 程式碼中無所不在。你已經見過一個語言最重要的函式了：<code>main</code> 函式是許多程式的入口點。此外你也看到了 <code>fn</code> 關鍵字能讓你宣告新的函式。</p>
<p>Rust 程式碼使用 <em>snake case</em> 作爲函式與變數名稱的慣例風格。在 snake case 中，所有的字母都是小寫，並用底線區隔單字。以下是一支包含函式定義範例的程式：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Rust 的函式定義從 <code>fn</code> 開始且在函式名稱後會有一組括號，大括號告訴編譯器函式本體的開始與結束位置。</p>
<p>我們可以輸入函式的名稱並加上括號來呼叫任何我們定義過的函式。因爲 <code>another_function</code> 已經在程式中定義了，他就可以在 <code>main</code> 函式中呼叫。注意到我們是在原始程式碼中的 <code>main</code> 函式<em>之後</em>定義 <code>another_function</code> 的，我們當然也可以把它定義在前面。Rust 不在乎你的函式是在哪裡定義的，只需要知道它在某處有定義就好。</p>
<p>讓我們開啟一個新的專案叫做 <em>functions</em> 來進一步探索。請將 <code>another_function</code> 範例放入 <em>src/main.rs</em> 然後執行它。你應該會看到以下輸出：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>程式碼會按照 <code>main</code> 函式中的順序執行。首先，「Hello, world!」的訊息會先顯示出來，再來才會呼叫 <code>another_function</code> 並印出它的訊息。</p>
<h3><a class="header" href="#函式參數" id="函式參數">函式參數</a></h3>
<p>函式也可以被定義成擁有<em>參數（parameters）<em>的，這是函式簽名（signatures）中特殊的變數。當函式有參數時，你可以提供那些參數的確切數值。嚴格上來說，我們傳遞的數值會叫做</em>引數（arguments）</em>。但爲了方便起見，通常大家不太會去在意兩者的區別。雖然函式定義時才叫<em>參數</em>，傳遞數值時叫做<em>引數</em>，但很多時候會被人們拿來交互使用。</p>
<p>以下是加上參數後重新寫過的 <code>another_function</code> 範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>嘗試執行程式的話，你應該會看到以下輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>宣告 <code>another_function</code> 時有一個參數叫做 <code>x</code>，而 <code>x</code> 的型別被指定爲 <code>i32</code>。當我們傳遞 <code>5</code> 給 <code>another_function</code> 時，<code>println!</code> 巨集會將 <code>5</code> 置於格式化字串中的大括號的位置。</p>
<p>在函式簽名中，你<em>必須</em>宣告每個參數的型別，這是 Rust 謹慎考慮後的設計決定：在函式定義中要求型別詮釋，代表編譯器幾乎不需要你在其他地方再提供資訊才能知道你要做什麼。</p>
<p>如果你希望函式擁有數個參數，你可以用逗號區隔開來，像這樣：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>此範例建立了一個有兩個參數的函式，兩個都是 <code>i32</code> 型別。接著函式在印出兩個參數的數值，注意參數不必得是相同的形態，這只是我們在此範例這樣寫而已。</p>
<p>讓我們試著執行此程式碼，請覆蓋你的專案 <em>functions</em> 內的 <em>src/main.rs</em> 檔案內容爲以上範例，然後用 <code>cargo run</code> 執行程式：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>因爲我們呼叫函式時，將 <code>5</code> 給了  <code>x</code> 且將 <code>6</code> 給了 <code>y</code>，字串就會印出這些數值。</p>
<h3><a class="header" href="#函式本體包含陳述式與表達式" id="函式本體包含陳述式與表達式">函式本體包含陳述式與表達式</a></h3>
<p>函式本體是由一系列的陳述式（statements）並在最後可以選擇加上表達式（expression）來組成。目前我們只講了沒有用到表達式做結尾的函式。由於 Rust 是門基於表達式（expression-based）的語言，知道這樣的區別是很重要的。其他語言通常沒有這樣的區別，所以現在讓我們來看看陳述式和表達式有什麼不同，以及它們怎麼影響函式本體。</p>
<p>我們其實已經使用了很多次陳述式與表達式。*陳述式（Statements）*是進行一些動作的指令，且不回傳任何數值。*表達式（Expressions）*則是計算並產生數值。讓我們來看一些範例：</p>
<p>建立一個變數然後用 <code>let</code> 關鍵字賦值給它就是一道陳述式。在範例 3-1 中的 <code>let y = 6;</code> 就是個陳述式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">範例 3-1：包含一道陳述式的 <code>main</code> 函式宣告</span></p>
<p>此函式定義也是陳述式，整個範例就是本身就是一個陳述式。</p>
<p>陳述式不會回傳數值，因此你無法將 <code>let</code> 陳述式賦值給其他變數。如同以下程式碼所做的，你將會得到一個錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>當你執行此程式時，你就會看到這樣的錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p><code>let y = 6</code> 陳述式不回傳數值，所以 <code>x</code> 得不到任何數值。這就和其他語言有所不同，像是 C 或 Ruby，通常它們的賦值仍能回傳所得到的值。在那些語言，你可以寫 <code>x = y = 6</code> 同時讓 <code>x</code> 與 <code>y</code> 都取得 <code>6</code>，但在 Rust 就不行。</p>
<p>表達式則會運算出些東西，並組合成你大部分所寫的 Rust 程式。先想想看一個簡單的數學運算比如 <code>5 + 6</code>，這就是個會算出 <code>11</code> 的表達式。表達式可以是陳述式的一部分：在範例 3-1 中 <code>let y = 6;</code> 的 <code>6</code> 其是就是個算出 <code>6</code> 的表達式。呼叫函式也可以是表達式、呼叫巨集也是表達、我們用 <code>{}</code> 產生的作用域也是表達式。舉例來說：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>此表達式：</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>就是一個會回傳 <code>4</code> 的區塊，此值再用 <code>let</code> 陳述式賦值給 <code>y</code>。請注意到 <code>x + 1</code> 這行沒有加上分號，它和你目前看到的寫法有點不同，因爲表達式結尾不會加上分號。如果你在此表達式加上分號的話，它就不會回傳數值。在我們繼續探討函式回傳值與表達式的同時請記住這一點。</p>
<h3><a class="header" href="#函式回傳值" id="函式回傳值">函式回傳值</a></h3>
<p>函式可以回傳數值給呼叫它們的程式碼，我們不會爲回傳值命名，但我們會用箭頭（<code>-&gt;</code>）來宣告它們的型別。在 Rust 中，回傳值其實就是函式本體最後一行的表達式。你可以用 <code>return</code> 關鍵字加上一個數值來提早回傳函式，但多數函式都能用最後一行的表達式作爲數值回傳。以下是一個有回傳數值的函式範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>在 <code>five</code> 函式中沒有任何函式呼叫、巨集甚至是 <code>let</code> 陳述式，只有一個 <code>5</code>。這在 Rust 中完全是合理的函式。請注意到函式的回傳型別也有指明，就是 <code>-&gt; i32</code>。嘗試執行此程式的話，輸出結果就會像是這樣：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p><code>five</code> 中的 <code>5</code> 就是函式的回傳值，這就是爲何回傳型別是 <code>i32</code>。讓我們進一步研究細節，這邊有兩個重要的地方：首先這行 <code>let x = five();</code> 顯示了我們用函式的回傳值作爲變數的初始值。因爲函式 <code>five</code> 回傳 <code>5</code>，所以這行和以下程式碼相同：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>再來，<code>five</code> 函式沒有參數但有定義回傳值的型別。所以函式本體只需有一個 <code>5</code> 就好，不需加上分號，這樣就能當做表達式回傳我們想要的數值。</p>
<p>讓我們在看另一個例子：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>執行此程式會顯示 <code>The value of x is: 6</code>，但如果我們在最後一行 <code>x + 1</code> 加上分號的話，就會將它從表達式變爲陳述式。我們就會得到錯誤。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>編譯此程式就會產生以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions`.

To learn more, run the command again with --verbose.
</code></pre>
<p>錯誤訊息「mismatched types」就告訴了我們此程式碼的核心問題。<code>plus_one</code> 的函式定義說它會回傳 <code>i32</code> 但是陳述式不會回傳任何數值。我們用空元組 <code>()</code> 表示不會回傳任何值。因此沒有任何值被回傳，這和函式定義相牴觸，最後產生錯誤。在此輸出結果，Rust 提供了一道訊息來協助解決問題：它建議移除分號，這樣就能修正錯誤。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch03-03-how-functions-work.md">d44317c</a></li>
<li>updated: 2020-09-05</li>
</ul>
</blockquote>
<h2><a class="header" href="#註解" id="註解">註解</a></h2>
<p>所有程式設計師均致力於讓他們的程式碼易於閱讀，不過有時後額外的解釋還是需要的。這種情況下，開發者會在他們的程式碼留下一些筆記或是<em>註解（comments）</em>，編譯器會忽略這些字，但其他人在閱讀程式碼時可能就會覺得很有幫助。</p>
<p>這是一個簡單地註釋：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<p>在 Rust 中，理想的註解風格是用兩行斜線在加上一個空格起頭，然後註解就能一直寫到該行結束爲止。如果註解會超過一行的話，你需要在每一行都加上 <code>//</code>，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
<span class="boring">}
</span></code></pre></pre>
<p>註解也可以加載程式碼之後：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
</code></pre></pre>
<p>不過你會更常看到它們用用以下格式，註解會爲於要說明的程式碼上一行：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust 還有另一種註解：技術文件註解。我們會在第十四章的「發佈 Crate 到 Crates.io」段落提到它。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/25a1530ccbf0a79c8df2920ee2af8beb106122e8/src/ch03-04-comments.md">25a1530</a></li>
<li>updated: 2020-09-06</li>
</ul>
</blockquote>
<h2><a class="header" href="#控制流程" id="控制流程">控制流程</a></h2>
<p>在大多數程式語言中，能夠決定依據某項條件是否爲真來執行些程式碼，以及依據某項條件是否爲真來重複執行些程式碼是非常基本的組成元件。在 Rust 程式碼中能讓你控制執行流程的常見方法有 <code>if</code> 表達式以及迴圈。</p>
<h3><a class="header" href="#if-表達式" id="if-表達式"><code>if</code> 表達式</a></h3>
<p><code>if</code> 能讓你依照條件判斷對你的程式碼產生分支。基本上你提供一個條件然後就像是在說：「如果此條件符合的話，就執行這個程式碼區塊；如果沒有的話，就不要執行這段程式碼。」</p>
<p>請在你的 <em>projects</em> 目錄下建立一個新的專案叫做 <em>branches</em> 好讓我們來探討 <code>if</code> 表達式。接著請在 <em>src/main.rs</em> 檔案內輸入以下內容：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<p>所有的 <code>if</code> 表達式都由 <code>if</code> 關鍵字開始在加上一個條件。在此例中的條件是判斷變數 <code>number</code> 是否小於 5。如果條件符合的話，我們將要執行的程式碼區塊接著用大括號接在後面。與 <code>if</code> 表達式條件相關的程式碼段落有時也被稱爲 <em>arms</em>，就像我們在第二章<a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">「將猜測的數字與祕密數字做比較」</a><!-- ignore -->段落提到的 <code>match</code> 表達式的分支一樣。</p>
<p>另外，我們還可以選擇性地加上 <code>else</code> 表達式（就像範例寫的），讓條件不符時可以去執行另外一段程式碼。如果你沒有提供 <code>else</code> 表達式且條件爲否的話，程式會直接略過 <code>if</code> 的程式碼區塊，接著執行後續的程式碼。</p>
<p>請嘗試執行此程式碼，你應該會看到以下輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<p>讓我們來變更 <code>number</code> 的值使條件變成 <code>false</code>，再來看看會發生什麼事：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;condition was true&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;condition was false&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>在跑一次程式，然後看看輸出：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<p>還有一件值得注意的是程式碼的條件判斷<em>必須</em>是 <code>bool</code>。如果條件不是 <code>bool</code> 的話，我們就會遇到錯誤。比方說，試試以下程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p>這次 <code>if</code> 條件計算出數值 <code>3</code>，然後 Rust 丟出錯誤給我們：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches`.

To learn more, run the command again with --verbose.
</code></pre>
<p>錯誤訊息告訴我們 Rust 預期收到 <code>bool</code> 但是卻拿到整數。這和 Ruby 和 JavaScript 就不同，Rust 不會自動將非布林值型別轉換成布林值。你永遠必須顯式提供布林值給 <code>if</code> 作爲它的條件判斷。舉例來說，如果我們希望 <code>if</code> 只會在數值爲 <code>0</code> 才執行，我們可以將 <code>if</code> 表達式改成以下範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>執行此程式碼就會印出「number was something other than zero」。</p>
<h4><a class="header" href="#使用-else-if-處理多重條件" id="使用-else-if-處理多重條件">使用 <code>else if</code> 處理多重條件</a></h4>
<p>想要實現多重條件的話，你可以將 <code>if</code> 和 <code>else</code> 組合成 <code>else if</code> 表達式。舉例來說：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>程式有四種可能的分支，當你執行它時你應該會看到以下輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>當此程式執行時，他會依序檢查每一個 <code>if</code> 表達式，並執行第一個符合條件的程式碼段落。注意到雖然 6 的確可以除以 2，但我們沒有看到 <code>number is divisible by 2</code>，也沒有看到來自 <code>else</code> 那段的 <code>number is not divisible by 4, 3, or 2</code>。這是因爲 Rust 只會執行第一個符合條件的區塊，而當它遇到時它就不會在檢查其他條件。</p>
<p>使用太多的 <code>else if</code> 表達式很容易讓你的程式碼變得凌亂，所以當你需要用到一個以上，你可能會想要先重構程式碼看看。爲此我們在第六章會介紹一個功能強大的 Rust 條件判斷結構叫做 <code>match</code>。</p>
<h4><a class="header" href="#在-let-陳述式中使用-if" id="在-let-陳述式中使用-if">在 <code>let</code> 陳述式中使用 <code>if</code></a></h4>
<p>因爲 <code>if</code> 是表達式，所以我們可以像範例 3-2 這樣放在 <code>let</code> 陳述式的右邊。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p><span class="caption">範例 3-2：將 <code>if</code> 表達式的結果賦值給變數</span></p>
<p>變數 <code>number</code> 會得到 <code>if</code> 表達式運算出的數值。執行此程式看看會發生什麼事：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>你應該還記得程式碼區塊也可以是表達式且會回傳最後一行的數值，而且數字本身也是表達式。在此例中，<code>if</code> 表達式的值取決於哪段程式碼被執行。這代表可能成爲最終結果的每一個 <code>if</code> 分支必須要是相同型別。在範例 3-2 中，各分支的型態都是 <code>i32</code>。如果型態不一致的話，如以下範例所示，我們會得到錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<p>當我們嘗試編譯程式碼時，我們會得到錯誤。<code>if</code> 和 <code>else</code> 分支的型態並不一致，而且 Rust 還確切指出程式出錯的地方在哪：</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                 |
  |                                 expected because of this

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches`.

To learn more, run the command again with --verbose.
</code></pre>
<p><code>if</code> 段落的表達式運算出整數，但 <code>else</code> 的區塊卻運算出字串。這樣行不通的原因是變數只能有一個型別。Rust 必須在編譯期間確切知道變數 <code>number</code> 的型別，這樣才能驗證它的型別在任何有使用到 <code>number</code> 的地方都是有效的。要是 <code>number</code> 只能在執行時知道的話，Rust 就沒辦法這樣做了。如果編譯器必須追蹤所有變數多種可能存在的型別，那就會變得非常負責並無法爲程式碼提供足夠的保障。</p>
<h3><a class="header" href="#使用迴圈重複執行" id="使用迴圈重複執行">使用迴圈重複執行</a></h3>
<p>重複執行同一段程式碼區塊時常是很有用的。針對這樣的任務，Rust 提供了多種產生 *迴圈（loops）*的方式。一個迴圈會執行一段程式碼區塊，然後在結束時馬上回到區塊起始位置繼續執行。爲了繼續探討迴圈，讓我們再開一個新專案 <em>loops</em>。</p>
<p>Rust 提供三種迴圈：<code>loop</code>、<code>while</code> 和 <code>for</code>。讓我們每個都嘗試看看吧。</p>
<h4><a class="header" href="#使用-loop-重複執行程式碼" id="使用-loop-重複執行程式碼">使用 <code>loop</code> 重複執行程式碼</a></h4>
<p><code>loop</code> 關鍵字告訴 Rust 去反覆不停地執行一段程式碼直到你親自告訴它要停下來。</p>
<p>我們用以下範例示範，請修改你 <em>loops</em> 目錄下的 <em>src/main.rs</em> 檔案成以下程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>當我們執行此程式時，我們會看到 <code>again!</code> 一直不停地重複顯示出來，直到我們手動停下程式爲止。大多數的終端機都支援 <span class="keystroke">ctrl-c</span> 這個快捷鍵來中斷一支卡在無限迴圈的程式，你可以自己試試看：</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-32-loop
cargo run
CTRL-C
-->
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29s
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p><code>^C</code> 這個符號表示你按下了 <span class="keystroke">ctrl-c</span>。按照程式收到中斷訊號的時間點，你可能不會看到 <code>again!</code> 出現在 <code>^C</code> 之後。</p>
<p>幸運的是 Rust 有提供另一個打破迴圈更可靠的方法。你可以在迴圈內加上 <code>break</code> 關鍵字告訴程式何時停止執行迴圈。回想一下我們在第二章<a href="ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">「猜對後離開」</a><!-- ignore -->段落就做過這樣的事，當使用者猜對正確數字而獲勝時就會離開程式。</p>
<h4><a class="header" href="#從迴圈回傳數值" id="從迴圈回傳數值">從迴圈回傳數值</a></h4>
<p>其中一種使用 <code>loop</code> 的用途是重試某些你覺得會失敗的動作，像是檢查一個執行緒是否已經完成其任務。不過這樣你可能就會想傳遞任務結果給之後的程式碼。要做到這樣的事，你可以在你要用來停下迴圈的 <code>break</code> 表達式內加上一個你想回傳數值，該值就會被停止的迴圈回傳，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}
</code></pre></pre>
<p>在迴圈之前，我們宣告了一個變數 <code>counter</code> 並初始化爲 <code>0</code>，然後我們宣告了另一個變數 <code>result</code> 來取的迴圈回傳的值。在迴圈每一次的迭代中，我們將變數 <code>counter</code> 加上 <code>1</code> 並檢查它是否等於 <code>10</code>。如果是的話就用 <code>break</code> 關鍵字回傳 <code>counter * 2</code>。在迴圈結束後，我們用分號才結束這個賦值給 <code>result</code> 的陳述式。最後我們印出 <code>result</code>，而結果爲 20。</p>
<h4><a class="header" href="#使用-while-做條件迴圈" id="使用-while-做條件迴圈">使用 <code>while</code> 做條件迴圈</a></h4>
<p>在程式中用條件判斷迴圈的執行通常是很有用的。當條件爲真時，迴圈就繼續執行。當條件不再符合時，程式就用 <code>break</code> 停止迴圈。這樣的循環方法可以用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 組合出來。如果你想嘗試的話，你現在就可以自己寫寫看看。</p>
<p>但是這種模式非常常見，所以 Rust 有提供內建的結構稱爲 <code>while</code> 迴圈。範例 3-3 就是使用 <code>while</code> 的例子：該程式會循環三次，每次計數都減一，然後在迴圈之後印出訊息並離開。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 3-3：使用 <code>while</code> 迴圈，當條件符合就持續執行程式碼</span></p>
<p>這樣的結構消除了很多使用 <code>loop</code>、<code>if</code>、<code>else</code> 與 <code>break</code> 會有的雜訊，這樣可以更易閱讀。當條件爲真的，程式碼就執行；不然的話，它就離開迴圈。</p>
<h4><a class="header" href="#使用-for-遍歷集合" id="使用-for-遍歷集合">使用 <code>for</code> 遍歷集合</a></h4>
<p>你可以用 <code>while</code> 來遍歷一個集合的元素，像是陣列等等。舉例來說，我們可以看看範例 3-4。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index += 1;
    }
}
</code></pre></pre>
<p><span class="caption">範例 3-4：使用 <code>while</code> 遍歷集合的每個元素</span></p>
<p>程式在此對陣列的每個元素計數，它先從索引 <code>0</code> 開始，然後持續循環直到它抵達最後一個陣列索引爲止（也就是 <code>index &lt; 5</code> 不再爲真）。執行此程式會印出陣列裡的每個元素：</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>所有五個元素都如預期顯示在終端機上。儘管 <code>index</code> 會在某一刻達到 <code>5</code>，但是迴圈會在嘗試取得陣列第六個元素前就停止執行。</p>
<p>但這樣的方式是容易出錯的，我們可能取得錯誤的索引長度造成程式恐慌。這同時也使程式變慢，因爲編譯器得在執行時的程式碼對迴圈中每次迭代的每個元素加上條件檢查。</p>
<p>所以更簡潔的替代方案是，你可以使用 <code>for</code> 迴圈來對集合的每個元素執行一些程式碼。<code>for</code> 迴圈的樣子就像範例 3-5 寫的這一樣。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p><span class="caption">範例 3-5：使用 <code>for</code> 迴圈遍歷集合的每個元素</span></p>
<p>當我們執行此程式時，我們會看到和範例 3-4 一樣的結果。最重要的是，我們增加了程式的安全性，去除了造成程式錯誤的可能性。不會出現超出陣列大小或是讀取長度不足的風險。</p>
<p>比方說在範例 3-4 的程式碼，如果你變更陣列 <code>a</code> 的元素爲只有 4 個，但忘記更新條件判斷爲 <code>while index &lt; 4</code> 的話，程式就會恐慌。使用 <code>for</code> 迴圈的話，我們變更陣列長度時，就不需要去記得更新其他程式碼。</p>
<p><code>for</code> 迴圈的安全性與簡潔程度讓它成爲 Rust 最常被使用的迴圈結構。就算你想執行的是依照次數循環的程式碼，像是範例 3-3 的 <code>while</code> 迴圈範例，多數 Rustaceans 還是會選擇 <code>for</code> 迴圈。要這麼做的方法是使用 <code>Range</code>，這是標準函式庫提供的型別，用來產生一連串的數字序列，從指定一個數字開始一直到另一個數字之前結束。</p>
<p>以下是我們用 <code>loop</code> 迴圈來計數的另一種方式，它用了一個我們還沒講過的方法 <code>rev</code>，這可以用來反轉：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>這樣是不是看起來更好讀許多？</p>
<h2><a class="header" href="#總結-1" id="總結-1">總結</a></h2>
<p>你做到了！這的確是篇大章節：你學到了變數、純量與複合資料型別、函式、註解、<code>if</code> 表達式以及迴圈！如果你想練習此章的概念，你可以試著打造以下程式：</p>
<ul>
<li>轉換攝氏與華氏溫度。</li>
<li>產生第 n 個斐波那契數字。</li>
<li>試著用重複的歌詞印出 Christmas carol 的 The Twelve Days of Christmas。</li>
</ul>
<p>當你準備好後，我們就來探討一個其他語言<em>不常見</em>的概念：所有權。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch03-05-control-flow.md">d44317c</a></li>
<li>updated: 2020-09-07</li>
</ul>
</blockquote>
<h1><a class="header" href="#理解所有權" id="理解所有權">理解所有權</a></h1>
<p>所有權可以說是 Rust 最與衆不同的特色，這讓 Rust 不需要垃圾回收（garbage collector）就可以保障記憶體安全。因此理解 Rust 中的所有權如何運作是非常重要的。在本章節，我們將討論所有權以及一些相關的功能：借用、slices 與 Rust 如何在記憶體分配資料。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/1fedfc4b96c2017f64ecfcf41a0a07e2e815f24f/src/ch04-00-understanding-ownership.md">1fedfc4</a></li>
<li>updated: 2020-09-07</li>
</ul>
</blockquote>
<h2><a class="header" href="#什麼是所有權" id="什麼是所有權">什麼是所有權？</a></h2>
<p>Rust 的核心特色就是<em>所有權</em>。雖然這項特色很容易解釋，但它卻深深影響整個語言的其他部分。</p>
<p>所有程式都需要在執行時管理它們使用記憶體的方式。有些語言會用垃圾回收機制，在程式執行時不斷尋找不再使用的記憶體；而有些程式，開發者必須親自分配和釋放記憶體。Rust 選擇了第三種方式：記憶體由所有權系統管理，且編譯器會在編譯時加上一些規則檢查。所有權的特性不會降低執行程式的速度。</p>
<p>因爲所有權對許多程式設計師來說是個全新的觀念，所以的確需要花一點時間消化。好消息是隨著你越熟悉 Rust 與所有權系統的規則，你越能本能地開發出安全又高效的程式碼。加油，堅持下去！</p>
<p>當你理解所有權時，你就有一個穩健的基礎能夠理解那些使 Rust 獨特的功能。在本章節中，你將透過一些範例來學習所有權，我們會專注在一個非常常見的資料結構：字串。</p>
<blockquote>
<h3><a class="header" href="#堆疊stack與堆積heap" id="堆疊stack與堆積heap">堆疊（Stack）與堆積（Heap）</a></h3>
<p>在許多程式語言，你通常不需要去想到堆疊與堆積。但在像是 Rust 這樣的系統程式語言，資料是位於堆疊還是堆積就會有差，這會影響語言的行爲以及爲何你得作出某些特定決策。在本章稍後討論所有權時，都會談到堆疊與堆積的關聯，所以這裡預先稍作解釋。</p>
<p>堆疊與堆積都是供你的程式碼在執行時能夠使用的記憶體部分，但他們組成的方式卻不一樣。堆疊會按照它取得數值的順序依序存放它們，並以相反的順序移除數值。這通常稱爲<em>後進先出（last in, first out)</em>。你可以把堆疊想成是盤子，當你要加入更多盤子，你會將它們疊在最上面。如果你要取走盤子的話，你也是從最上方拿走。想要從底部或中間，插入或拿走盤子都是不可行的！當我們要新增資料時，我們會稱呼爲<em>推入堆疊（pushing onto the stack）</em>，而移除資料則是叫做<em>彈出堆疊（popping off the stack）</em>。</p>
<p>所有在堆疊上的資料都必須是已知固定大小。在編譯時屬於未知或可能變更大小的資料必須儲存在堆積。堆積就比較沒有組織，當你要將資料放入堆積，你得要求一定大小的空間。記憶體分配器（memory allocator）會找到一塊夠大的空位，標記爲已佔用，然後回傳一個<em>指標（pointer）</em>，指著該位置的地址。這樣的過程稱爲<em>在堆積上分配（allocating on the heap）</em>，或者有時直接簡稱爲*分配（allocating）*就好。將數值放入堆疊不會被視爲是在分配。因爲指標是固定已知的大小，所以你可以存在堆疊上。但當你要存取實際資料時，你就得去透過指標取得資料。</p>
<p>你可以想像成是一個餐廳。當你進入餐廳時，你會告訴服務員你的團體有多少人，他就會將你們帶到足夠人數的餐桌。如果你的團體有人晚到的話，他們可以直接尋問你坐在哪而找到你。</p>
<p>將資料推入堆疊會比在堆積上分配還來的快，因爲分配器不需要去搜尋哪邊才能存入新資料，其位置永遠在堆疊最上方。相對的，堆積就需要比較多步驟，分配器必須先找到一個夠大的空位來儲存資料，然後作下紀錄未下次分配做準備。</p>
<p>在堆積上取得資料也比在堆疊上取得來得慢，因爲你需要用追蹤指標才找的到。現代的處理器如果在記憶體間跳轉越少的話速度就越快。讓我們繼續用餐廳做比喻，想像伺服器就是在餐廳爲數個餐桌點餐。最有效率的點餐方式就是依照餐桌順序輪流點餐。如果幫餐桌 A 點了餐之後跑到餐桌 B 點，又跑回到 A 然後又跑到 B 的話，可以想像這是個浪費時間的過程。同樣的道理，處理器在處理任務時，如果處理的資料相鄰很近（就如同存在堆疊）的話，當然比相鄰很遠（如同存在堆積）來得快。要在堆積分配大量的空間同樣也很花時間。</p>
<p>當你的程式碼呼叫函式時，傳遞給函式的數值（可能包含指向堆積上資料的指標）與函式區域變數會被推入堆疊。當函式結束時，這些數值就會被彈出。</p>
<p>追蹤哪部分的程式碼用到了堆積上的哪些資料、最小化堆積上的重複資料、以及清除堆積上沒再使用的資料確保你不會耗盡空間，這些問題都是所有權系統要處理的。一旦你理解所有權後，你通常就不再需要常常想到堆疊與堆積，不過能理解所有權就是爲了管理堆積有助於解釋爲何它要這樣運作。</p>
</blockquote>
<h3><a class="header" href="#所有權規則" id="所有權規則">所有權規則</a></h3>
<p>首先，讓我們先看看所有權規則。當我們在解釋說明時，請記得這些規則：</p>
<ul>
<li>Rust 中每個數值都會有一個變數作爲它的<em>所有者（owner）</em>。</li>
<li>同時間只能有一個所有者。</li>
<li>當所有者離開作用域時，數值就會被丟棄。</li>
</ul>
<h3><a class="header" href="#變數作用域" id="變數作用域">變數作用域</a></h3>
<p>我們已經在第二章示範了一支 Rust 的程式。現在既然我們已經知道了基本語法，我們接下來就不再將 <code>fn main() {</code> 寫進程式碼範例範例中。所以你在參考時，請記得親自寫在 <code>main</code> 函式內。這樣一來，我們的範例可以更加簡潔，讓我們更加專注在細節而非樣板程式。</p>
<p>作爲所有權的第一個範例，我們先來看變數的<em>作用域（scope）</em>。作用域是一些項目在程式內的有效範圍。假設我們有個像這樣的變數：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>變數 <code>s</code> 是一個字串字面值（string literal），而字串數值是寫死在我們程式內。此變數的有效範圍是從它宣告開始一直到當前<em>作用域</em>結束爲止。範例 4-1 註解了 <code>s</code> 在哪裡是有效的。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {                      // s 在此處無效，因爲它還沒宣告
        let s = &quot;hello&quot;;   // s 在此開始視爲有效

        // 使用 s
    }                      // 此作用域結束， s 不再有效
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 4-1：變數與它在作用域的有效範圍</span></p>
<p>換句話說，這裡有兩個重要的時間點：</p>
<ul>
<li>當 <code>s</code> <em>進入作用域</em>時，它是有效的。</li>
<li>它持續被視爲有效直到它<em>離開作用域</em>爲止。</li>
</ul>
<p>目前爲止，變數何時有效與作用域的關係都還跟其他程式語言相似。現在我們要以此基礎來介紹 <code>String</code> 型別</p>
<h3><a class="header" href="#string-型別" id="string-型別"><code>String</code> 型別</a></h3>
<p>要能夠解釋所有權規則，我們需要使用比第三章的<a href="ch03-02-data-types.html#data-types">「資料型別」</a><!-- ignore -->介紹過的還複雜的型別才行。之前我們提到的型別都是儲存在堆疊上的，在作用域結束時就會從堆疊中彈出。但是我們想要觀察的是儲存在堆積上的資料，並研究 Rust 是如知道要清理資料的。</p>
<p>我們會使用 <code>String</code> 最爲範例並專注在 <code>String</code> 與所有權有關的部分。這些部分也適用於其他基本函式庫或你自己定義的複雜資料型態。我們會在第八章更深入探討 <code>String</code>。</p>
<p>我們已經看過字串字面值，字串的數值是寫死在我們的程式內的。字串字面值的確很方便，但他不可能完全適用於我們使用文字時的所有狀況。其中一個原因是因爲它是不可變的，另一個原因是並非所有字串值在我們編寫程式時就會知道。舉裡來說，要是我們想要收集使用者的輸入並儲存它呢？對於這些情形，Rust 提供第二種字串型別 <code>String</code>。此型別是分配在堆積上的，所以可以儲存我們在編譯期間未知的一些文字。你可以建議從字串字面值使用 <code>from</code> 函式來建立一個 <code>String</code>，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>雙冒號（<code>::</code>）讓我們可以將 <code>from</code> 函式置於 <code>String</code> 型別的命名空間（namespace）底下，而不是取像是 <code>string_from</code> 這樣的名稱。我們將會在第五章的<a href="ch05-03-method-syntax.html#method-syntax">「方法語法」</a><!-- ignore -->討論這個語法，並在第七章的<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">「引用模組項目的路徑」</a><!-- ignore -->討論模組（modules）與命名空間。</p>
<p>這種類型的字串是<em>可以</em>被改變的：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String

    println!(&quot;{}&quot;, s); // This will print `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>所以這邊有何差別呢？爲何 <code>String</code> 是可變的，但字面值卻不行？兩者最主要的差別在於它們對待記憶體的方式。</p>
<h3><a class="header" href="#記憶體與分配" id="記憶體與分配">記憶體與分配</a></h3>
<p>以字串字面值來說，我們在編譯時就知道它的內容，所以可以寫死在最終執行檔內。這就是爲何字串字面值非常迅速且高效。但這些特性均來自於字串字面值的不可變性。不幸的是我們無法將編譯時未知大小的文字，或是執行程式時大小可能會改變的文字等對應記憶體塞進二進制檔案中。</p>
<p>而對於 <code>String</code> 型別來說，爲了要能夠支援可變性、改變文字長度大小，我們需要在堆積上分配一塊編譯時未知大小的記憶體來儲存這樣的內容，這代表：</p>
<ul>
<li>記憶體分配器必須在執行時請求記憶體。</li>
<li>我們不再需要這個 <code>String</code> 時，我們需要以某種方法將此記憶體還給分配器。</li>
</ul>
<p>當我們呼叫 <code>String::from</code> 時就等於完成第一個部分，它的實作會請求分配一塊它需要的記憶體。這邊大概和其他程式語言都一樣。</p>
<p>不過第二部分就不同了。在擁有*垃圾回收機制（garbage collector, GC）*的語言中，GC 會追蹤並清理不再使用的記憶體，所以我們不用去擔心這件事。沒有 GC 的話，識別哪些記憶體不再使用並顯式呼叫程式碼釋放它們就是我們的責任了，就像我們請求取得它一樣。在以往的歷史我們可以看到要完成這件事是一項艱鉅的任務，如果我們忘了，那麼就等於在浪費記憶體。如果我們釋放的太早的話，我們則有可能會拿到無效的變數。要是我們釋放了兩次，那也會造成程式錯誤。我們必須準確無誤地配對一個 <code>allocate</code> 給剛好一個 <code>free</code>。</p>
<p>Rust 選擇了一條不同的道路：當記憶體在擁有它的變數離開作用域時就會自動釋放。以下是我們解釋作用域的範例 4-1，但使用的是 <code>String</code> 而不是原本的字串字面值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let s = String::from(&quot;hello&quot;); // s 在此開始視爲有效

        // 使用 s
    }                                  // 此作用域結束
                                       // s 不再有效
<span class="boring">}
</span></code></pre></pre>
<p>當 <code>s</code> 離開作用域時，我們就可以很自然地將 <code>String</code> 所需要的記憶體釋放回分配器。 當變數離開作用域時，Rust 會幫我們呼叫一個特殊函式。此函式叫做 <code>drop</code>，在這裡當時 <code>String</code> 的作者就可以寫入釋放記憶體的程式碼。Rust 會在大括號結束時自動呼叫 <code>drop</code>。</p>
<blockquote>
<p>注意：在 C++，這樣在項目生命週期結束時釋放資源的模式，有時被稱爲<em>資源取得即初始化（Resource Acquisition Is Initialization, RAII）</em>。如果你已經用過 RAII 的模式，那麼你應該就會很熟悉 Rust 的 <code>drop</code> 函式。</p>
</blockquote>
<p>這樣的模式對於 Rust 程式碼的編寫有很深遠的影響。雖然現在這樣看起來很簡單，但在更多複雜的情況下程式碼的行爲可能會變得很難預測。像是當我們需要許多變數，所以得在堆積上分配它們的情況。現在就讓我們開始來探討這些情形。</p>
<h4><a class="header" href="#變數與資料互動的方式移動move" id="變數與資料互動的方式移動move">變數與資料互動的方式：移動（Move）</a></h4>
<p>數個變數在 Rust 中可以有許多不同方式來與相同資料進行互動。讓我們看看使用整數的範例 4-2。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 4-2：將變數 <code>x</code> 的數值賦值給 <code>y</code></span></p>
<p>我們大概可以猜到這做了啥：「<code>x</code> 取得數值 <code>5</code>，然後拷貝（copy）了一份 <code>x</code> 的值給 <code>y</code>。」所以我們有兩個變數 <code>x</code> 與 <code>y</code>，而且都等於 <code>5</code>。這的確是我們所想的這樣，因爲整數是已知且固定大小的簡單數值，所以這兩個數值 <code>5</code> 都會推入堆疊中。</p>
<p>現在讓我們看看 <code>String</code> 的版本：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>這和之前的程式碼非常相近，所以我們可能會認爲它做的事也是一樣的：也就是第二行也會拿到一份 <code>s1</code> 拷貝的值給 <code>s2</code>。但事實上卻不是這樣。</p>
<p>請看看圖示 4-1 來瞭解 <code>String</code> 底下的架構到底長什麼樣子。一個 <code>String</code> 由三個部分組成，如圖中左側所示：一個指向儲存字串內容記憶體的指標、它的長度和它的容量。這些資料是儲存在堆疊上的，但圖右的內容則是儲存在堆積上。</p>
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">圖示 4-1：將數值 <code>&quot;hello&quot;</code> 賦值給 <code>s1</code> 的 <code>String</code> 記憶體結構</span></p>
<p>長度指的是目前所使用的 <code>String</code> 內容在記憶體以位元組爲單位所佔用的大小。而容量則是 <code>String</code> 從分配器以位元組爲單位取得的總記憶體量。長度和容量的確是有差別的，但現在對我們來說還不太重要，你現在可以先忽略容量的問題。</p>
<p>當我們將 <code>s1</code> 賦值給 <code>s2</code>，<code>String</code> 的資料會被拷貝，不過我們拷貝的是堆疊上的指標、長度和容量。我們不會拷貝指標指向的堆積資料。資料以記憶體結構表示的方式會如圖示 4-2 表示。</p>
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">圖示 4-2：<code>s2</code> 擁有一份 <code>s1</code> 的指標、長度和容量的記憶體結構</span></p>
<p>所以實際上的結構<em>不會</em>長的像圖示 4-3 這樣，如果 Rust 也會拷貝 堆積資料的話，才會看起來像這樣。如果 Rust 這麼做的話，<code>s2 = s1</code> 的動作花費會變得非常昂貴。當堆積上的資料非常龐大時，對執行時的性能影響是非常顯住的。</p>
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">圖示 4-3：如果 Rust 也會拷貝堆積資料，<code>s2 = s1</code> 可能會長得樣子</span></p>
<p>稍早我們提到當變數離開作用域時，Rust 會自動呼叫 <code>drop</code> 函式並清理該變數在堆積上的資料。但圖示 4-2 顯式兩個資料指標都指向相同位置，這會造成一個問題。當 <code>s2</code> 與 <code>s1</code> 都離開作用域時，它們都會嘗試釋放相同的記憶體。這被稱呼爲*雙重釋放（double free）*錯誤，也是我們之前提過的錯誤之一。釋放記憶體兩次可能會導致記憶體損壞，進而造成安全漏洞。</p>
<p>爲了保障記憶體安全，在此情況中 Rust 還會在做一件重要的事。與其嘗試拷貝分配的記憶體，Rust 會將 <code>s1</code> 視爲無效。因此當 <code>s1</code> 離開作用域時，Rust 不需要釋放任何東西。請看看如果在 <code>s2</code> 建立之後繼續使用 <code>s1</code> 會發生什麼事，以下程式就執行不了：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;

    println!(&quot;{}, world!&quot;, s1);
<span class="boring">}
</span></code></pre>
<p>你會得到像這樣的錯誤，因爲 Rust 會防止你使用無效的引用：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;hello&quot;);
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>如果你在其他語言聽過<em>淺拷貝（shallow copy）</em> 和 <em>深拷貝（deep copy）<em>這樣的詞，拷貝指標、長度和容量而沒有拷貝實際內容這樣的概念應該就相近於淺拷貝。但因爲 Rust 同時又無效化第一個變數，我們不會叫此爲淺拷貝，而是稱此動作爲</em>移動（move）</em>。在此範例我們會稱 <code>s1</code> <em>被移動</em> 到 <code>s2</code>，所以實際上發生的事長得像圖示 4-4 這樣。</p>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">圖示 4-4：<code>s1</code> 無效後的記憶體結構</span></p>
<p>這樣就解決了問題！只有 <code>s2</code> 有效的話，當它離開作用域，就只有它會釋放記憶體，我們就完成所有動作了。</p>
<p>除此之外，這邊還表達了另一個設計決策：Rust 永遠不會自動將你的資料建立「深拷貝」。因此任何<em>自動</em>的拷貝動作都可以被視爲是對執行效能影響很小的。</p>
<h4><a class="header" href="#變數與資料互動的方式克隆clone" id="變數與資料互動的方式克隆clone">變數與資料互動的方式：克隆（Clone）</a></h4>
<p>要是我們<em>真的想</em>深拷貝 <code>String</code> 在堆積上的資料而非僅是堆疊資料的話，我們可以使用一個常見的方法叫做 <code>clone</code>。我們會在第五章講解方法語法，不過既然方法是很常見的程式語言功能，你很可能已經有些概念了。</p>
<p>以下是 <code>clone</code> 方法運作的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();

    println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼能執行無誤，並明確作出了像圖示 4-3 這樣的行爲，也就是堆積資料<em>的確</em>被複製了一份。</p>
<p>當你看到 <code>clone</code> 的呼叫，你就會知道有一些特定的程式碼被執行且消費可能是相對昂貴的。你可以很清楚地知道有些不同的行爲正在發生。</p>
<h4><a class="header" href="#只在堆疊上的資料拷貝copy" id="只在堆疊上的資料拷貝copy">只在堆疊上的資料：拷貝（Copy）</a></h4>
<p>還有一個小細節我們還沒提到，也就是我們在使用整數時的程式碼。回想一下範例 4-2 是這樣寫的，它能執行且有效：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>但這段程式碼似乎和我們剛學的互相矛盾：我們沒有呼叫 <code>clone</code>，但 <code>x</code> 卻仍是有效的，沒有移動到 <code>y</code>。</p>
<p>原因是因爲像整數這樣的型別在編譯時是已知大小，所以只會存在在堆疊上。所以要拷貝一份實際數值的話是很快的。這也讓我們沒有任何理由要讓 <code>x</code> 在 <code>y</code> 建立後被無效化。換句話說，這邊沒有所謂淺拷貝與深拷貝的差別。所以這邊呼叫 <code>clone</code> 的會不會與平常的淺拷貝有啥不一樣，我們可以保持這樣就好。</p>
<p>Rust 有個特別的標記叫做 <code>Copy</code> 特徵（trait）可以用在標記像整數這樣存在堆疊上的型別（我們會在第十章討論什麼是特徵）。如果一個型別有 <code>Copy</code> 特徵的話，舊的變數在賦值後仍然會是有效的。如果一個型別有實作（implement）<code>Drop</code> 特徵的話，Rust 不會允許我們讓此型別擁有 <code>Copy</code> 特徵。如果我們對某個型別在數值離開作用域時，需要在做特別處理的話，我們對此型別標註 <code>Copy</code> 特徵會在編譯時期產生錯誤。想要瞭解如何爲你的型別加上 <code>Copy</code> 的話，請參考附錄 C <a href="appendix-03-derivable-traits.html">「可推導的特徵」</a><!-- ignore --> </p>
<p>所以哪些型別有 <code>Copy</code> 呢？你可以閱讀技術文件來知道哪些型別有，但基本原則是任何簡單地純量數值都可以有 <code>Copy</code>，且不需要分配記憶體或任何形式資源的型別也是有 <code>Copy</code>。以下是一些擁有 <code>Copy</code> 的型別：</p>
<ul>
<li>所有整數型別像是 <code>u32</code>。</li>
<li>布林型別 <code>bool</code>，它只有數值 <code>true</code> 與 <code>false</code>。</li>
<li>所有浮點數型別像是 <code>f64</code>。</li>
<li>字元型別 <code>char</code>。</li>
<li>元組，不過包含的型別也都要有 <code>Copy</code> 才行。比如 <code>(i32, i32)</code> 就有 <code>Copy</code>，但 <code>(i32, String)</code> 則無。</li>
</ul>
<h3><a class="header" href="#所有權與函式" id="所有權與函式">所有權與函式</a></h3>
<p>傳遞數值給函式這樣的語義和賦值給變數是類似的。傳遞變數給函式會是移動或拷貝，就像賦值一樣。範例 4-3 說明了變數如何進入且離開作用域。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s 進入作用域

    takes_ownership(s);             // s 的值進入函式
                                    // 所以 s 也在此無效

    let x = 5;                      // x 進入作用域

    makes_copy(x);                  // x 本該移動進函式裡
                                    // 但 i32 有 Copy，所以 x 可繼續使用

} // x 在此離開作用域，接著是 s。但因爲 s 的值已經被移動了
  // 它不會有任何動作

fn takes_ownership(some_string: String) { // some_string 進入作用域
    println!(&quot;{}&quot;, some_string);
} // some_string 在此離開作用域並呼叫 `drop`
  // 佔用的記憶體被釋放

fn makes_copy(some_integer: i32) { // some_integer 進入作用域
    println!(&quot;{}&quot;, some_integer);
} // some_integer 在此離開作用域，沒有任何動作發生
</code></pre></pre>
<p><span class="caption">範例 4-3：具有所有權的函式</span></p>
<p>如果我們嘗試在呼叫 <code>takes_ownership</code> 後使用 <code>s</code>，Rust 會拋出編譯時期錯誤。這樣的靜態檢查可以免於我們犯錯。你可以試試看在 <code>main</code> 裡哪裡可以使用 <code>s</code> 和 <code>x</code>，以及所有權規則如何防止你寫錯。</p>
<h3><a class="header" href="#回傳值與作用域" id="回傳值與作用域">回傳值與作用域</a></h3>
<p>回傳值一樣能轉移所有權，範例 4-4 和範例 4-3 一樣有加上註解說明。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership 移動它的回傳值給 s1

    let s2 = String::from(&quot;hello&quot;);     // s2 進入作用域

    let s3 = takes_and_gives_back(s2);  // s2 移入 takes_and_gives_back
                                        // 該函式又將其回傳值移到 s3
} // s3 在此離開作用域並釋放
  // s2 離開作用域但已被移走，沒有任何動作發生
  // s1 離開作用域並釋放

fn gives_ownership() -&gt; String {             // gives_ownership 會將他的回傳值
                                             // 移動給呼叫它的函式

    let some_string = String::from(&quot;hello&quot;); // some_string 進入作用域

    some_string                              // 回傳 some_string 並移動給
                                             // 呼叫它的函式
}

// takes_and_gives_back 會取得一個 String 然後回傳它
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 進入作用域

    a_string  // 回傳 a_string 並移動給呼叫的函式
}
</code></pre></pre>
<p><span class="caption">範例 4-4：轉移回傳值的所有權</span></p>
<p>變數的所有權每次都會遵從相同的模式：賦值給其他變數就會移動。當擁有堆積資料的變數離開作用域時，該數值就會被 <code>drop</code> 清除，除非該資料被移動到其他變數所擁有。</p>
<p>在每個函式取得所有權在回傳所有權的確有點囉唆。要是我們可以讓函式使用一個數值卻不取得所所有權呢？要是我們想重複使用同個值，但每次都要傳入再傳出實在是很麻煩。而且我們有時也會想要讓函式回傳一些它們自己產生的值。</p>
<p>其中一個方法是可以用元組，如範例 4-5 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() 回傳 String 的長度

    (s, length)
}
</code></pre></pre>
<p><span class="caption">範例 4-5：回傳參數的所有權</span></p>
<p>但這實在太繁瑣，而且這樣的情況是很常見的。幸運的是 Rust 有提供一個概念叫做<em>引用（references）</em>。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/52b0d291d2000dfebfd0ad470bdd11bb91985439/src/ch04-01-what-is-ownership.md">52b0d29</a></li>
<li>updated: 2020-09-08</li>
</ul>
</blockquote>
<h2><a class="header" href="#引用與借用" id="引用與借用">引用與借用</a></h2>
<p>我們在範例 4-5 使用元組的問題在於，我們必須回傳 <code>String</code> 給呼叫的函式，我們才能繼續在呼叫 <code>calculate_length</code> 之後繼續使用 <code>String</code>，因爲 <code>String</code> 會被傳入 <code>calculate_length</code>。</p>
<p>以下是我們定義並使用 <code>calculate_length</code> 時，在參數改用引用物件而非取得所有權的程式碼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>首先你會注意到原先變數宣告與函式回傳值會用到元組的地方都被更改了。再來注意到我們傳遞的是 <code>&amp;s1</code> 給 <code>calculate_length</code>，然後在定義時我們是取 <code>&amp;String</code> 而非 <code>String</code>。這些「&amp;」符號就是<em>引用（references）</em>，它們允許你不必獲取所有權來引用它。以下用圖示 4-5 示意。 </p>
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />
<p><span class="caption">圖示 4-5：顯示 <code>&amp;String s</code> 指向 <code>String s1</code> 的示意圖</span></p>
<blockquote>
<p>注意：使用 <code>&amp;</code> 引用的反向動作是 <em>解引用（dereferencing）</em>，使用的是解引用運算符號 <code>*</code>。我們會在第八章看到一些解引用的範例並在第 15 章詳細解釋解引用。</p>
</blockquote>
<p>讓我們進一步看看函式的呼叫：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<p><code>&amp;s1</code> 語法讓我們可以建立一個指向 <code>s1</code> 數值的引用，但不會擁有它。因爲它並沒有所有權，它所指向的資料在引用離開作用域時並不會被丟棄。</p>
<p>同樣地，函式簽名也是用 <code>&amp;</code> 說明參數 <code>s</code> 是個引用。讓我們加一些註解在範例上：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;hello&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s 個 String 的引用
    s.len()
} // s 在此離開作用域，但因爲它沒有它所指向的資料的所有權
  // 沒有任何動作發生
</code></pre></pre>
<p>變數 <code>s</code> 有效的作用域和任何函式參數的作用域一樣，但當引用離開作用域時，我們不會丟棄任何它指向的資料，因爲我們沒有所有權。當函式使用引用作爲參數而非實際數值時，我們不需要回傳數值來還所有權，因爲我們不曾擁有過。</p>
<p>我們會稱呼函式用引用作爲參數叫做<em>借用（borrowing）</em>。就像現實世界一樣，如果有人擁有每項東西，他可以借用給你。當你使用完後，你就還給他。</p>
<p>所以要是我們嘗試修改我們借用的東西會如何呢？請試試範例 4-6 的程式碼。直接劇透你：它執行不了的！</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">範例 4-6：嘗試修改借用的值</span></p>
<p>以下是錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>如同變數預設是不可變，引用也是一樣的。我們不被允許修改我們引用的值。</p>
<h3><a class="header" href="#可變引用" id="可變引用">可變引用</a></h3>
<p>我們可以修正這項錯誤，只要在範例 4-6 做一點小修改就好：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>首先我們將 <code>s</code> 加上了 <code>mut</code>，然後我們用 <code>&amp;mut s</code> 建立了一個可變引用，然後以 <code>some_string: &amp;mut String</code> 來接收這個可變引用。</p>
<p>但是可變引用有個很大的限制：在特定作用域中的一個特定資料只能有一個可變引用。所以以下程式碼就會失敗：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre>
<p>以下是錯誤資訊：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>這項限制允許了可變行爲，但是同時也受到一定程度的約束。這通常是新 Rustaceans 遭受挫折的地方，因爲多數語言都會任你去改變其值。</p>
<p>這項限制的好處是 Rust 可以在編譯時期就防止資料競爭（data races）。<em>資料競爭</em>和競爭條件（race condition）類似，它會由以下三種行爲發生：</p>
<ul>
<li>同時有兩個以上的指標存取同個資料。</li>
<li>至少有一個指標在寫入資料。</li>
<li>沒有針對資料的同步存取機制。</li>
</ul>
<p>資料競爭會造成未定義行爲（undefined behavior），而且在執行時你通常是很難診斷並修正的。Rust 能夠阻止這樣的問題發生，因爲它不會讓有資料競爭的程式碼編譯通過！</p>
<p>如往常一樣，我們可以用大括號來建立一個新的作用域來允許多個可變引用，只要不是同時擁有就好：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 離開作用域，所以建立新的引用也不會有問題

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>類似的規則也存在於可變引用和不可變引用的組合中，以下程式碼就會產生錯誤：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // 沒問題
    let r2 = &amp;s; // 沒問題
    let r3 = &amp;mut s; // 很有問題！

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre>
<p>以下是錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>哇！看來我們<em>也不可以</em>在擁有不可變引用的同時擁有可變引用。擁有不可變引用的使用者可不希望有人暗地裡突然改變了值！不過數個不可變引用是沒問題的，因爲所有在讀取資料的人都無法影響其他人閱讀資料。</p>
<p>請注意引用的作用域始於它被宣告的地方，一直到它最後一次引用被使用爲止。舉例來說以下程式就可以編譯，因爲不可變引用最後一次的使用在可變引用宣告之前：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // 沒問題
    let r2 = &amp;s; // 沒問題
    println!(&quot;{} and {}&quot;, r1, r2);
    // r1 和 r2 從此不再使用
    
    let r3 = &amp;mut s; // 沒問題
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<p>不可變引用 <code>r1</code> 和 <code>r2</code> 的作用域在 <code>println!</code> 之後結束。這是它們最後一次使用到的地方，也就是在宣告可變引用 <code>r3</code> 之前。它們的作用域沒有重疊，所以程式碼是允許的。</p>
<p>雖然借用錯誤有時是令人沮喪的，但請記得這是 Rust 編譯器希望提前（在編譯時而非執行時）指出潛在程式錯誤並告訴你問題的源頭在哪。這樣你就不必親自追蹤到你爲何你的資料不是你所想的那樣。</p>
<h3><a class="header" href="#迷途引用" id="迷途引用">迷途引用</a></h3>
<p>在有指標的語言中，通常都很容易不小心產生<em>迷途指標（dangling pointer）</em>。當資源已經被釋放但指標卻還留著，這樣的指標指向的地方很可能就已經被別人所有了。相反地，在 Rust 中編譯器會保證引用絕不會是迷途引用：如果你有某些資料的引用，編譯器會確保資料不會在引用結束前離開作用域。</p>
<p>讓我們來嘗試產生迷途指標，看看 Rust 怎麼產生編譯期錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>以下是錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ help: consider giving it a 'static lifetime: `&amp;'static`
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>此錯誤訊息包含了一個我們還沒介紹的功能：生命週期（lifetimes）。我們會在第十章詳細討論生命週期。就算我們先不管生命週期的部分，錯誤訊息仍然告訴了我們程式出錯的關鍵點：</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<p>讓我們進一步看看我們的 <code>dangle</code> 程式碼每一步發生了什麼：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
</code></pre>
<p>因爲 <code>s</code> 是在 <code>dangle</code> 內產生的，當 <code>dangle</code> 程式碼結束時，<code>s</code> 會被釋放。但我們卻嘗試回傳引用。此引用會指向一個已經無效的 <code>String</code>。這看起來不太優！Rust 不允許我們這麼做。</p>
<p>解決的辦法是直接回傳 <code>String</code> 就好：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
</code></pre></pre>
<p>這樣就沒問題了。所有權轉移了出去，沒有任何值被釋放。</p>
<h3><a class="header" href="#引用規則" id="引用規則">引用規則</a></h3>
<p>讓我們來回顧我們討論到的引用規則：</p>
<ul>
<li>在任何時候，我們要麼<em>只能有</em>一個可變引用，要麼可以有<em>任意數量</em>的不可變引用。</li>
<li>引用必須永遠有效。</li>
</ul>
<p>接下來我們要來看看一個不太一樣的引用型別：slices。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch04-02-references-and-borrowing.md">d44317c</a></li>
<li>updated: 2020-09-08</li>
</ul>
</blockquote>
<h2><a class="header" href="#slice-型別" id="slice-型別">Slice 型別</a></h2>
<p>另一種沒有所有權的資料型別是 <em>slice</em>。Slice 讓你可以引用一串集合中的元素序列，而不非引用整個集合。</p>
<p>以下是個小小的程式問題：寫一支接收字串的函式並回傳第一個找到的單字，如果函式沒有在字串找到空格的話，就代表整個字串就是一個單字，所以就回傳整個字串。</p>
<p>先來想想看函式簽名該長怎樣：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>此函式 <code>first_word</code> 有一個參數 <code>&amp;String</code>。我們不需要取得所有權，所以這是合理的。但我們該回傳啥呢？我們目前還沒有方法能夠描述一個字串的<em>其中一部分</em>。不過我們可以回傳該單字的最後一個索引。讓我們像範例 4-7 這樣試試看。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 4-7：函式 <code>first_word</code> 回傳參數 <code>String</code> 第一個單字最後的索引</span></p>
<p>因爲我們需要遍歷 <code>String</code> 的每個元素並檢查該值是空格，我們要用 <code>as_bytes</code> 方法將 <code>String</code> 轉換成一個位元組陣列：</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>接下來我們使用 <code>iter</code> 方法對位元組陣列建立一個疊代器（iterator）：</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>我們會在第十三章討論疊代器的細節。現在我們只需要知道 <code>iter</code> 是個能夠回傳集合中每個元素的方法，然後 <code>enumerate</code> 會將 <code>iter</code> 的結果包裝起來回傳成元組。<code>enumerate</code> 回傳的元組中的第一個元素是索引，第二個才是元素的引用。這樣比我們自己計算索引還來的方便。</p>
<p>既然 <code>enumerate</code> 回傳的是元組，我們可以用模式配對來解構元組，就像在 Rust 其他地方使用的方式一樣。所以在 <code>for</code> 迴圈中，我們指定了一個模式讓 <code>i</code> 取得索引然後 <code>&amp;item</code> 取得元組中的位元組。因爲我們從用 <code>.iter().enumerate()</code> 取得引用的，所以在模式中我們用的是 <code>&amp;</code> 來獲取。</p>
<p>在 <code>for</code> 迴圈裡面我們使用字串字面值的語法搜尋位元組是不是空格。如果我們找到空格的話，我們就回傳該位置。不然我們就用 <code>s.len()</code> 回傳整個字串的長度：</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>我們現在有了一個能夠找到字串第一個單字結尾索引的辦法，但還有一個問題。我們回傳的是一個獨立的 <code>usize</code>，它套用在 <code>&amp;String</code> 身上才有意義。換句話說，因爲它是個與 <code>String</code> 沒有直接關係的數值，我們無法保證它在未來還是有效的。參考一下使用了範例 4-7 中函式 <code>first_word</code> 的範例 4-8：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word 取得數值 5

    s.clear(); // 這會清空 String，這就等於 &quot;&quot;

    // word 仍然是數值 5 ，但是我們已經沒有相等意義的字串了
    // 擁有 5 的變數 word 現在完全沒意義！
}
</code></pre></pre>
<p><span class="caption">範例 4-8：先儲存呼叫函式 <code>first_word</code>的結果再變更 <code>String</code> 的內容</span></p>
<p>此程式可以成功編譯沒有任何錯誤，而且我們在呼叫 <code>s.clear()</code> 後仍然能使用 <code>word</code>。因爲 <code>word</code> 和 <code>s</code> 並沒有直接的關係，<code>word</code> 在之後仍能繼續保留 <code>5</code>。我們可以用 <code>s</code> 取得 <code>5</code> 並嘗試取得第一個單字。但這樣就會是程式錯誤了，因爲 <code>s</code> 的內容自從我們賦值 <code>5</code> 給 <code>word</code> 之後的內容已經被改變了。</p>
<p>要隨時留意 <code>word</code> 會不會與 <code>s</code> 的資料脫鉤是很煩瑣的且容易出錯！要是我們又寫了個函式 <code>second_word</code>，管理這些索引會變得非常難以管控！我們會不得不將函式簽名改成這樣：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>現在我們得同時紀錄起始<em>與</em>結束的索引，而且我們還產生了更多與原本數值沒辦法直接相關的計算結果。我們現在有三個非直接相關的變數需要保持同步。</p>
<p>幸運的是 Rust 爲此提供了一個解決辦法：字串 slice。</p>
<h3><a class="header" href="#字串-slice" id="字串-slice">字串 Slice</a></h3>
<p><em>字串 slice</em> 是 <code>String</code> 其中一部分的引用，它長得像這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>這和取得整個 <code>String</code> 的引用相似，但是加上了 <code>[0..5]</code>。所以與其引用整個 <code>String</code>，這個只引用了一部分的<code>String</code>。</p>
<p>我們可以像這樣 <code>[起始索引..結束索引]</code> 用中括號加上一個範圍來建立 slice。<code>起始索引</code> 是 slice 的第一個位置，而 <code>結束索引</code> 在索引結尾之後的位置（所以不包含此值）。在內部的 slice 資料結構會儲存起始位置，以及 <code>結束索引</code> 與 <code>起始索引</code> 相減後的長度。所以用 <code>let world = &amp;s[6..11];</code> 作爲例子的話， <code>world</code> 就會是個 slice，包含一個指標指向 <code>s</code> 第七個位元組和一個長度數值 <code>5</code>。</p>
<p>Figu圖示re 4-6 就是此例的示意圖。</p>
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
<p><span class="caption">圖示 4-6：指向部分 <code>String</code> 的字串 slice</span></p>
<p>要是你想用 Rust 指定範圍的語法 <code>..</code> 從第一個索引（也就是零）開始的話，你可以省略兩個句點之前的值。換句話說，以下兩個是相等的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>同樣地，如果你的 slice 包含 <code>String</code> 的最後一個位元組的話，你同樣能省略最後一個數值。這代表以下都是相等的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>如果你要獲取整個字串的 slice，你甚至能省略兩者的數值，以下都是相等的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意：字串 slice 的索引範圍必須是有效的 UTF-8 字元界限。如果你嘗試從一個多位元組字元（multibyte character）中產生字串 slice，你的程式就會回傳錯誤。爲了方便介紹字串 slice，本章指使用了 ASCII 字元而已。
我們會在第八章的<a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">「使用 String 儲存 UTF-8 編碼的文字」</a><!-- ignore -->做更詳盡的討論。</p>
</blockquote>
<p>有了這些資訊，讓我們用 slice 來重寫 <code>first_word</code> 吧。「字串字面值」的的回傳型態我們會寫 <code>&amp;str</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>我們如同範例 4-7 一樣用判斷第一個空格取得了單字結尾的索引。當我們找到第一個空格，我們用字串的初始索引與當前空格的索引作爲初始與結束索引來回傳字串 slice。</p>
<p>現在當我們呼叫 <code>first_word</code>，我們就會取得一個與原本資料有直接相關的數值。此數值是由 slice 的起始位置即 slice 中的元素數量組成。</p>
<p>這樣函式 <code>second_word</code>  一樣也可以回傳 slice：</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>我們現在有個不可能出錯且更直觀的 API，因爲編譯器會確保 <code>String</code> 的引用會是有效的。還記得我們在範例 4-8 的錯誤嗎？就是那個當我們取得單字結尾索引，但字串卻已清空變成無效的錯誤。那段程式碼邏輯是錯誤的，卻不會馬上顯示錯誤。要是我們持續嘗試用該索引存取空字串的話，問題才會浮現。Slice 可以讓這樣的程式錯誤無所遁形，並及早讓我們知道我們程式碼有問題。使用 slice 版本 <code>first_word</code> 的程式碼的話就會出現編譯期錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p>以下是錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>回憶一下借用規則，要是我們有不可變引用的話，我們就不能取得可變引用。因爲 <code>clear</code> 會縮減 <code>String</code>，它必須是可變引用。這樣一來 Rust 就不允許，並讓編譯失敗。Rust 不僅讓我們的 API 更容易使用，還想辦法讓所有錯誤在編譯期就消除！</p>
<h4><a class="header" href="#字串字面值就是-slices" id="字串字面值就是-slices">字串字面值就是 Slices</a></h4>
<p>回想一下我們講說字串字面值是怎麼存在二進制檔案的。現在既然我們已經知道 slices，我們就能知道更清楚字串字面值：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>此處 <code>s</code> 的型別是 <code>&amp;str</code>：它是指向二進制檔案某部份的 slice。這也是爲何字串字面值是不可變的，<code>&amp;str</code> 是個不可變引用。</p>
<h4><a class="header" href="#字串-slice-作爲參數" id="字串-slice-作爲參數">字串 Slice 作爲參數</a></h4>
<p>知道你可以取得字面值的 slices 與 <code>String</code> 數值後，我們可以再改善一次 <code>first_word</code>。那就是它的簽名：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>較富有經驗的 Rustacean 會用範例 4-9 的方式編寫函式簽名，因爲這讓該函式可以同時接受 <code>&amp;String</code> 和 <code>&amp;str</code> 的數值。</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word 適用於 `String` 的 slice
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word 適用於字串字面值
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // 因爲字串字面值*本來*竟是 slices
</span><span class="boring">    // 沒有 slice 語法也是可行的！
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 4-9：使用字串 slice 作爲參數 <code>s</code> 來改善函式 <code>first_word</code></span></p>
<p>如果我們有字串字面值的話，我們可以直接傳遞。如果我們有 <code>String</code> 的話，我可以們傳遞整個 <code>String</code> 的 slice。定義函式的參數爲字串字面值而非 <code>String</code> 可以讓我們的 API 更通用且不會失去去任何功能：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word 適用於 `String` 的 slice
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word 適用於字串字面值
    let word = first_word(&amp;my_string_literal[..]);

    // 因爲字串字面值*本來*竟是 slices
    // 沒有 slice 語法也是可行的！
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3><a class="header" href="#其他-slices" id="其他-slices">其他 Slices</a></h3>
<p>字串 slices 如你所想的一樣是特別針對字串的。但是我們還有更通用的 slice 型別。請考慮以下陣列：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>就像我們引用一部分的字串一樣，我們可以這樣引用一部分的字串：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>此 slice 的型別爲 <code>&amp;[i32]</code>，它和字串運作的方式一樣，儲存了 slice 的第一個元素以及總長度。你以後會對其他集合也使用這樣的 slice。我們會在第八章討論這些集合的更多細節。</p>
<h2><a class="header" href="#總結-2" id="總結-2">總結</a></h2>
<p>所有權、借用與 slices 的概念讓 Rust 可以在編譯時期就確保記憶體安全。Rust 程式語言讓你和其他程式語言一樣控制你的記憶體使用方式，但是會在所有者離開作用域時自動清除擁有的資料，讓你不必在編寫或除錯額外的程式碼。</p>
<p>所有權影響了 Rust 很多其它部分執行的方式，所以我們在書中之後討論這些概念。讓我們繼續到第五章，看看如何用 <code>struct</code> 將資料組合在一起。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch04-03-slices.md">d44317c</a></li>
<li>updated: 2020-09-08</li>
</ul>
</blockquote>
<h1><a class="header" href="#透過結構體組織相關資料" id="透過結構體組織相關資料">透過結構體組織相關資料</a></h1>
<p><em>struct</em>或*結構體（structure）*是個讓你命名並封裝數個相關數值爲單一組合的自定型別。如果你熟悉物件導向語言的話，<em>struct</em> 就像是物件的資料屬性。在本章節，我們會比較元組與結構體的差別，介紹如何使用結構體，並討論如何定義結構體資料的方法與相關函式行爲。結構體與將會在第六章提到的枚舉（enum）是 Rust 產生新型別的基本元件，它們能充分利用 Rust 的編譯時型別檢查。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch05-00-structs.md">d44317c</a></li>
<li>updated: 2020-09-08</li>
</ul>
</blockquote>
<h2><a class="header" href="#定義與實例化結構體" id="定義與實例化結構體">定義與實例化結構體</a></h2>
<p>結構體（Structs）和我們在第三章討論過的元組類似。和元組一樣，結構體的每個部分可以是不同的型別。但與元組不同的地方是，你必須爲每個資料部分命名以便表達每個數值的意義。因爲有了這些名稱，結構體通常比元組還來的有彈性：你不需要依賴資料的順序來指定或存取實例中的值。</p>
<p>欲定義結構體，我們輸入關鍵字 <code>struct</code> 並爲整個結構體命名。結構體的名稱需要能夠描述其所組合出的資料意義。然後在大括號內，我們對每個資料部分定義名稱與型別，我們會稱爲<em>欄位（fields）</em>。舉例來說，範例 5-1 定義了一個儲存使用者帳號的結構體。</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 5-1：<code>User</code> 結構體定義</span></p>
<p>要在我們定義後使用該結構體，我們可以指定每個欄位的實際數值來建立結構體的<em>實例</em>。要建立實例的話，我們先寫出結構體的名稱再加上大括號，裡面會包含數個 <code>key: value</code> 的配對。<code>key</code> 是每個欄位的名稱，而 <code>value</code> 就是你想給予欄位的數值。欄位的順序可以不用和定義結構體時的順序一樣。換句話說，結構體的定義比較像是型別的通用樣板，然後實例會依據此樣板插入特定資料來將產生型別的數值。比如說，我們可以像範例 5-2 這樣宣告一個特定使用者。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-2：產生一個 <code>User</code> 結構體的實例</span></p>
<p>要取得結構體中特定數值的話，我們可以使用句點。如果我們只是想要此使用者的電子郵件信箱，我們可以在任何我們想使用此值的地方使用 <code>user1.email</code>。如果該實例可變的話，我們可以使用句點並賦值給該欄位來改變其值。範例 5-3 顯示了如何改變一個可變 <code>User</code> 實例中 <code>email</code> 欄位的值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-3：改變 <code>User</code> 中 <code>email</code> 欄位的值</span></p>
<p>請注意整個實例必須是可變的，Rust 不允許我們只標記特定欄位是可變的。再來，就像任何表達式一樣，我們可以在函式本體最後的表達式中，建立一個新的結構體實例作爲回傳值。</p>
<p>範例 5-4 展示了 <code>build_user</code> 函式會依據給予的電子郵件和使用者名稱來回傳 <code>User</code> 實例。而 <code>active</code> 欄位取得數值 <code>true</code> 且 <code>sign_in_count</code> 取得數值 <code>1</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-4：<code>build_user</code> 函式取得電子郵件與使用者名稱並回傳 <code>User</code> 實例</span></p>
<p>函式參數名稱與結構體欄位名稱相同是非常合理的，但是要重複寫 <code>email</code> 和 <code>username</code> 的欄位名稱與變數就有點冗長了。如果結構體有更多欄位的話，重複寫這些名稱就顯得有些煩人了。幸運的事，我們的確有更方便的語法！</p>
<h3><a class="header" href="#當變數與欄位名稱相同時使用欄位初始化簡寫語法" id="當變數與欄位名稱相同時使用欄位初始化簡寫語法">當變數與欄位名稱相同時使用欄位初始化簡寫語法</a></h3>
<p>由於範例 5-4 的參數名稱與結構體欄位名稱相同，我們可以使用*欄位初始化簡寫（field init shorthand）*語法來重寫 <code>build_user</code>，讓它的結果相同但不必重複寫出 <code>email</code> 和 <code>username</code>，如範例 5-5 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        String::from(&quot;someusername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-5：<code>build_user</code> 函式使用欄位初始化簡寫，因爲參數 <code>email</code> 與 <code>username</code> 結構體欄位相同</span></p>
<p>在此我們建立了 <code>User</code> 結構體的實例，它有一個欄位叫做 <code>email</code>。我們希望用 <code>build_user</code> 函式中的參數 <code>email</code> 賦值給 <code>email</code> 欄位。然後因爲 <code>email</code> 欄位與 <code>email</code> 參數有相同的名稱，我們只要寫 <code>email</code> 就好，不必寫 <code>email: email</code>。</p>
<h3><a class="header" href="#使用結構體更新語法從其他結構體建立實例" id="使用結構體更新語法從其他結構體建立實例">使用結構體更新語法從其他結構體建立實例</a></h3>
<p>通常我們也會從舊的實例來產生新的實例，不過修改一些欄位數值，這時你可以使用<em>結構體更新語法（struct update syntax）</em>。</p>
<p>首先範例 5-6 顯示了我們沒有使用更新語法來建立新的 <code>User</code> 實例 <code>user2</code>。我們設置了新的數值給 <code>email</code> 和 <code>username</code>，但其他欄位就使用我們在範例 5-2 建立的 <code>user1</code> 相同的值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        username: String::from(&quot;anotherusername567&quot;),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-6：從 <code>user1</code> 一些值中建立新的 <code>User</code> 實例</span></p>
<p>使用結構體更新語法，我們可以用較少的程式碼達到相同的效果，如範例 5-7 所示。<code>..</code> 語法表示剩下沒指明的欄位都會取得與所提供的實例相同的值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;someusername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;another@example.com&quot;),
        username: String::from(&quot;anotherusername567&quot;),
        ..user1
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-7：對新的 <code>User</code> 實例設置新的 <code>email</code> 和 <code>username</code> 數值，但其他欄位使用與 <code>user1</code> 變數實例中欄位相同的值</span></p>
<p>範例 5-7 的程式碼一樣產生了有不同 <code>email</code> 和 <code>username</code> 的 <code>user2</code> 實例，但是有與 <code>user1</code> 相同的 <code>active</code> 和 <code>sign_in_count</code>。</p>
<h3><a class="header" href="#使用無名稱欄位的元組結構體來建立不同型別" id="使用無名稱欄位的元組結構體來建立不同型別">使用無名稱欄位的元組結構體來建立不同型別</a></h3>
<p>你還可以定義結構體讓它長得像是元組那樣，我們稱作<em>元組結構體（tuple structs）</em>。元組結構體仍然有定義整個結構的名稱，但是它們的欄位不會有名稱，它們只會有欄位型別而已。元組結構體的用途在於當你想要爲元組命名，好讓它跟其他不同型別的元組作出區別，以及對常規結構體每個欄位命名是冗長且不必要的時候。</p>
<p>要定義一個元組結構體，一樣先從 <code>struct</code> 關鍵字開始，其後再接著要定義的元組。舉例來說，以下是兩個使用元組結構體定義的 <code>Color</code> 和 <code>Point</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<p>注意 <code>black</code> 與 <code>origin</code> 屬於不同型別，因爲它們是不同的元組結構體實例。每個你定義的結構體都是專屬於自己的型別，就算它們的欄位型別一摸一樣。舉例來說，一個參數爲 <code>Color</code> 的函式就無法接受 <code>Point</code> 引數，就算它們的型別都是三個 <code>i32</code> 的組合。除此之外，元組結構體實例的行爲和元組類似：你可以將它們解構爲獨立部分，你也可以使用 <code>.</code> 加上索引來取得每個數值等等。</p>
<h3><a class="header" href="#無任何欄位的類單位結構體" id="無任何欄位的類單位結構體">無任何欄位的類單位結構體</a></h3>
<p>你也可以定義沒有任何欄位的結構體！這些叫做<em>類單位結構體（unit-like structs）</em>，因爲它們的行爲就很像 <code>()</code> 單位型別（unit type）。類單位結構體很適合用在當你要實作一個特徵（trait）或某種型別，但你沒有任何需要儲存在型別中的資料。我們會在第十章討論特徵。</p>
<blockquote>
<h3><a class="header" href="#結構體資料的所有權" id="結構體資料的所有權">結構體資料的所有權</a></h3>
<p>在範例 5-1 的 <code>User</code> 結構體定義中，我們使用了擁有所有權的 <code>String</code> 型別，而不是 <code>&amp;str</code> 字串 slice 型別。這邊是故意這樣選擇的，因爲我們希望解構體的實例可以擁有它所有的資料，並在整個結構體都有效時資料也是有效的。</p>
<p>要在結構體中儲存別人擁有的資料引用是可行的，但這會用到<em>生命週期（lifetimes）</em>，我們在第十章才會談到。生命週期能確保資料引用在結構體存在期間都是有效的。要是你沒有使用生命週期來用結構體儲存引用的話，會如以下出錯：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
<pre><code class="language-rust ignore does_not_compile">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>編譯器會抱怨它需要生命週期標記：</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`.

To learn more, run the command again with --verbose.
</code></pre>
<p>在第十章，我們將會討論如何修正這樣的錯誤，好讓你可以在結構體中儲存引用。但現在的話，我們先用有所有權的 <code>String</code> 而非 <code>&amp;str</code> 引用來避免錯誤。</p>
</blockquote>
<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch05-01-defining-structs.md">d44317c</a></li>
<li>updated: 2020-09-10</li>
</ul>
</blockquote>
<h2><a class="header" href="#使用結構體的程式範例" id="使用結構體的程式範例">使用結構體的程式範例</a></h2>
<p>爲了瞭解我們何時會想要使用結構體，讓我們來寫一支計算長方行面積的程式。我們會先從單一變數開始，在慢慢重構成使用結構體。</p>
<p>讓我們用 Cargo 建立一個新的專案 <em>rectangles</em> ，它將接收長方形的長度與寬度，然後計算出長方形的面積。範例 5-8 展示了在我們專案底下 <em>src/main.rs</em> 的小程式用其中一種方式寫出來。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">範例 5-8：使用變數 width 和 height 計算長方形面積</span></p>
<p>現在使用 <code>cargo run</code> 執行程式：</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/structs`
The area of the rectangle is 1500 square pixels.
</code></pre>
<p>雖然範例 5-8 可以執行並呼叫 <code>area</code> 函式計算出長方形的面積，但我們可以做得更好。寬度與長度是互相關聯的，因爲它們在一起剛好定義了一個長方形。</p>
<p>此程式碼的問題在 <code>area</code> 的函式簽名就能看出來：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}
</span></code></pre>
<p><code>area</code> 函式應該要計算長方形的面積，但是我們寫的函式有兩個參數。參數之間是有關聯的，但是它在我們的程式中沒有表現出來。要是能將寬度與長度組合起來的話，會更容易閱讀與管理。我們可以使用我們在第三章提到的<a href="ch03-02-data-types.html#the-tuple-type">「元組型別」</a><!-- ignore -->。</p>
<h3><a class="header" href="#使用元組重構" id="使用元組重構">使用元組重構</a></h3>
<p>範例 5-9 展示了我們的程式用元組的另一種寫法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">範例 5-9：使用元組指定長方形的寬度與長度</span></p>
<p>一方面來說，此程式的確比較好。元組讓我們增加了一些結構，而我們現在只需要傳遞一個引數。但另一方面來說，此版本的閱讀性反而更差。元組無法命名它的元素，所以我們在計算時反而更讀懂，我們傳得只是元組的索引。</p>
<p>我們在計算面積時，哪個值是寬度還是長度的確不重要。但如果我們要顯示出來的話，這就很重要了！我們會需要記住元組索引 <code>0</code> 是 <code>width</code> 然後元組索引 <code>1</code> 是 <code>height</code>。如果有其他人要維護這段程式碼的話，他就也得知道並記住這件事才行。但事實上是我們很常忘記這樣數值的意義並導致錯誤發生，因爲我們無法從程式碼推導出資料的意義。</p>
<h3><a class="header" href="#使用結構體重構賦予更多意義" id="使用結構體重構賦予更多意義">使用結構體重構：賦予更多意義</a></h3>
<p>我們可以用結構體來爲資料命名以賦予其意義。我們可以將元組轉會成一個有整體名稱且內部資料也都有名稱的資料型別。，如範例 5-10 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">範例 5-10：定義 <code>Rectangle</code> 結構體</span></p>
<p>我們在此定義了一個結構體叫做 <code>Rectangle</code>。在大括號內，我們定義了 <code>width</code> 與 <code>height</code> 的欄位，兩者型別皆爲。然後在 <code>main</code> 中，我們建立了一個寬度爲 30 長度爲 50 的 <code>Rectangle</code> 實例。</p>
<p>現在我們的 <code>area</code> 函式使需要一個參數 <code>rectangle</code>，其型別爲 <code>Rectangle</code> 結構體實例的不可變借用。如同第四章提到的，我們希望借用結構體而非取走其所有權。這樣一來，<code>main</code> 能保留它的所有權並讓 <code>rect1</code> 繼續使用，這也是爲何我們要在要呼叫函式的簽名中使用 <code>&amp;</code>。</p>
<p><code>area</code> 函式能夠存取 <code>Rectangle</code> 中的 <code>width</code> 與 <code>height</code> 欄位。我們的 <code>area</code> 函式簽名由可以表達出我們想要做的事情了：使用 <code>width</code> 與 <code>height</code> 欄位來計算 <code>Rectangle</code> 的面積。這能表達出寬度與長度之間的關係，並且給了它們容易讀懂的名稱，而不是像元組那樣用索引 <code>0</code> 和 <code>1</code>。這樣清楚多了。</p>
<h3><a class="header" href="#使用推導特徵實現更多功能" id="使用推導特徵實現更多功能">使用推導特徵實現更多功能</a></h3>
<p>現在要是能夠在我們除錯程式時能夠印出 <code>Rectangle</code> 的實例並看到它所有的欄位數值就更好了。範例 5-11 嘗試使用我們之前章節提到的 <code>println!</code> 巨集，但是卻無法執行。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">範例 5-11：嘗試印出 <code>Rectangle</code> 實例</span></p>
<p>當我們編譯此程式碼時，我們會得到以下錯誤訊息：</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p><code>println!</code> 巨集預設可以做各式各樣的格式化，大括號告訴 <code>println!</code> 要使用 <code>Display</code> 特徵的格式化方式：其輸出結果是用來給最終使用者使用的。我們目前遇過的基本型別預設都會實作 <code>Display</code>，因爲它們也只有一種顯示方式（像是 <code>1</code>）能夠給使用者。但是對結構體來說 <code>println!</code> 要怎麼格式化輸出結果就會有點不明確了，因爲顯示的方式就很有多種。是要加上頓號嗎？是要印出大括號嗎？所有的欄位都要顯示出來嗎？基於這些不確定因素，Rust 不會去猜我們要的是什麼，所以結構體預設並沒有 <code>Display</code> 的實作。</p>
<p>如果我們繼續閱讀錯誤訊息，我們會得到一些有幫助的資訊：</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>讓我們來試試看吧！<code>println!</code> 巨集的呼叫方式現在看起來應該會像這樣 <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>。在 <code>println!</code> 內加上 <code>:?</code> 這樣的標記指的是我們想要使用 <code>Debug</code> 特徵來作爲輸出格式方式。<code>Debug</code> 特徵讓我們能印出對開發者有幫助的資訊，好讓我們在除錯程式時可以看到它的數值。</p>
<p>但是要是編譯這樣的程式的話，哎呀！我們卻還是會得到錯誤：</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
</code></pre>
<p>不過同樣地，編譯器又給了我們有用的資訊：</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
</code></pre>
<p>Rust <em>的確</em> 有印出除錯資訊的功能，但是我們要針對我們的結構體顯式實作出來才會有對應的功能。爲此我們可以在結構體前加上 <code>#[derive(Debug)]</code>，如範例 5-12 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">範例 5-12：加上推導（derive） <code>Debug</code> 特徵的標記並印出 <code>Rectangle</code> 實例的格式化資訊</span></p>
<p>現在當我們執行程式，我們不會在得到錯誤了，而且我們可以看到格式化厚的輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>漂亮！雖然這不是非常好看的輸出格式，但是它的確顯示了實例中所有的欄位數值，這對我們除錯時會非常有用。不過如果我們的結構體非常龐大的話，我們會希望輸出格式可以比較好閱讀。爲此我們可以在 <code>println!</code> 的字串使用 <code>{:#?}</code> 而非 <code>{:?}</code>。當我們使用 <code>{:#?}</code> 風格的話，輸出結果會長得像這樣：</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 is Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Rust 提供了一些特徵並讓我們可以用 <code>derive</code> 標記來爲自定型態加入些實用的功能。這類的特徵與其行爲都列在附錄 C。我們會在第十章介紹如何定義自定特徵，且如何實作這些特徵的自訂行爲。</p>
<p>我們的函式 <code>area</code> 最後就非常清楚明白了，它只會計算長方形的面積。這樣的行爲要是能夠緊貼著我們的 <code>Rectangle</code> 結構體，因爲這樣一來它就不會相容於其他型別。讓我們看看我們如何繼續重構我們的程式碼，接下來我們可以將函式 <code>area</code> 轉換爲 <code>Rectangle</code> 型別的*方法（method）*將。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch05-02-example-structs.md">d44317c</a></li>
<li>updated: 2020-09-10</li>
</ul>
</blockquote>
<h2><a class="header" href="#方法語法" id="方法語法">方法語法</a></h2>
<p><em>方法（Methods）</em> 和函式類似，它們都用 <code>fn</code> 關鍵字並加上它們名稱來宣告，它們都有參數與回傳值，然後它們包含一些程式碼能夠在其他地方呼叫它們。不過，方法與函式不同的地方在於它們是針對結構體定義的（或是枚舉和特徵物件，我們會在第六章與第十七章分別介紹它們），且它們第一個參數永遠是 <code>self</code>，這代表的是呼叫該方法的結構體實例。</p>
<h3><a class="header" href="#定義方法" id="定義方法">定義方法</a></h3>
<p>讓我們把 <code>Rectangle</code> 作爲參數的 <code>area</code> 函式轉換成定義在 <code>Rectangle</code> 內的 <code>area</code> 方法，如範例 5-13 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">範例 5-13：在 <code>Rectangle</code> 中定義 <code>area</code> 方法</span></p>
<p>要定義 <code>Rectangle</code> 中的方法，我們先從 <code>impl</code>（implementation） 區塊開始。再來將 <code>area</code> 移入 <code>impl</code> 的大括號中，並將簽名中的第一個參數（在此例中是唯一一個）與其本體中用到的地方改成 <code>self</code>。在 <code>main</code> 中我們原先使用 <code>rect1</code> 作爲引數呼叫的 <code>area</code>，可以改成使用*方法語法（method syntax）*來呼叫 <code>Rectangle</code> 的 <code>area</code> 方法。方法語法在實例後面呼叫，我們在其之後加上句點、方法名稱、括號然後任何所需的引數。</p>
<p>在 <code>area</code> 的簽名中，我們使用 <code>&amp;self</code> 而非 <code>rectangle: &amp;Rectangle</code>，這是因爲此方法位於 <code>impl Rectangle</code> 底下，Rust 知道 <code>self</code> 的型別爲 <code>Rectangle</code>。請注意我們仍然在 <code>self</code> 使用 <code>&amp;</code>，如同我們之前用的 <code>&amp;Rectangle</code>。方法讓我們擁有 <code>self</code> 的所有權的情況下，並在此借用不可變的 <code>self</code>。不過我們也可以在前面加上 <code>mut</code> 讓 <code>self</code> 的借用成爲可不變的，就像其他參數一樣。</p>
<p>我們之所以選擇 <code>&amp;self</code> 的原因和我們在之前函式版本的 <code>&amp;Rectangle</code> 一樣，我們不想取得所有權，只想讀取結構體的資料，而非寫入它。如果我們想要透過方法改變實例的數值的話，我們會使用 <code>&amp;mut self</code> 作爲第一個參數。而只使用 <code>self</code> 取得所有權的方法更是非常少見，這種使用技巧通常是爲了想改變 <code>self</code> 成你想要的樣子，並且希望能避免原本被改變的實例繼續被呼叫。</p>
<p>使用方法而非函式最大的好處是，除了可以使用方法語法而不必在方法簽名重複 <code>self</code> 的型別之外，其更具組織性。我們將所有一個型別所能做的事都放入 <code>impl</code> 區塊中了，而不必讓未來的使用者在茫茫函式庫中尋找 <code>Rectangle</code> 的功能。</p>
<blockquote>
<h3><a class="header" href="#--運算子跑去哪了" id="--運算子跑去哪了"><code>-&gt;</code> 運算子跑去哪了？</a></h3>
<p>在 C 與 C++ 中，我們有兩種呼叫方式的運算元：我們會用 <code>.</code> 來直接呼叫物件的方法；用 <code>-&gt;</code> 來呼叫需要先解引用的物件。換句話說，如果 <code>object</code> 是指標的話，<code>object-&gt;something()</code> 就會像是<code>(*object).something()</code>。</p>
<p>Rust 沒有提供 <code>-&gt;</code> 這樣的運算子。相反地 Rust 有個功能叫做 <em>自動引用與解引用（automatic referencing and dereferencing）</em>。呼叫方法是 Rust 少數會有這樣行爲的地方。</p>
<p>運作方式如下：當你呼叫方法像是 <code>object.something()</code> 時，Rust 會自動加上<code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code>，以便符合方法簽名。換句話說，以下範例是相同的：</p>
</blockquote>
<!-- CAN'T EXTRACT SEE BUG TODO -->
<blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>第一個呼叫簡潔多了，這種自動引用的行爲之所以可行是因爲方法有明確的 <code>self</code> 引用型別。依據接收者的方法名稱，Rust 可以知道該方法是在讀取（<code>&amp;self</code>）、可變的（<code>&amp;mut self</code>）或是會消耗的（<code>self</code>）。而 Rust 之所以允許借用方法接收者成隱式的原因，是因爲這可以讓所有權更易讀懂。</p>
</blockquote>
<h3><a class="header" href="#擁有更多參數的方法" id="擁有更多參數的方法">擁有更多參數的方法</a></h3>
<p>讓我們來練習再實作另一個 <code>Rectangle</code> 的方法。這次我們要 <code>Rectangle</code> 的實例可以接收另一個 <code>Rectangle</code> 實例，要是 <code>self</code> 本身可以包含另一個 <code>Rectangle</code> 的話我們就回傳 <code>true</code>，不然的話就回傳 <code>false</code>。也就是我們希望定一個方法 <code>can_hold</code> 如範例 5-14 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">範例 5-14：使用一個還沒定義完的方法 <code>can_hold</code></span></p>
<p>然後我們預期的輸出結果會如以下所示，因爲 <code>rect2</code> 的兩個維度都比 <code>rect1</code> 小，但 <code>rect3</code> 會比 <code>rect1</code> 大：</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>我們知道我們要定義方法的話，它一定得在 <code>impl Rectangle</code> 區塊底下。方法的名稱會叫做 <code>can_hold</code>。它會取得另一個 <code>Rectangle</code> 的不可變引用作爲參數。我們可以從程式碼呼叫方法的地方來知道參數的可能的型別：<code>rect1.can_hold(&amp;rect2)</code> 傳遞了 <code>&amp;rect2</code>，這是一個 <code>rect2</code> 的不可變引用，同時也是 <code>Rectangle</code> 的實例。這是合理的，因爲我們只需要讀取 <code>rect2</code>（而不是寫入，寫入代表我們需要可變引用），且我們希望 <code>main</code> 能夠保持 <code>rect2</code> 的所有權，好讓我們之後能在繼續使用它來呼叫 <code>can_hold</code> 方法。<code>can_hold</code> 的回傳值會是布林值，然後實作細節會是檢查 <code>self</code> 的寬度與長度是否都大於其他 <code>Rectangle</code> 的寬度與長度。讓我們加入範例 5-13 的 <code>can_hold</code> 方法到 <code>impl</code> 區塊中，如範例 5-15 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-15：在 <code>Rectangle</code> 中實作了取得其他 <code>Rectangle</code> 作爲參數的 <code>can_hold</code> 方法</span></p>
<p>當我們用範例 5-14 的 <code>main</code> 函式執行此程式碼的話，我們會得到預期的輸出結果。方法可以在參數 <code>self</code> 之後接收更多參數，而那些參數就和函式中的參數用法一樣。</p>
<h3><a class="header" href="#關聯函式" id="關聯函式">關聯函式</a></h3>
<p><code>impl</code> 區塊另一個實用的功能是，我們允許在 <code>impl</code> 內定義函式且無需以 <code>self</code> 作爲參數。這叫叫做<em>關聯函式（associated functions）</em>，因爲它們與結構體是相關的。它們仍然是函式而非方法，因爲它們沒有用到結構體的實例。你已經用到了 <code>String::from</code> 此關聯函式。</p>
<p>關聯函式很常用作建構子，來產生新的結構體實例。舉例來說，我們可以提供一個只接收一個維度作爲參數的關聯函式，讓它賦值給寬度與長度，讓我們可以用 <code>Rectangle</code> 來產生正方形，而不必提供兩次相同的值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}
</span></code></pre></pre>
<p>要呼叫關聯函式的話，我們使用 <code>::</code> 語法並加上結構體的名稱。比方說 <code>let sq = Rectangle::square(3);</code>。此函式用結構體名稱作爲命名空間，<code>::</code> 語法可以用在關聯函式以及模組的命名空間，我們會在第七章介紹模組。</p>
<h3><a class="header" href="#多重-impl-區塊" id="多重-impl-區塊">多重 <code>impl</code> 區塊</a></h3>
<p>每個結構體都允許有數個 <code>impl</code> 區塊。舉例來說，範例 5-15 與範例 5-16 展示的程式碼是一樣的，它讓每個方法都有自己的 <code>impl</code> 區塊。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 5-16：使用多重 <code>impl</code> 來重寫範例 5-15</span></p>
<p>這邊我們的確沒有將方法拆爲 <code>impl</code> 區塊的理由，不過這樣的語法是合理的。我們會在第十章介紹泛型型別與特徵，看到多重 <code>impl</code> 區塊是非常實用的案例。</p>
<h2><a class="header" href="#總結-3" id="總結-3">總結</a></h2>
<p>結構體讓你可以自訂對你的領域有意義的型別。使用結構體的話，你可以讓每個資料部分與其他部分具有相關性，並爲每個部分讓程式更好讀懂。方法讓你可以爲你的結構體實例指定特定行爲，然後關聯函式讓你可以在沒有實例的情況下，將特定功能置入結構體的命名空間。</p>
<p>但是結構體並不是自訂型別的唯一方法：讓我看看 Rust 的沒枚舉功能，讓你的工具箱可以再多一項工具使用。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/5c71aac64380f74f34cd9a158cc2b1d9122b5ceb/src/ch05-03-method-syntax.md">5c71aac</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h1><a class="header" href="#枚舉與模式配對" id="枚舉與模式配對">枚舉與模式配對</a></h1>
<p>在本章節中，我們將討論 <em>枚舉（enumerations）</em>，有時也被簡寫爲 <em>enums</em>。枚舉讓你定義一個能夠列舉其可能*變體（variants）*的型別。首先，我們會定義並使用枚舉來展示枚舉如何將其數據組織起來。再來，我們會來探討一個特定的實用枚舉：<code>Option</code>，其代表該值爲某些東西不然就是什麼都沒有。然後我們會看看 <code>match</code> 表達式的模式配對是怎麼運作的，讓它能夠針對枚舉中不同數值執行不同的程式碼。最後，我們會介紹 <code>if let</code> 如何組織你的程式碼，這是另一個讓你處理枚舉的方法，而且簡潔又方便。</p>
<p>枚舉是許多語言中都有提供的功能，不過它們能做的事在不同語言而異。Rust 的枚舉最接近於函式語言的<em>代數型別（algebraic data types）</em>，像是 F#、OCaml 與 Haskell。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/5c71aac64380f74f34cd9a158cc2b1d9122b5ceb/src/ch06-00-enums.md">5c71aac</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#定義枚舉" id="定義枚舉">定義枚舉</a></h2>
<p>讓我們看一個程式碼表達的例子，來看看爲何此時用枚舉會比結構體更恰當且實用。假設我們要使用 IP 位址，而且現在有兩個主要的標準能使用 IP 位址：IPv4 與 IPv6。這些事我們的程式碼可能會遇到的 IP 位址，我們可以*枚舉（enumerate）*出所有可能的變體，這正是枚舉的由來。</p>
<p>任何 IP 位址可以是第四版或第六版，但不是同時存在。IP 位址這樣的特性非常適合使用枚舉資料結構，因爲枚舉的值只能是其中一個變體。第四版與第六版同時都屬於 IP 位址，所以當有程式碼要處理任何類型的 IP 位址時，它們都應該被視爲相同型別。</p>
<p>要表達這樣的概念，我們可以定義 <code>IpAddrKind</code> 枚舉和列出 IP 位址可能的類型 <code>V4</code> 和 <code>V6</code>。這些稱爲枚舉的變體（variants）：</p>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> 現在成了能在我們程式碼任何地方使用的自訂資料型別。</p>
<h3><a class="header" href="#枚舉數值" id="枚舉數值">枚舉數值</a></h3>
<p>我們可以像這樣建立兩個不同變體的 <code>IpAddrKind</code> 實例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>注意變體會爲於枚舉命名空間底下，所以我們用兩個冒號來標示。這樣的好處在於 <code>IpAddrKind::V4</code> 和 <code>IpAddrKind::V6</code> 都是同型別 <code>IpAddrKind</code>。比方說，我們就可以定義一個接收任 <code>IpAddrKind</code> 的函式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>然後我們可以用任意變體呼叫此函式：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>使用枚舉還有更多好處。我們再進一步想一下我們的 IP 位址型態還沒有辦法儲存實際的 IP 位址<em>資料</em>，我們現在只知道它是哪種<em>類型</em>。考慮到你已經學會第五章的結構體，你應該會像範例 6-1 這樣解決問題。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from(&quot;127.0.0.1&quot;),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from(&quot;::1&quot;),
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 6-1：使用 <code>struct</code> 儲存 IP 位址的資料與 <code>IpAddrKind</code> 的變體</span></p>
<p>我們在這裡定義了一個有兩個欄位的結構體 <code>IpAddr</code>：欄位 <code>kind</code> 擁有 <code>IpAddrKind</code>（我們上面定義過的枚舉）型別，<code>address</code> 欄位則是 <code>String</code> 型別。再來我們有兩個此結構體的實例。第一個 <code>home</code> 擁有 <code>IpAddrKind::V4</code> 作爲 <code>kind</code> 的值，然後位址資料是 <code>127.0.0.1</code>。第二個實例 <code>loopback</code> 擁有 <code>IpAddrKind</code> 另一個變體 <code>V6</code> 作爲 <code>kind</code> 的值，且有 <code>::1</code> 作爲位址資料。我們用結構體來組織 <code>kind</code> 和 <code>address</code> 的值在一起，讓變體可以與數值相關。</p>
<p>我們可以用另一種更簡潔的方式來定義枚舉就好，而不必使用結構體加上枚舉。枚舉內的每個變體其實都能擁有數值。以下這樣新的定義方式讓 <code>IpAddr</code> 的 <code>V4</code> 與 <code>V6</code> 都能擁有與其相關的 <code>String</code> 數值：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>我們將資料直接附加到枚舉的每個變體上，這樣就不再用結構體。</p>
<p>改使用枚舉而非結構體的話還有另一項好處：每個變體可以擁有不同型別與資料的數量。第四版的 IP 位址永遠只會有四個 0 到 255 的數字部分，如果我們想要讓 <code>V4</code> 儲存四個 <code>u8</code>，但 <code>V6</code> 位址仍保持 String` 不變的話，我們在結構體是無法做到的。枚舉可以輕鬆勝任：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>我們展示了許多種定義儲存第四版與第六版 IP 位址資料結構的方式，不過需要儲存 IP 位址並編碼成不同類型的案例實在太常見了，所以<a href="../std/net/enum.IpAddr.html">標準函式庫已經幫我們定義好了！</a><!-- ignore -->讓我們看看標準函式庫是怎麼定義 <code>IpAddr</code> 的：它有和我們一模一樣的枚舉變體，不過變體各自儲存的資料是另外兩個不同的結構體，兩個定義的內容均不相同：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼展示了你可以將任何資料類型放入枚舉的變體中：字串、數字型別、結構體都可以。你甚至可以再包含另一個枚舉！另外標準函式庫內的型別常常沒有你想得那麼複雜。</p>
<p>請注意雖然標準函式庫已經有定義 <code>IpAddr</code>，但我們還是可以使用並建立我們自己定義的型別，而且不會產生衝突，因爲我們還沒有將標準函式庫的定義匯入到我們的作用域中。我們會在第七章討論如何將型別匯入作用域內。</p>
<p>讓我們再看看範例 6-2 的另一個枚舉範例，這次的變體有各式各樣的型別。</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 6-2：<code>Message</code> 枚舉的變體各自擁有不同的型別與數值數量</span></p>
<p>此枚舉有四個不同型別的變體：</p>
<ul>
<li><code>Quit</code> 沒有包含任何資料。</li>
<li><code>Move</code> 包含了一個匿名結構體</li>
<li><code>Write</code> 包含了一個 <code>String</code>。</li>
<li><code>ChangeColor</code> 包含了三個 <code>i32</code>。</li>
</ul>
<p>如同範例 6-2 這樣定義枚舉變體和定義不同類型的結構體很像，只不過枚舉不使用 <code>struct</code> 關鍵字，而且所有的變體都會在 <code>Message</code> 型別底下。以下的結構體可以包含與上方枚舉變體定義過的資料：</p>
<pre><pre class="playground"><code class="language-rust">struct QuitMessage; // 類單位結構體
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // 元組結構體
struct ChangeColorMessage(i32, i32, i32); // 元組結構體
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>但是如果我們使用不同結構體且各自都有自己的型別的話，我們就無法像範例 6-2 那樣將 <code>Message</code> 視爲單一型別，輕鬆在定義函式時接收訊息所有可能的類型。</p>
<p>枚舉和結構體還有一個地方很像：如同我們可以對結構體使用 <code>impl</code> 定義方法，我們也可以對枚舉定義方法。以下範例顯示我們可以對 <code>Message</code> 枚舉定義一個 <code>call</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // 在此定義方法本體
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
<span class="boring">}
</span></code></pre></pre>
<p>方法本體使用 <code>self</code> 來取得我們呼叫方法的值。在此例中M，我們建立了一個變數 <code>m</code> 並取得 <code>Message::Write(String::from(&quot;hello&quot;))</code>，而這就會是當我們執行 <code>m.call()</code> 時 <code>call</code> 方法內會用到的 <code>self</code>。</p>
<p>讓我們再看看另一個標準函式庫內非常常見且實用的枚舉：<code>Option</code>。</p>
<h3><a class="header" href="#option-枚舉相對於空值的優勢" id="option-枚舉相對於空值的優勢"><code>Option</code> 枚舉相對於空值的優勢</a></h3>
<p>在之前的段落，我們看到了如何使用 <code>IpAddr</code> 枚舉，來讓我們利用 Rust 的型別系統來爲我們程式中的資料附加更多資訊。在此段落我們將來研究 <code>Option</code>，這是在標準函式庫中定義的另一種枚舉。<code>Option</code> 廣泛運用在許多場合，它能表示一個數值可能有某個東西，或者什麼都沒有。在型別系統中表達這樣的概念可以讓編譯器檢查我們是否都處理完我們該處理的情況了。這樣的功能可以防止其他程式語言中非常常見的程式錯誤。</p>
<p>程式語言設計通常要考慮哪些功能是你要得，但同時哪些功能是你不要的也很重要。Rust 沒有像其他許多語言都有空值。*空值（Null）*代表的是沒有任何數值。在有空值的語言，所有變數都有兩種可能：空值或非空值。</p>
<p>而其發明者 Tony Hoare 在他 2009 的演講「空引用：造成數十億損失的錯誤」（“Null References: The Billion Dollar Mistake”）中提到：</p>
<blockquote>
<p>我稱它爲我數十億美元的錯誤。當時我正在爲一門物件導向語言設計第一個全方位的引用型別系統。我當時的目標是透過編譯器自動檢查來確保所有的引用都是安全的。但我無法抗拒去加入空引用的誘惑，因爲實作的方式實在太簡單了。這導致了無數的錯誤、漏洞與系統崩潰，在接下來的四十年中造成了大概十億美金的痛苦與傷害。</p>
</blockquote>
<p>空值的問題在於，如果你想在非空值使用空值的話，你會得到某種錯誤。由於空值與非空值的特性無所不再，你會很容易犯下這類型的錯誤。</p>
<p>但有時後能夠表達「空（null）」的概念還是很有用的：空值代表目前的數值因爲某些原因而無效或缺少。</p>
<p>所以問題不在於概念本身，而在於如何實作。所以 Rust 並沒有空值，但是它有一個枚舉可以表達出這樣的概念，也就是一個值可能是存在或不存在的。此枚舉就是 <code>Option&lt;T&gt;</code>，它是在<a href="../std/option/enum.Option.html">標準函式庫中這樣定義的</a><!-- ignore -->：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> 實在太實用了，所以它早已加進 prelude 中，你不需要特地匯入作用域中。除此之外，它的變體也是如此，你可以直接使用 <code>Some</code> 和 <code>None</code> 而不必加上 <code>Option::</code> 的前綴。<code>Option&lt;T&gt;</code> 仍然就只是個枚舉，
<code>Some(T)</code> 與 <code>None</code> 仍然是<code>Option&lt;T&gt;</code> 型別的變體。</p>
<p><code>&lt;T&gt;</code> 語法是我們還沒介紹到的 Rust 功能。它是個泛型型別參數，我們會在第十章正式介紹泛型（generics）。現在你只需要知道 <code>&lt;T&gt;</code> 指的是 <code>Option</code> 枚舉中的 <code>Some</code> 變體可以是任意型別。以下是使用 <code>Option</code> 來包含數字與字串型別的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_string = Some(&quot;a string&quot;);

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>如果我們是用 <code>None</code> 而非 <code>Some</code> 的話，我們就需要告訴 Rust <code>Option&lt;T&gt;</code> 的確切型別，因爲編譯器無法從 <code>None</code> 值推斷出 <code>Some</code> 變體該擁有何種型別。</p>
<p>當我們有 <code>Some</code> 值時，我們會知道數值是存在的而且就位於 <code>Some</code> 內。當我們有 <code>None</code> 值時，在某種意義上它代表該值是空的，我們沒有有效的數值。所以爲何 <code>Option&lt;T&gt;</code> 會比用空值來得好呢？</p>
<p>簡單來說因爲 <code>Option&lt;T&gt;</code> 與 <code>T</code>（<code>T</code> 可以是任意型別）是不同的型別，編譯器不會允許我們像一般有效的值那樣來使用 <code>Option&lt;T&gt;</code>。舉例來說，以下範例是無法編譯的，因爲這場是將 <code>i8</code> 與 <code>Option&lt;i8&gt;</code> 相加：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}
</span></code></pre>
<p>如果我們執行此程式，我們會得到以下錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
  = help: the trait `std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<p>這樣其實很好！此錯誤訊息事實上指的是 Rust 不知道如何將 <code>i8</code> 與 <code>Option&lt;i8&gt;</code> 相加，因爲它們是不同的型別。當我們在 Rust 中有個型別像是 <code>i8</code>，編譯器將會確保我們永遠會擁有有效數值。我們可以很放新的使用該值，而不必檢查是不是空的。我們只有在使用 <code>Option&lt;i8&gt;</code> （或者任何其他要使用的型別）時才需要去擔心會不會沒有值。然後編譯器會確保我們在使用該值前，有處理過該有的條件。</p>
<p>換句話說，你必須將 <code>Option&lt;T&gt;</code> 轉換爲 <code>T</code> 你才能對 <code>T</code> 做運算。 這通常就能幫助我們抓到空值最常見的問題：認爲某值不爲空，但它其實就是空值。</p>
<p>不用再擔心一個非空值是不是不正確的，可以讓你對你寫的程式碼更有信心。要讓一個值變成可能爲空的話，你必須顯式建立成對應型別的 <code>Option&lt;T&gt;</code>。然後當你要使用該值時，你就得顯式處理數值是否爲空的條件。只要一個數值的型別不是 <code>Option&lt;T&gt;</code>，你就<em>可以</em>安全地認定該值不爲空。這是 Rust 刻意考慮的設計決定，限制無所不再的空值，並增強 Rust 程式碼的安全性。</p>
<p>所以當我們有一個數值型別 <code>Option&lt;T&gt;</code>，我們要怎麼從 <code>Some</code> 變體取出 <code>T</code>，好讓我們可以使用該值呢？<code>Option&lt;T&gt;</code> 枚舉有大量實用的方法可以在不同的場合下使用。你可以在<a href="../std/option/enum.Option.html">它的技術文件</a><!-- ignore -->查閱。更加熟悉 <code>Option&lt;T&gt;</code> 的方法十分益於你接下來的 Rust 旅程。</p>
<p>總之來說，要使用 <code>Option&lt;T&gt;</code> 數值的話，你要讓程式碼可以處理每個變體。你會希望有一些程式碼只會在當我們有 <code>Some(T)</code> 時執行，然後這些程式碼允許使用內部的 <code>T</code>。你會希望有另一部分的程式碼能在只有 <code>None</code> 時執行，且這些程式碼不會拿到有效的 <code>T</code> 數值。<code>match</code> 表達式正是處理此枚舉行爲的控制流結構：它會針對不同的枚舉變體執行不同的程式碼，而且程式碼可以使用配對到的數值資料。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch06-01-defining-an-enum.md">d44317c</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#match-控制流運算子" id="match-控制流運算子"><code>match</code> 控制流運算子</a></h2>
<p>Rust 有個功能非常強大的控制流運算子叫做 <code>match</code>，你可以使用一系列模式來配對數值並依據配對到的模式來執行對應的程式。模式（Patterns）可以是字面數值、變數名稱、通配符（wildcards）和其他更多元件來組成。第十八章會涵蓋所有不同類型的模式，以及它們的用途。<code>match</code> 強大的地方在於模式表達的清楚程度以及編譯器會確保所有可能的情況都處理了。</p>
<p>你可以想像 <code>match</code> 表達式成一個硬幣分類機器：硬幣會滑到不同大小的軌道，然後每個硬幣會滑入第一個符合大小的軌道。同樣地，數值會依序遍歷 <code>match</code> 的每個模式，然後進入第一個「配對」到該數值的模式所在的程式碼區塊，並在執行過程中使用。</p>
<p>既然我們都提到硬幣了，就讓我們用它們來作爲 <code>match</code> 的範例吧！我們可以寫一個接收未知美國硬幣的函式，以類似驗鈔機的方式，決定它是何種硬幣並以美分作爲單位回傳其值。如範例 6-3 所示。</p>
<pre><pre class="playground"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 6-3：枚舉以及用枚舉變體作爲模式的 <code>match</code> 表達式</span></p>
<p>讓我們一一介紹 <code>value_in_cents</code> 函式中 <code>match</code> 的每個部分。首先我們使用 <code>match</code> 並加上一個表達式，在此例的話就是指 <code>coin</code>。這和 <code>if</code> 中表達式的用法很像。不過差別在於 <code>if</code> 中的表達式必須回傳布林值，而在此它可以是任何型別。在此範例中 <code>coin</code> 的型別是我們在第一行定義的枚舉 <code>Coin</code>。</p>
<p>接下來是 <code>match</code> 的分支，每個分支有兩個部分：一個模式以及對應的程式碼。這邊第一個分支的模式是 <code>Coin::Penny</code> 然後 <code>=&gt;</code> 會將模式與要執行的程式碼分開來，而在此例的程式碼就只是個 <code>1</code>。每個分支之間由逗號區隔開來。</p>
<p>當 <code>match</code> 表達式執行時，他會將計算的數據結果依序與每個分支的模式做比較。如果有模式配對到該值的話，其對應的程式碼就會執行。如果該模式與數值不符的話，就繼續執行下一個分支，就像硬幣分類機器。</p>
<p>每個分支對應的程式碼都是表達式，然後在配對到的分支中表達式的數值結果就會是整個 <code>match</code> 表達式的回傳值。</p>
<p>如果配對分支的程式碼很短的話，通常就不需要用到的大括號，像是範例 6-3 每個分支就只回傳一個數值。如果你想要在配對分支執行多行程式碼的話，你就可以用大括號。舉例來說，以下程式會在每次配對到 <code>Coin::Penny</code> 時印出「Lucky penny!」再回傳程式碼區塊最後的數值 <code>1</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3><a class="header" href="#綁定數值的模式" id="綁定數值的模式">綁定數值的模式</a></h3>
<p>另一項配對分支的實用功能是它們可以綁定配對模式中部分的數值，這讓我們可以取出枚舉變體中的數值。</p>
<p>舉例來說，讓我們改變我們其中一個枚舉變體成擁有資料。從 1999 年到 2008 年，美國在鑄造 25 美分硬幣時，其中一側會有 50 個州不同的設計。不過其他的硬幣就沒有這樣的設計，只有 25 美分會有特殊值而已。我們可以改變我們的 <code>enum</code> 中的 <code>Quarter</code> 變體成儲存 <code>UsState</code> 數值，如範例 6-4所示。</p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 6-4：修改 <code>Coin</code> 枚舉的 <code>Quarter</code> 變體來包含一個 <code>UsState</code> 數值</span></p>
<p>讓我們想像我們有一個朋友想要收集所有 50 州的 25 美分硬幣。當我們在排序零錢的同時，我們會在拿到 25 美分時喊出該硬幣對應的州，好讓我們的朋友知道，如果他沒有的話就可以納入收藏。</p>
<p>在此程式中的配對表達式中,我們在 <code>Coin::Quarter</code> 變體的配對模式中新增了一個變數 <code>state</code>。當 <code>Coin::Quarter</code> 配對符合時，變數 <code>state</code> 會綁定該 25 美分的數值，然後我們就可以在分支程式碼中使用 <code>state</code>，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<p>如果我們呼叫 <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> 的話，<code>coin</code> 就會是 <code>Coin::Quarter(UsState::Alaska)</code>。當我們比較每個配對分支時，我們會到 <code>Coin::Quarter(state)</code> 的分支才配對成功。此時 <code>state</code> 綁定的數值就會是 <code>UsState::Alaska</code>。我們就可以在 <code>println!</code> 表達式中使用該幫訂的值，以此取得 <code>Coin</code> 枚舉中 <code>Quarter</code> 變體內的值。</p>
<h3><a class="header" href="#配對-optiont" id="配對-optiont">配對 <code>Option&lt;T&gt;</code></a></h3>
<p>在上一個段落，我們想要在使用 <code>Option&lt;T&gt;</code> 時取得 <code>Some</code> 內部的 <code>T</code> 值。如同枚舉 <code>Coin</code>，我們一樣可以使用 <code>match</code> 來處理 <code>Option&lt;T&gt;</code>！ 相對於比較硬幣，我們要比較的是 <code>Option&lt;T&gt;</code> 的變體，不過 <code>match</code> 表達式運作的方式一模一樣。</p>
<p>假設我們要寫個接受 <code>Option&lt;i32&gt;</code> 的函式，而且如果內部有值的話就將其加上 1。如果內部沒有數值的話，該函式就回傳 <code>None</code> 且不再嘗試做任何動作。</p>
<p>拜 <code>match</code> 所賜，這樣的函式很容易寫出來，長得就像範例 6-5。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 6-5：對 <code>Option&lt;i32&gt;</code> 使用 <code>match</code> 表達式的函式</span></p>
<p>讓我們來仔細分析 <code>plus_one</code> 第一次的執行結果。當我們呼叫 <code>plus_one(five)</code>時，<code>plus_one</code> 本體中的變數 <code>x</code> 會擁有 <code>Some(5)</code>。我們接著就拿去和每個配對分支比較。</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p><code>Some(5)</code> 並不符合 <code>None</code> 這樣的模式，所以我們繼續進行下一個分支。</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span><span class="boring">            None =&gt; None,
</span>            Some(i) =&gt; Some(i + 1),
<span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p><code>Some(5)</code> 有符合 <code>Some(i)</code> 這樣的模式嗎？這是當然的囉！我們有相同的變體。<code>i</code> 會綁定 <code>Some</code> 中的值，所以 <code>i</code> 會取得 <code>5</code>。接下來配對分支中的程式碼就會執行，我們將 1 加入 <code>i</code> 並產生新的 <code>Some</code> 其內部的值就會是 <code>6</code>。</p>
<p>現在讓我們看看範例 6-5 第二次的 <code>plus_one</code> 呼叫，這次的 <code>x</code> 是 <code>None</code>。我們進入 <code>match</code> 然後比較第一個分支。</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span><span class="boring">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
</span><span class="boring">        match x {
</span>            None =&gt; None,
<span class="boring">            Some(i) =&gt; Some(i + 1),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>配對成功！因爲沒有任何數值可以相加，程式就停止並在 <code>=&gt;</code> 之後馬上回傳 <code>None</code>。因爲第一個分支就配對成功了，沒有其他的分支需要在做比較。</p>
<p>用 <code>match</code> 與枚舉組合起來在很多地方都很實用。你將會在許多 Rust 程式碼看到這樣的模式，使用 <code>match</code> 配對枚舉，綁定內部的資料，然後執行對應的程式碼。一開始使用的確會有點陌生，但當你熟悉以後，你會希望所有語言都能提供這樣的功能。這一直是使用者最愛的功能之一。</p>
<h3><a class="header" href="#配對必須是徹底的" id="配對必須是徹底的">配對必須是徹底的</a></h3>
<p>我們還有一個 <code>match</code> 的細節要討論，今天要是我們像這樣寫了一個有錯誤的 <code>plus_one</code> 函式版本，它會無法編譯：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }
<span class="boring">
</span><span class="boring">    let five = Some(5);
</span><span class="boring">    let six = plus_one(five);
</span><span class="boring">    let none = plus_one(None);
</span><span class="boring">}
</span></code></pre>
<p>我們沒有處理到 <code>None</code> 的情形，所以此程式碼會產生錯誤。幸運的是這是 Rust 能夠抓到的錯誤。如果我們嘗試編譯此程式的話，我們會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust 發現我們沒有考慮到所有可能條件，而且還知道我們少了哪些模式！Rust 中的配對必須是*徹底（exhaustive）*的：我們必須列舉出所有可能的情形，程式碼才能夠被視爲有效。尤其是在 <code>Option&lt;T&gt;</code> 的情況下，當 Rust 防止我們忘記處理 <code>None</code> 的情形時，它也使我們免於以爲擁有一個有效實際上卻是空的值。因此要造成之前提過的數十億元錯誤在這邊基本上是不可能的。</p>
<h3><a class="header" href="#_-佔位符" id="_-佔位符"><code>_</code> 佔位符</a></h3>
<p>Rust 還有一個模式可以讓我們不必列出所有可能的數值，只需要使用此模式就好。舉例來說 <code>u8</code> 可能的數值爲 0 到 255，如果我們只在意數值 1、3、5 和 7，我們就不會想要列出 0、2、4、6、8、9 還剩下一直到 255 的每個值。幸運的是，我們不需要這樣做，我們可以使用特殊模式 <code>_</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_u8_value = 0u8;
    match some_u8_value {
        1 =&gt; println!(&quot;one&quot;),
        3 =&gt; println!(&quot;three&quot;),
        5 =&gt; println!(&quot;five&quot;),
        7 =&gt; println!(&quot;seven&quot;),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>_</code> 模式會配對任意數值，將它置於所有分支之後，<code>_</code>就會配對剩下尚未指明的可能情形。<code>()</code> 只是一個單位數值，所以在 <code>_</code> 的分支沒有任何事情會發生。所以我們可以說我們不想針對 <code>_</code> 佔位符之前沒有列出的可能情形，做任何動作。</p>
<p>不過有時候我們只在意其中<em>一種</em>情形的話， <code>match</code> 表達式的確會有點囉唆。針對此情形，Rust 提供 <code>if let</code>。</p>
<p>而更多有關配對模式的內容可以在<a href="ch18-00-patterns.html">第十八章</a>查閱。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/41d9f4c9ae6ba07191f55338e864c713cd49a876/src/ch06-01-defining-an-enum.md">41d9f4c</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過-if-let-簡化控制流" id="透過-if-let-簡化控制流">透過 <code>if let</code> 簡化控制流</a></h2>
<p><code>if let</code> 語法讓你可以用 <code>if</code> 與 <code>let</code> 的組合來以比較不冗長的方式，來處理只在乎其中一種模式而忽略其餘的數值。現在考慮一支程式如範例 6-6 所示，我們配對 <code>Option&lt;u8&gt;</code> 的值，但只想在數值爲 3 時執行程式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let some_u8_value = Some(0u8);
    match some_u8_value {
        Some(3) =&gt; println!(&quot;three&quot;),
        _ =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 6-6：<code>match</code> 只在數值爲 <code>Some(3)</code> 時執行程式</span></p>
<p>我們想在 <code>Some(3)</code> 配對到時做些事情，但不想管其他 <code>Some&lt;u8&gt;</code> 的值或是 <code>None</code>。爲了滿足 <code>match</code> 表達式，我們必須在只處理一種變體的分支後面，再加上 <code>_ =&gt; ()</code>。這樣就加了不少樣板程式碼。</p>
<p>不過我們可以使用 <code>if let</code> 以更精簡的方式寫出來，以下程式碼的行爲就與範例 6-6 的 <code>match</code> 一樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_u8_value = Some(0u8);
</span>    if let Some(3) = some_u8_value {
        println!(&quot;three&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> 接收一個模式與一個表達式，然後用等號區隔開來。它與 <code>match</code> 的運作方式相同，表達式的意義與 <code>match</code> 相同，然後前面的模式就是第一個分支。</p>
<p>使用 <code>if let</code> 可以少打些字、減少縮排以及不用寫多餘的樣板程式碼。不過你就少了 <code>match</code> 強制的徹底窮舉檢查。要何時選擇 <code>match</code> 還是 <code>if let</code> 得依據你在的場合是要做什麼事情，以及在精簡度與徹底檢查之間做取捨。</p>
<p>換句話說，你可以想像 <code>if let</code> 是 <code>match</code> 的語法糖，它只會配對一種模式來執行程式碼並忽略其他數值。</p>
<p>我們也可以在 <code>if let</code> 之後加上 <code>else</code>，<code>else</code> 之後的程式碼區塊等同於 <code>match</code> 表達式中 <code>_</code> 情形的程式碼區塊。這樣一來的 <code>if let</code> 和 <code>else</code> 組合就等同於 <code>match</code> 了。回想一下範例 6-4 的 <code>Coin</code> 枚舉定義， <code>Quarter</code> 變體擁有數值 <code>UsState</code>。如果我們希望統計所有不是 25 美分的硬幣的同時，也能繼續回報 25 美分所屬的州的話，我們可以用 <code>match</code> 像這樣寫：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<p>或是我們也可以用 <code>if let</code> 和 <code>else</code> 表達式這樣寫：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --snip--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<p>如果你的程式碼邏輯遇到使用 <code>match</code> 表達會太囉唆的話，記得 <code>if let</code> 也在你的 Rust 工具箱中可以使用。</p>
<h2><a class="header" href="#總結-4" id="總結-4">總結</a></h2>
<p>我們現在含蓋了如何使用枚舉來建立一系列枚舉數值的自訂型別。我們展示了邊準函式庫的 <code>Option&lt;T&gt;</code> 型別如何用型別系統來預防錯誤。當枚舉數值其內有資料時，你可以依照你想處理的情況數量，使用 <code>match</code> 或 <code>if let</code> 來取出並使用那些數值。</p>
<p>你的 Rust 程式碼現在能夠使用結構體與枚舉來表達你所知領域的概念了。在你的 API 建立自訂型別可以確保型別安全，編譯器會保證你的函式只會取得該函式預期的型別數值。</p>
<p>接下來爲了提供組織完善且直觀的的 API 供你的使用者使用，並只表達出使用者確切所需要的內容，我們需要瞭解 Rust 的模組。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/41d9f4c9ae6ba07191f55338e864c713cd49a876/src/ch06-03-if-let.md">41d9f4c</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h1><a class="header" href="#透過套件crate與模組管理成長中的專案" id="透過套件crate與模組管理成長中的專案">透過套件、Crate與模組管理成長中的專案</a></h1>
<p>當你寫的程式規模更大時，組織你的程式碼就很重要。因爲用你的腦帶要記住整個程式碼是幾乎不可能的。要是能組織相關功能的程式碼並將它們分成明確功能的話，你就能清楚地找到實作特定功能的程式碼，以及該在哪裏修改該功能的行爲。</p>
<p>我們之前寫過的程式都只在一個檔案內的一個模組（module）中。隨著專案成長，我們可以組織程式碼，拆成數個模組與數個檔案。一個套件（package）可以包含數個二進制 crate 以及選擇性提供一個函式庫 crate。隨著套件增長，你可以取出不同的部分作爲獨立的 crate，成爲對外的依賴函式庫。此章節將會介紹這些所有概念。對於非常龐大的專案，需要一系列的關聯套件組合在一起的話，Cargo 有提供工作空間（workspaces），我們會在第十四章的<a href="ch14-03-cargo-workspaces.html">「Cargo 工作空間」</a><!-- ignore -->做介紹。</p>
<p>除了爲了組織功能以外，對實作細節進行封裝可以讓你的程式碼在頂層更好使用。一旦你實作了某項功能，其他程式就可以用程式碼的公開介面呼叫該程式碼，而不必去知道它實作如何運作。你在寫程式碼時會去定義哪些部分是給其他程式碼公開使用的，以及哪些部分是私底下你可以任意修改的實作細節。這是能再減少你的腦袋需要煩惱的細節數量。</p>
<p>還有一個概念需要再提一次，也就是作用域（scope）：程式碼需要能被定義在「作用域內」並要能夠指明此作用域。當讀取寫入或編譯程式碼時，程式設計師與編譯器需要知道特定地點的名稱，才能知道其內的變數、函式、結構體、枚舉、常數或其他任何有意義的項目。你可以建立作用域，並改變其在作用域內與作用域外的名稱。你無法在同個作用域內擁有兩個相同名稱的項目。我們可以使用一些工具來解決名稱衝突的問題。</p>
<p>Rust 有一系列的功能能讓你管理你的程式碼組織，包含哪些細節能對外提供、哪些細節是私有地，以及程式中每個作用域的名稱爲何。這些功能有時會統一稱作<em>模組系統「module system」</em>，其中包含：</p>
<ul>
<li>**套件（Package）：**讓你建構、測試並分享 crate 的 Cargo 功能</li>
<li>**Crates：**產生函式庫或執行檔的模組集合</li>
<li><strong>模組（Modules）</strong> 與 **use：**讓你控制組織、作用域與路徑的隱私權</li>
<li>**路徑（Paths）:**對一個項目的命名方式，像是一個結構體、函式或模組</li>
</ul>
<p>在本章節中，我們會涵蓋所有這些功能，討論它們如何互動，並解釋如何使用它們來管理作用域。在讀完後，你應該就會對模組系統有紮實的認知，並能夠對作用域的使用駕輕就熟！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/41d9f4c9ae6ba07191f55338e864c713cd49a876/src/ch06-03-if-let.md">41d9f4c</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#套件與-crates" id="套件與-crates">套件與 Crates</a></h2>
<p>首先我們要介紹的第一個模組系統部分爲套件與 crates。一個 crate 指的是一個二進制執行檔或函式庫。<em>crate 的源頭</em>會是一個原始檔案，讓 Rust 的編譯器可以作爲起始點並組織 crate 模組的地方（我們會在<a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">「定義模組來控制作用域與隱私權」</a><!-- ignore -->的段落更加解釋模組）。*套件（package）*則是提供一系列功能的一或數個 crate。一個套件會包含一個 <em>Cargo.toml</em> 檔案來解釋如何建構那些 crate。</p>
<p>套件依據一些規則來組成。一個套件<em>必須</em>包含零或一個函式庫 crate，不能再更多。它可以包含多少二進制執行檔 crate 都沒關係，但一定得至少提供一個 crate（無論是函式庫或二進制執行檔）。</p>
<p>讓我們看看當我們建立一個套件時發生了什麼事。首先我們先輸入 <code>cargo new</code> 命令：</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>當我們輸入命令時，Cargo 會建立一個 <em>Cargo.toml</em> 檔案並以此作爲套件依據。查看 <em>Cargo.toml</em> 的內容時，你會發現沒有提到 <em>src/main.rs</em>，這是因爲 Cargo 遵循一個常規，也就是 <em>src/main.rs</em> 就是與套件同名的
二進制 crate 的 crate 源頭。同樣地，Cargo 也會知道如果套件目錄包含 <em>src/lib.rs</em>的話，則該套件就會包含與套件同名的 函式庫 crate。Cargo 會將 crate 源頭檔案傳遞給 <code>rustc</code> 來建構函式庫或二進制執行檔</p>
<p>我們在此的套件只有包含 <em>src/main.rs</em> 代表它只有一個同名的二進制 crate 叫做 <code>my-project</code>。如果套件包含 <em>src/main.rs</em> 與 <em>src/lib.rs</em> 的話，它就有兩個 crate：一個函式庫與一個二進制執行檔，兩者都與套件同名。一個套件可以有多個二進制 crate，只要將檔案放在 <em>src/bin</em> 目錄底下就好，每個檔案會被視爲獨立的二進制 crate。</p>
<p>Crate 會將相關的程式碼組織在一個作用域內，好讓其通能易於分享給其他專案。舉例來說，我們在<a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">第二章</a><!-- ignore -->使用到的 <code>rand</code> crate 就提供了產生隨機數值的功能。我們可以將 <code>rand</code> crate 引入我們的專案，讓我們可以在我們的專案使用這項功能。所有 <code>rand</code> crate 提供的功能都可以透過 crate 的名稱 <code>rand</code> 來索取。</p>
<p>將 crate 的功能維持在各自的作用域內能清楚地表達特定功能是定義在我們自己的 crate 還是 <code>rand</code> crate 的，以防止可能的衝突。舉例來說，<code>rand</code> crate 提供了一個特徵叫做 <code>Rng</code>，我們也可以在我們自己的 crate 中定義一個 <code>struct</code> 叫做 <code>Rng</code>。由於 crate 的功能都位於它所屬的作用域的命名空間底下，當我們加入 <code>rand</code> 作爲依賴時，編譯器不會被搞不清楚是哪個 <code>Rng</code> 被使用。在我們的 crate 中，它指的是我們定義的 <code>struct Rng</code>。而要使用 <code>rand</code> crate 的 <code>Rng</code> 特徵的話，我們得這樣使用 <code>rand::Rng</code>。</p>
<p>接下來讓我們繼續討論模組系統吧！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch07-01-packages-and-crates.md">d44317c</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#定義模組來控制作用域與隱私權" id="定義模組來控制作用域與隱私權">定義模組來控制作用域與隱私權</a></h2>
<p>在此段落，我們將討論模組以及其他模組系統的部分，像是*路徑（paths）*項允許你來命名項目，而 <code>use</code> 關鍵字可以將路徑引入作用域，再來 <code>pub</code> 關鍵字可以讓指定的項目對外公開。我們還會討論到 <code>as</code> 關鍵字、外部套件以及全域（glob）運算子。現在讓我們先專注在模組吧！</p>
<p><em>模組（Modules）<em>讓我們在 crate 內組織程式碼成數個群組以便使用且增加閱讀性。模組也能控制項目的</em>隱私權</em>，也就是該項目能否被外部程式碼（<em>公開（public）</em>）使用，或者只作爲內部實作細節，對外是無法使用的（<em>私有（private）</em>）。</p>
<p>舉例來說，讓我們建立一個提供餐廳功能的函式庫 crate。我們定義一個函式簽名不過本體會是空的，好讓我們專注在程式組織，而非餐廳程式碼的實作。</p>
<p>在餐飲業中，餐廳有些地方會被稱作<em>前端（front of house）<em>而其他部分則是</em>後端（back of house）</em>。前端是消費者的所在區域，這裡是安排顧客座位、點餐並結帳、吧台調酒的地方。而後台則是主廚與廚師工作的廚房、洗碗工洗碗以及經理管理行政工作的地方。</p>
<p>要讓我們的 crate 像真正的餐廳一樣的話，我們可以組織函式進入模組中。要建立一個新的函式庫叫做 <code>restaurant</code> 的話，請執行 <code>cargo new --lib restaurant</code>。然後將範例 7-1 的程式碼放入 <em>src/lib.rs</em> 中，這定義了一些模組與函式簽名。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 7-1：<code>front_of_house</code> 模組包含了其他擁有函式的模組</span></p>
<p>我們用 <code>mod</code> 關鍵字加上模組的名稱（在此例爲 <code>front_of_house</code>）來定義一個模組，並用大括號涵蓋模組的本體。在模組中，我們可以再包含其他模組，在此例中我們包含了 <code>hosting</code> 和 <code>serving</code>。模組還能包含其他項目，像是結構體、枚舉、常數、特徵、或像是 範例 7-1 的函式。</p>
<p>使用模組的話，我們就能加相關的定義組合起來，並用名稱指出會合它們互相關聯。程式設計師在使用此程式碼時就能快找到他們想使用的定義，因爲他們就不必遍歷所有的定義，只要觀察依據組合起來的模組名稱就好。要對此程式碼增加新功能的開發者也能知道該將程式碼放在哪裡，以維持程式碼的組織。</p>
<p>稍早我們提到說 <em>src/main.rs</em> 和 <em>src/lib.rs</em> 屬於 crate 的源頭。之所以這樣命名的原因是因爲這兩個文件的內容都會在 crate 源頭模組架構中組成一個模組叫做 <code>crate</code>，這樣的結構稱之爲<em>模組樹（module tree）</em>。</p>
<p>範例 7-2 顯示了範例 7-1 的模組樹架構。</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">範例 7-2：範例 7-1 的模組樹</span></p>
<p>此樹顯示了有些模組是包含在其他模組內的（比方說 <code>hosting</code> 就在 <code>front_of_house</code> 底下）。此樹也顯示了有些模組是其他模組的<em>同輩（siblings）</em>，代表它們是在同模組底下定義的（<code>hosting</code> 和 <code>serving</code> 都在 <code>front_of_house</code> 底下定義）。繼續沿用家庭來譬喻的話，如果模組 A 被包含在模組 B 中，我們會說模組 A 是模組 B 的<em>下一代（child）</em>，而模組 B 是模組 A 的<em>上一代（parent）</em>。注意到整個模組樹的源頭是一個隱性模組叫做 <code>crate</code>。</p>
<p>模組樹可能會讓你想到電腦中檔案系統的目錄樹，這是一個非常恰當的比喻！就像檔案系統中的目錄，你使用模組來組織你的程式碼。而且就像目錄中的檔案，我們需要有方法可以找到我們的模組。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch07-01-packages-and-crates.md">d44317c</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#引用模組項目的路徑" id="引用模組項目的路徑">引用模組項目的路徑</a></h2>
<p>要展示 Rust 如何從模組樹中找到一個項目，我們要使用和查閱檔案系統時一樣的路徑方法。如果我們想要呼叫函式，我們需要知道它的路徑：</p>
<p>路徑可以有兩種形式：</p>
<ul>
<li>*絕對路徑（absolute path）*是從 crate 的源頭開始找起，用 crate 的名稱或 <code>crate</code> 作爲起頭。</li>
<li>*相對路徑（relative path）*則是從本身的模組開始，使用 <code>self</code>、<code>super</code>或是當前模組的標識符（identifiers）。</li>
</ul>
<p>無論是絕對或相對路徑其後都會接著一或多個標識符，並使用雙冒號（<code>::</code>）區隔開來。</p>
<p>讓我們回頭看看範例 7-1，我們要如何呼叫函式 <code>add_to_waitlist</code> 呢？這就和問函式 <code>add_to_waitlist</code> 在哪的問題是一樣的。在範例 7-3，我們移除了一些模組與函式來精簡程式碼的呈現方式。我們會展示兩種從 crate 源頭定義的 <code>eat_at_restaurant</code> 函式內呼叫 <code>add_to_waitlist</code> 的方法。<code>eat_at_restaurant</code> 函式是我們函式庫 crate 公開 API 的一部分，所以我們會加上 <code>pub</code> 關鍵字。在<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">「使用 <code>pub</code> 關鍵字公開路徑」</a><!-- ignore -->的段落中，我們會提到更多 <code>pub</code> 的細節。請注意此範例還不能編譯，我們等等會解釋原因。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-3：使用絕對與相對路徑呼叫 <code>add_to_waitlist</code> 函式</span></p>
<p>我們在 <code>eat_at_restaurant</code> 中第一次呼叫 <code>add_to_waitlist</code> 函式的方式是用絕對路徑。<code>add_to_waitlist</code> 函式和 <code>eat_at_restaurant</code> 都是在同一個 crate 底下，所以我們可以使用 <code>crate</code> 關鍵字來作爲絕對路徑的開頭。</p>
<p>在 <code>crate</code> 之後, 我們接續加上對應的模組直到抵達 <code>add_to_waitlist</code>。你可以想像一個有相同架構的檔案系統，然後我們指定 <code>/front_of_house/hosting/add_to_waitlist</code> 這樣的路徑來執行 <code>add_to_waitlist</code> 程式。使用 <code>crate</code> 這樣的名稱作爲 crate 源頭的開始，就像在你的 shell 使用 <code>/</code> 作爲檔案系統的根一樣。</p>
<p>而我們第二次在 <code>eat_at_restaurant</code> 呼叫 <code>add_to_waitlist</code> 的方式是使用相對路徑。 路徑的起頭是 <code>front_of_house</code>，因爲它和 <code>eat_at_restaurant</code> 都被定義在模組樹的同一層中。這裡相對應的檔案系統路徑就是 <code>front_of_house/hosting/add_to_waitlist</code>。使用一個名稱作爲開頭通常就是代表相對路徑。</p>
<p>何時該用相對或絕對路徑是你在你的專案中要做的選擇。選擇的依據通常會看你移動程式碼位置時，是會連帶它們一起移動，或是分開移動到不同地方。舉例來說，如果我們同時將 <code>front_of_house</code> 模組和 <code>eat_at_restaurant</code> 函式移入另一個模組叫做 <code>customer_experience</code> 的話，就會需要修改 <code>add_to_waitlist</code> 的絕對路徑，但是相對路徑就可以原封不動。而如果我們只單獨將 <code>eat_at_restaurant</code> 函式移入一個叫做 <code>dining</code> 模組的話，<code>add_to_waitlist</code> 的絕對路徑就不用修改，但相對路徑就需要更新。我們通常會傾向於指定絕對路徑，因爲分別移動程式碼定義與項目呼叫的位置通常是比較常見的。</p>
<p>讓我們嘗試編譯範例 7-3 並看看爲何不能編譯吧！以下範例 7-4 是我們得到的錯誤資訊。</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<p><span class="caption">範例 7-4：範例 7-3 嘗試編譯程式碼出現的錯誤</span></p>
<p>錯誤訊息表示 <code>hosting</code> 模組是私有地。換句話說，我們指定 <code>hosting</code> 模組與 <code>add_to_waitlist</code> 函式的路徑是正確的，但是因爲它沒有私有部分的存取權，所以 Rust 不讓我們使用。</p>
<p>模組不僅用來組織你的程式碼，它們還定義了 Rust 的<em>隱私界限（privacy boundary）</em>：這是條封裝實作細節，讓外部程式碼無法看到、呼叫或依賴的界限。所以你想要建立私有的函式或結構體，你可以將它們放入模組內。</p>
<p>Rust 隱私權的運作方式是預設所有的項目（函式、方法、結構體、枚舉、模組與常數）都是私有的。上層模組的項目無法使用下層模組的私有項目，但下層模組能使用它們上方所有模組的項目。這麼做的原因是因爲下層模組上用了來實現實作細節，而下層模組應該要能夠看到在自己所定義的地方的其他內容。讓我們繼續用餐廳做比喻的話，我們可以想像隱私權規則就像是餐廳的後臺辦公室。對餐廳顧客來說裡面發生什麼事情都是未知的，但是辦公室經理可以知道經營餐廳時的所有事物。</p>
<p>Rust 選擇這樣的模組系統，讓內部實作細節預設都是隱藏起來的。這樣一來，你就能知道內部哪些程式碼需要修改，而不會破壞到外部的程式碼。不過你可以使用 <code>pub</code> 關鍵字來讓下層模組內部的一些程式碼公開給上層模組來使用。</p>
<h3><a class="header" href="#使用-pub-關鍵字公開路徑" id="使用-pub-關鍵字公開路徑">使用 <code>pub</code> 關鍵字公開路徑</a></h3>
<p>讓我們在執行一次範例 7-4 的錯誤，它告訴我們 <code>hosting</code> 模組是私有的。我們希望上層模組中的 <code>eat_at_restaurant</code> 函式可以呼叫下層模組的 <code>add_to_waitlist</code> 函式，所以我們將 <code>hosting</code> 模組加上 <code>pub</code> 關鍵字，如範例 7-5 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-5：宣告 <code>hosting</code> 模組爲 <code>pub</code> 好讓 <code>eat_at_restaurant</code> 可以使用</span></p>
<p>不幸的是範例 7-5 的程式碼仍然回傳了另一個錯誤，如範例 7-6 所示。</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<p><span class="caption">範例 7-6：編譯範例 7-5 時產生的錯誤</span></p>
<p>到底發生了什麼事？在 <code>mod hosting</code> 之前加上 <code>pub</code> 關鍵字確實公開了模組。有了這項修改後，我們的確可以在取得 <code>front_of_house</code> 的後繼續進入 <code>hosting</code>。但是 <code>hosting</code> 的所有<em>內容</em>仍然是私有的。模組中的 <code>pub</code> 關鍵字只會讓該模組公開讓上層模組使用而已。</p>
<p>範例 7-6 的錯誤訊息表示 <code>add_to_waitlist</code> 函式是私有的。隱私權規則如同模組一樣適用於結構體、枚舉、函式與方法。</p>
<p>讓我們在 <code>add_to_waitlist</code> 的函式定義加上 <code>pub</code> 公開它吧，如範例 7-7 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 7-7：將 <code>mod hosting</code> 和 <code>fn add_to_waitlist</code> 都加上 <code>pub</code> 關鍵字，讓我們可以從 <code>eat_at_restaurant</code> 呼叫函式</span></p>
<p>現在程式碼就能成功編譯了！讓我們看看絕對與相對路徑，以及再次檢查爲何 <code>pub</code> 關鍵字是如何遵守隱私權規則，讓我們可以在 <code>add_to_waitlist</code> 取得這些路徑。</p>
<p>在絕對路徑中，我們始於 <code>crate</code>，這是 crate 模組樹的源頭。再來 <code>front_of_house</code> 模組被定義在 crate 源頭中，<code>front_of_house</code> 模組不是公開，但因爲 <code>eat_at_restaurant</code> 函式被定義在與 <code>front_of_house</code> 同一層模組中（也就是 <code>eat_at_restaurant</code> 與 <code>front_of_house</code> 同輩（siblings）），我們可以從 <code>eat_at_restaurant</code> 引用 <code>front_of_house</code>。接下來是有 <code>pub</code> 標記的 <code>hosting</code> 模組，我們可以取得 <code>hosting</code> 的上層模組，所以我們可以取得 <code>hosting</code>。最後 <code>add_to_waitlist</code> 函式也有 <code>pub</code> 標記而我們可以取得它的上層模組，所以整個程式呼叫就能執行了！</p>
<p>而在相對路徑中，基本邏輯與絕對路徑一樣，不過第一步有點不同。我們不是從 crate 源頭開始，路徑是從 <code>front_of_house</code> 開始。<code>front_of_house</code> 與 <code>eat_at_restaurant</code> 被定義在同一層模組中，所以從 <code>eat_at_restaurant</code> 開始定義的相對路徑是有效的。再來因爲 <code>hosting</code> 與 <code>add_to_waitlist</code> 都有 <code>pub</code> 標記，其餘的路徑也都是可以進入的，所以此函式呼叫也是有效的！</p>
<h3><a class="header" href="#使用-super-作爲相對路徑的開頭" id="使用-super-作爲相對路徑的開頭">使用 <code>super</code> 作爲相對路徑的開頭</a></h3>
<p>我們還可以在路徑開頭使用 <code>super</code> 來建構從上層模組出發的相對路徑。這就像在檔案系統中使用 <code>..</code> 作爲路徑開頭一樣。不過爲何我們想要這樣做呢？</p>
<p>請考慮範例 7-8 的程式碼，這模擬了一個主廚修正一個錯誤的訂單，並親自提供給顧客的場景。函式 <code>fix_incorrect_order</code> 呼叫了函式 <code>serve_order</code>，不過這次是使用 <code>super</code> 來指定 <code>serve_order</code> 的路徑：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 7-8：使用 <code>super</code> 作爲呼叫函式路徑的開頭</span></p>
<p><code>fix_incorrect_order</code> 函式在 <code>back_of_house</code> 模組中，所以我們可以使用 <code>super</code> 前往 <code>back_of_house</code> 的上層模組，在此例的話就是源頭 <code>crate</code>。然後在此時我們就能找到 <code>serve_order</code>。成功！我們認定 <code>back_of_house</code> 模組與 <code>serve_order</code> 函式應該會維持這樣相同的關係，在我們要組織 crate 的模組樹時，它們理當一起被移動。因此我們使用 <code>super</code> 讓我們在未來程式碼被移動到不同模組時，我們不用更新太多程式路徑。</p>
<h3><a class="header" href="#公開結構體與枚舉" id="公開結構體與枚舉">公開結構體與枚舉</a></h3>
<p>我們也可以使用 <code>pub</code> 來公開結構體與枚舉，但是我們有些額外細節要考慮到。如果我們在結構體定義之前加上 <code>pub</code> 的話，我們的確能公開結構體，但是結構體內的欄位仍然會是私有的。我們可以視情況決定每個欄位要不要公開。在範例 7-9 我們定義了一個公開的結構體 <code>back_of_house::Breakfast</code> 並公開欄位 <code>toast</code>，不過將欄位 <code>seasonal_fruit</code> 維持是私有的。這次範例模擬的情境是，餐廳顧客可以選擇早餐要點什麼類型的麵包，但是由主廚視庫存與當季食材來決定提供何種水果。餐廳提供的水果種類隨季節變化很快，所以顧客無法選擇或預先知道他們會拿到何種水果。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 7-9：一個有些欄位公開而有些是私有欄位的結構體</span></p>
<p>因爲 <code>back_of_house::Breakfast</code> 結構體中的 <code>toast</code> 欄位是公開的，在 <code>eat_at_restaurant</code> 中我們可以加上句點來對 <code>toast</code> 欄位進行讀寫。注意我們不能在 <code>eat_at_restaurant</code> 使用 <code>seasonal_fruit</code> 欄位，因爲它是私有的。請嘗試解開修改 <code>seasonal_fruit</code> 欄位數值的那行程式註解，看看你會獲得什麼錯誤！</p>
<p>另外因爲 <code>back_of_house::Breakfast</code> 擁有私有欄位，該結構體必須提供一個公開的關聯函式（associated function）才有辦法產生 <code>Breakfast</code> 的實例（我們在此例命名爲 <code>summer</code>）。如果 <code>Breakfast</code> 沒有這樣的函式的話，我們就無法在 <code>eat_at_restaurant</code> 建立 <code>Breakfast</code> 的實例，因爲我們無法在 <code>eat_at_restaurant</code> 設置私有欄位 <code>seasonal_fruit</code> 的數值。</p>
<p>接下來，如果我們公開枚舉的話，那它所有的變體也都會公開。我們只需要在 <code>enum</code> 關鍵字之前加上 <code>pub</code> 就好，如範例 7-10 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 7-10：公開枚舉會讓其所有變體也公開</span></p>
<p>因爲我們公開了 <code>Appetizer</code> 枚舉，我們可以在 <code>eat_at_restaurant</code> 使用 <code>Soup</code> 和 <code>Salad</code>。枚舉的變體沒有全部都公開的話，通常會讓枚舉很不好用。要用 <code>pub</code> 標註所有的枚舉變體都公開的話又很麻煩。所以公開枚舉的話，預設就會公開其變體。相反地，結構體不讓它的欄位全部都公開的話，通常反而比較實用。因此結構體欄位的通用原則是預設爲私有，除非有 <code>pub</code> 標註。</p>
<p>我們會還有一個 <code>pub</code> 的使用情境還沒提到，也就是我們模組系統最後一項功能：<code>use</code> 關鍵字。我們接下來會先解釋 <code>use</code>，再來研究如何組合 <code>pub</code> 和 <code>use</code>。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過-use-關鍵字引入路徑" id="透過-use-關鍵字引入路徑">透過 <code>use</code> 關鍵字引入路徑</a></h2>
<p>我們目前呼叫函式的路徑都很冗長、重複且不方便。舉例來說範例 7-7 我們在考慮要使用絕對或相對路徑來呼叫 <code>add_to_waitlist</code> 函式時，每次想要呼叫 <code>add_to_waitlist</code> 我們都得指明 <code>front_of_house</code> 以及
<code>hosting</code>。幸運的是，我們有簡化過程的辦法。我們可以使用 <code>use</code> 關鍵字將路徑引入作用域，然後就像它們是本地項目一樣來呼叫它們。</p>
<p>在範例 7-11 中，我們引入了 <code>crate::front_of_house::hosting</code> 模組進 <code>eat_at_restaurant</code> 函式的作用域中，所以我們要呼叫函式 <code>add_to_waitlist</code> 的話我們只需要指明 <code>hosting::add_to_waitlist</code>。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 7-11：使用 <code>use</code> 將模組引入</span></p>
<p>使用 <code>use</code> 將路徑引入作用域就像是在檔案系統中產生符號連結一樣（symbolic link）。在 crate 源頭加上 <code>use crate::front_of_house::hosting</code> 後，<code>hosting</code> 在作用域內就是個有效的名稱了。使用 <code>use</code> 的路徑也會檢查隱私權，就像其他路徑一樣。</p>
<p>你也可以使用 <code>use</code> 加上相對路徑來引入項目。範例 7-12 就展示了如何指明相對路徑來達到與範例 7-11 一樣的結果。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 7-12：使用 <code>use</code> 與相對路徑將項目引入作用域</span></p>
<h3><a class="header" href="#建立慣用的-use-路徑" id="建立慣用的-use-路徑">建立慣用的 <code>use</code> 路徑</a></h3>
<p>在範例 7-11 你可能會好奇爲何我們指明 <code>use crate::front_of_house::hosting</code> 然後在 <code>eat_at_restaurant</code> 呼叫，而不是直接用 <code>use</code> 指明 <code>add_to_waitlist</code> 函式的整個路徑就好。像範例 7-13 這樣寫。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 7-13：使用 <code>use</code> 將 <code>add_to_waitlist</code> 函式引入作用域，但這較不符合習慣</span></p>
<p>雖然範例 7-11 與範例 7-13 都能完成相同的任務，但是範例 7-11 使用 <code>use</code> 講函式引入作用域的方法比較符合習慣用法。使用 <code>use</code> 將函式的上層模組引入作用域，讓我們必須在呼叫函式時得指明對應模組。這樣清楚知道該函式並非本地定義的，同時一樣能簡化路徑。範例 7-13 的程式碼會不清楚 <code>add_to_waitlist</code> 是在哪定義的。</p>
<p>另一方面，如果是要使用 <code>use</code> 引入結構體、枚舉或其他項目的話，直接指明完整路徑反而是符合習慣的方式。範例 7-14 顯示了將標準函式庫的 <code>HashMap</code> 引入二進制 crate 作用域的習慣用法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">範例 7-14：引入 <code>HashMap</code> 進作用域的習慣用法</span></p>
<p>此習慣沒什麼強硬的理由：就只是大家已經習慣這樣的用法來讀寫 Rust 的程式碼。</p>
<p>這樣的習慣有個例外，那就是如果我們將兩個相同名稱的項目使用 <code>use</code> 陳述式引入作用域時，因爲 Rust 不會允許。範例 7-15 展示了如何引入兩個同名但屬於不同模組的 <code>Result</code> 型別進作用域中並使用的方法。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 7-15：要將兩個同名的型別引入相同作用域的話，必須使用它們所屬的模組</span></p>
<p>如同你所見使用對應的模組可以分辨出是再使用哪個 <code>Result</code> 型別。如果我們直接指明 <code>use std::fmt::Result</code> 和 <code>use std::io::Result</code> 的話，我們會在同一個作用域中擁有兩個 <code>Result</code> 型別，這樣一來 Rust 就無法知道我們想用的 <code>Result</code> 是哪一個。</p>
<h3><a class="header" href="#使用-as-關鍵字提供新名稱" id="使用-as-關鍵字提供新名稱">使用 <code>as</code> 關鍵字提供新名稱</a></h3>
<p>要在相同作用域中使用 <code>use</code> 引入兩個同名型別的話，還有另一個辦法。在路徑之後，我們可以用 <code>as</code> 指定一個該型別在本地的新名稱，或者說別名。範例 7-16 展示重寫了範例 7-15，將其中一個 <code>Result</code> 型別使用 <code>as</code> 重新命名。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 7-16：使用 <code>as</code> 將型別引入作用域的同時重新命名</span></p>
<p>在第二個 <code>use</code> 陳述式，我們選擇了將 <code>std::io::Result</code> 型別重新命名爲 <code>IoResult</code>，這樣就不會和同樣引入作用域內 <code>std::fmt</code> 的 <code>Result</code> 有所衝突。範例 7-15 與 範例 7-16 都屬於習慣用法，你可以選擇你比較喜歡的方式！</p>
<h3><a class="header" href="#使用-pub-use-重新匯出名稱" id="使用-pub-use-重新匯出名稱">使用 <code>pub use</code> 重新匯出名稱</a></h3>
<p>當我們使用 <code>use</code> 關鍵字將名稱引入作用域時，該有效名稱在新的作用域中是私有的。要是我們希望呼叫我們這段程式碼時，也可以使用這個名稱的話（就像該名稱是在此作用域內定義的），我們可以組合 <code>pub</code> 和 <code>use</code>。這樣的技巧稱之爲 <em>重新匯出（re-exporting）</em>，因爲我們將項目引入作用域，並同時公開給其他作用域引用。</p>
<p>範例 7-17 顯示將範例 7-11 在源頭模組中原本的 <code>use</code> 改成 <code>pub use</code>。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 7-17：使用 <code>pub use</code> 使名稱公開給任何程式的作用域中引用</span></p>
<p>使用 <code>pub use</code> 可以讓外部程式碼以 <code>hosting::add_to_waitlist</code> 的方式來呼叫函式 <code>add_to_waitlist</code>。如果我們沒有指明 <code>pub use</code>，函式 <code>eat_at_restaurant</code> 仍可以在它的作用域呼叫 <code>hosting::add_to_waitlist</code>，但外部程式碼就無法利用這個新的路徑。</p>
<p>當程式碼的內部結構與使用程式的開發者對於該領域所想像的結構不同時，重新匯出會很有用。我們再次用餐廳做比喻的話就像是，經營餐廳的人可能會想像餐廳是由「前端」與「後端」所組成，但光顧的顧客可能不會用這些術語來描繪餐廳的每個部分。使用 <code>pub use</code> 的話，我們可以用某種架構寫出程式碼，再以不同的架構對外公開。這樣讓我們的的函式庫可以完整的組織起來，且對開發函式庫的開發者與使用函式庫的開發者都提供友善的架構。</p>
<h3><a class="header" href="#使用外部套件" id="使用外部套件">使用外部套件</a></h3>
<p>在第二章我們寫了一支猜謎遊戲專案時，有用到一個外部套件叫做 <code>rand</code> 來取得隨機數字。要在專案內使用 <code>rand</code> 的話，我們會在 <em>Cargo.toml</em> 加上此行：</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>在 <em>Cargo.toml</em> 新增  <code>rand</code> 作爲依賴函式庫會告訴 Cargo 要從 <a href="https://crates.io/">crates.io</a> 下載  <code>rand</code> 以及其他相關的依賴，讓我們可專案可以使用 <code>rand</code>。</p>
<p>接下來要將 <code>rand</code> 的定義引入我們套件的作用域的話，我們加上一行 <code>use</code> 後面接著 crate 的名稱 <code>rand</code> 然後列出我們想要引入作用域的項目。回想一下在第二章<a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">「產生隨機數字」</a><!-- ignore -->的段落，我們將 <code>Rng</code> 特徵引入作用域中，並呼叫函式 <code>rand::thread_rng</code>：</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1, 101);
<span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span>}
</code></pre>
<p>Rust 社群成員在 <a href="https://crates.io/">crates.io</a> 發佈了不少套件可供使用，要將這些套件引入到你的套件的步驟是一樣的。在你的套件的 <em>Cargo.toml</em> 檔案列出它們，然後使用 <code>use</code> 將這些 crate 內的項目引入作用域中。</p>
<p>請注意到標準函式庫（<code>std</code>）對於我們的套件來說也是一個外部 crate。由於標準函式庫會跟著 Rust 語言發佈，所以我們不需要更改 <em>Cargo.toml</em> 來包含 <code>std</code>。但是我們仍然需使用 <code>use</code> 來將它的項目引入我們套件的作用域中。舉例來說，要使用 <code>HashMap</code> 我們可以這樣寫：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<p>這是個用標準函式庫的 crate 名稱 <code>std</code> 起頭的絕對路徑。</p>
<h3><a class="header" href="#使用巢狀路徑來大量的-use-行數" id="使用巢狀路徑來大量的-use-行數">使用巢狀路徑來大量的 <code>use</code> 行數</a></h3>
<p>如果我們要使用在相同 crate 或是相同模組內定義的數個項目，針對每個項目都單獨寫一行的話，會佔據我們檔案內很多空間。舉例來說，範例 2-4 中的猜謎遊戲我們用了這兩個 <code>use</code> 陳述式來引入作用域中：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>我們可以改使用巢狀路徑（nested paths）來只用一行就能將數個項目引入作用域中。我們先指明相同路徑的部分，加上雙冒號，然後在大括號內列出各自不同的路徑部分，如範例 7-18 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
use std::{cmp::Ordering, io};
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 7-18：使用巢狀路徑引入有部分相同前綴的數個路徑至作用域中</span></p>
<p>在較大的程式中，使用巢狀路徑將相同 crate 或相同模組中的許多項目引入作用域，可以大量減少 <code>use</code> 陳述式的數量！</p>
<p>我們可以在路徑中的任何部分使用巢狀路徑，這在組合兩個享有相同子路徑的 <code>use</code> 陳述式時非常有用。舉例來說，範例 7-19 顯示了兩個 <code>use</code> 陳述式：一個將 <code>std::io</code> 引入作用域，另一個將 <code>std::io::Write</code> 引入作用域。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 7-19：兩個 <code>use</code> 陳述式且其中一個是另一個的子路徑</span></p>
<p>這兩個路徑的相同部分是 <code>std::io</code>，這也是整個第一個路徑。要將這兩個路徑合爲一個 <code>use</code> 陳述式的話，我們可以在巢狀路徑使用 <code>self</code>，如範例 7-20 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 7-20：組合範例 7-19 的路徑爲一個 <code>use</code> 陳述式</span></p>
<p>此行就會將 <code>std::io</code> 和 <code>std::io::Write</code> 引入作用域。</p>
<h3><a class="header" href="#全域運算子" id="全域運算子">全域運算子</a></h3>
<p>如果我們想要將在一個路徑中所定義的<em>所有</em>公開項目引入作用域的話，我們可以在指明路徑之後加上全域（glob）運算子 <code>*</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<p>此 <code>use</code> 陳述式會將 <code>std::collections</code> 定義的所有公開項目都引入作用域中。不過請小心使用全域運算子！它容易讓我們無法分辨作用域內的名稱，以及程式中使用的名稱是從哪定義來的。</p>
<p>全域運算子很常用在 <code>tests</code> 模組下，將所有東西引入測試中。我們會在第十一章的<a href="ch11-01-writing-tests.html#how-to-write-tests">「如何寫測試」</a><!-- ignore -->段落來討論。 全域運算子也常拿來用在 prelude 模式中，你可以查閱<a href="../std/prelude/index.html#other-preludes">標準函式庫的技術文件</a><!-- ignore -->來瞭解此模式的更多資訊。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch07-04-bringing-paths-into-scope-with-the-use-keyword.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#將模組拆成不同檔案" id="將模組拆成不同檔案">將模組拆成不同檔案</a></h2>
<p>本章節目前所有的範例將數個模組定義在同一個檔案中。當模組增長時，你可能會想要將它們的定義拆開到別的檔案中，好讓程式碼容易瀏覽。</p>
<p>舉例來說，讓我修將範例 7-17 中的 <code>front_of_house</code> 模組移到它自己的檔案 <em>src/front_of_house.rs</em>，然後在 crate 源頭檔案加上這個模組，如範例 7-21 所示。在此例中，源頭檔案爲 <em>src/lib.rs</em> 不過這步驟在二進制執行檔 crate 的 src/main.rs* 一樣可行。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">範例 7-21：宣告 <code>front_of_house</code> 模組，其本體位於 <em>src/front_of_house.rs</em></span></p>
<p>然後 <code>front_of_house</code> 模組的本體會定義在 <em>src/front_of_house.rs</em>，如範例 7-22 所示。</p>
<p><span class="filename">檔案名稱：src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p><span class="caption">範例 7-22：<code>front_of_house</code> 模組的定義位於 <em>src/front_of_house.rs</em></span></p>
<p>在 <code>mod front_of_house</code> 之後用分號而不是大括號會告訴 Rust 讀取其他與模組同名的檔案以取得模組內容。讓我們繼續將範例中的 <code>hosting</code> 模組也取出並移到它自己的檔案中，我們可以變更 <em>src/front_of_house.rs</em> 成只包含 <code>hosting</code> 模組的宣告</p>
<p><span class="filename">檔案名稱：src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;
</code></pre>
<p>然後我們建立一個目錄 <em>src/front_of_house</em> 以及一個檔案 <em>src/front_of_house/hosting.rs</em> 來包含 <code>hosting</code> 模組的定義：</p>
<p><span class="filename">檔案名稱：src/front_of_house/hosting.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_to_waitlist() {}
<span class="boring">}
</span></code></pre></pre>
<p>雖然定義都被移到不同的檔案了，但模組樹維持不變，而且在 <code>eat_at_restaurant</code> 的函式呼叫方式也不用做任何更改。此技巧讓你可以將增長中的模組移到新的檔案。</p>
<p>另外 <em>src/lib.rs</em> 內的 <code>pub use crate::front_of_house::hosting</code> 陳述式沒有改變，在檔案作爲 crate 的一部分來編譯時，使用 <code>use</code> 的方式也沒有改變。<code>mod</code> 關鍵字能宣告模組，然後 Rust 會去同名的檔案尋找該模組的程式碼。</p>
<h2><a class="header" href="#總結-5" id="總結-5">總結</a></h2>
<p>Rust 讓你能夠將套件拆成數個 crate，然後 crate 能在分成數個模組，好讓你可以從一個模組內指定其他模組的項目。而你可以使用絕對或相對路徑來達成。這些路徑可以用 <code>use</code> 陳述式來引入作用域，讓你可以在該作用域用更短的路徑來多次呼叫該項目。模組程式碼預設爲私有的，但你可以使用 <code>pub</code> 關鍵字公開它的定義內容。</p>
<p>在下個章節，我們將探討在標準函式庫中的一些資料結構集合，讓你可以利用它們寫出整潔有組織的程式碼。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch07-05-separating-modules-into-different-files.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h1><a class="header" href="#常見集合" id="常見集合">常見集合</a></h1>
<p>Rust 的標準函式庫提供一些非常實用的資料結構稱之爲<em>集合（collections）</em>。多數其他資料型別只會呈現一個特定數值，但是集合可以包含數個數值。不像內建的陣列與元組型別，這些集合指向的資料位於堆積上，代表資料的數量不必在編譯期就知道，而且可以隨著程式執行增長或縮減。每種集合都有不同的能力以及消耗，依照你的情形選擇適當的集合，是一項你會隨著開發時間漸漸掌握的技能。在本章節我們會介紹三種在 Rust 程式中十分常用的集合：</p>
<ul>
<li><em>Vector</em> 允許你接二連三地儲存數量不定的數值。</li>
<li><em>字串（String）</em> 是字元的集合。我們在之前就提過 <code>String</code> 型別，本章會正式深入介紹。這是從一種通用資料結構 <em>map</em> 衍生出來的特定實作。</li>
</ul>
<p>想瞭解更多標準函式庫提供的集合種類的話，歡迎查閱<a href="../std/collections/index.html">技術文件</a>。</p>
<p>我們將討論如何建立與更新 vector、字串與雜湊映射，以及它們的所長。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch08-00-common-collections.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過-vector-儲存列表" id="透過-vector-儲存列表">透過 Vector 儲存列表</a></h2>
<p>我們第一個要來看的集合是 <code>Vec&lt;T&gt;</code> 常稱爲 <em>vector</em>。Vectors 允許你在一個資料結構儲存不止一個數值，而且該結構的記憶體會接連排列所有數值。它們很適合用來處理你手上的項目列表，像是一個檔案中每行的文字，或是購物車內每像物品。</p>
<h3><a class="header" href="#建立新的-vector" id="建立新的-vector">建立新的 Vector</a></h3>
<p>要建立一個新的空 vector 的話，我們可以呼叫 <code>Vec::new</code> 函式，如範例 8-1 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-1建立一個儲存數值型別爲 <code>i32</code> 的空 vector</span></p>
<p>注意到我們在此加了型別詮釋。因爲我們沒有對此 vector 插入任何數值，Rust 不知道我們想儲存什麼類型的元素。這是一項重點，vector 是用泛型（generics）實作，我們會在第十章說明如何爲你自己的型別使用泛型。現在我們只需要知道標準函式庫提供的 <code>Vec&lt;T&gt;</code> 型別可以持有任意型別，然後當特定 vector 要持有特定型別時，該型別會標是在尖括號內。在範例 8-1，我們告訴 Rust 在 <code>v</code> 中的 <code>Vec&lt;T&gt;</code> 會持有 <code>i32</code> 型別的元素。</p>
<p>在更實際的程式碼中，當你插入數值時，Rust 通常都能推導出型別來。所以你不太常會需要指明型別詮釋。建立 <code>Vec&lt;T&gt;</code> 的同進行初始化是更常見的，爲此 Rust 提供了 <code>vec!</code> 以便使用。此巨集會建立一個新的 vector 並取得你提供的數值。在範例 8-2 中，我們建立了一個新的 <code>Vec&lt;i32&gt;</code> 並擁有數值 <code>1</code>、<code>2</code> 和 <code>3</code>。整數型別爲 <code>i32</code> 是因爲這是預設整數型別，如同我們在第三章的<a href="ch03-02-data-types.html#data-types">「資料型別」</a><!-- ignore --> 段落提到的一樣。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-2：建立一個擁有數值的新 vector</span></p>
<p>因爲我們給予了初始的 <code>i32</code> 數值，Rust 可以推導出 <code>v</code> 的型別爲 <code>Vec&lt;i32&gt;</code>，所以型別詮釋就不是必要的了。接下來，讓我們看看如何修改 vector。</p>
<h3><a class="header" href="#更新-vector" id="更新-vector">更新 Vector</a></h3>
<p>要在建立 vector 之後新增元素的話，我們可以使用 <code>push</code> 方法，如範例 8-3 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-3：使用 <code>push</code> 方法來新增數值到 vector</span></p>
<p>與其他變數一樣，如果我們想要變更其數值的話，我們需要使用 <code>mut</code> 關鍵字使它成爲可變的，如同第三章提到的一樣。我們插入的數值所屬型別均爲 <code>i32</code>，然後 Rust 可以從資料推導，所以我們不必指明 <code>Vec&lt;i32&gt;</code>。</p>
<h3><a class="header" href="#釋放-vector-的同時也會釋放其元素" id="釋放-vector-的同時也會釋放其元素">釋放 Vector 的同時也會釋放其元素</a></h3>
<p>就像其它 <code>struct</code> 一樣，vector 會在作用域結束時被釋放，如範例 8-4 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // do stuff with v
    } // &lt;- v goes out of scope and is freed here
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-4：顯示 vector 及其元素在哪裡被釋放</span></p>
<p>當 vector 被釋放時，其所有內容也都會被釋放，代表它持有的那些整數都會被清除。這雖然聽起來很直觀，但是當我們開始引用 vector 中的元素時可能就會變得有點複雜。讓我們看看怎麼處理這種情形吧！</p>
<h3><a class="header" href="#讀取-vector-元素" id="讀取-vector-元素">讀取 Vector 元素</a></h3>
<p>現在你知道如何建立、更新與刪除 vector，接下來就是要知道如何讀取他們的內容了。要引用 vector 儲存的數值有兩種方式。爲了更加清楚說明此範例，我們詮釋了函式回傳值的型別。</p>
<p>範例 8-5 顯示了取得 vector 中數值的方法，可以是用索引語法或者 <code>get</code> 方法。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {}&quot;, third);

    match v.get(2) {
        Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-5：使用索引語法或 <code>get</code> 方法來取的 vector 項目</span></p>
<p>我們要注意兩個地方。首先，我們使用了索引數值 <code>2</code> 來獲取地三個元素：vectors 可以用數字來索引，從零開始計算。第二，使用 <code>&amp;</code> 和 <code>[]</code> 會給我們一個引用，而使用 <code>get</code> 方法加上一個索引作爲引數，則會給我們 <code>Option&lt;&amp;T&gt;</code>。</p>
<p>Rust 有兩種取得元素引用的方式，所以能以此決定程式的行爲。像是當你使用了一個索引但 vector 卻沒有對應的元素的情況。讓我們看看一個範例，我們有一個 vector 擁有五個元素，但我們嘗試用索引 100 來取得對應數值，如範例 8-6 所示。</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-6：嘗試對只有五個元素的 vector 取得索引 100 的值</span></p>
<p>當我們執行程式時，第一個 <code>[]</code> 方法會讓程式恐慌，因爲它引用了不存在的元素。此方法適用於當你希望一有無效索引時就讓程式崩潰的狀況。</p>
<p>當你使用 <code>get</code> 方法來索取 vector 不存在的索引時，它會回傳 <code>None</code> 而不會恐慌。如果正常情況下偶而會不小心存取超出 vector 範圍索引的話，你就會想要只用此方法。你的程式碼就會有個邏輯專門處理 <code>Some(&amp;element)</code> 或 <code>None</code>，如同第六章所述。舉例來說，可能會有由使用者輸入的索引。如果他不小心輸入太大的數字的話，程式可以回傳 <code>None</code>，你可以告訴使用者目前 vector 有多少項目，並讓他們可以再輸入一次。這會比直接讓程式崩潰還來的親民，他們可能只是不小心打錯而已！</p>
<p>當程式有個有效引用時，借用檢查器（borrow checker）會貫徹所有權以及借用規則（如第四章所述）來確保此引用及其他對 vector 內容的引用都是有效的。回想一下有個規則是我們不能在同個作用域同時擁有可變與不可變引用。這個規則一樣適用於範例 8-7，在此我們有一個 vector 第一個元素的不可變引用，然後我們嘗試在 vector 後方新增元素。如果我們嘗試在此動作後繼續使用第一個引用的話，程式會無法執行：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {}&quot;, first);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 8-7：在持有一個項目的引用時，還嘗試對 vector 新增元素</span></p>
<p>編譯此程式會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;The first element is: {}&quot;, first);
  |                                          ----- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<p>範例 8-7 的程式碼看起來好像能執行。爲何第一個元素的引用要在意 vector 的最後端發生了什麼事呢？此錯誤其實跟 vector 運作的方式有關：在 vector 後方新增元素時，如果當前 vector 的空間不夠在塞入另一個值的話，可能會需要分配新的記憶體並複製舊的元素到新的空間中。這樣一來，第一個元素的索引可能就會指向已經被釋放的記憶體，借用規則會防止程式遇到這樣的情形。</p>
<blockquote>
<p>注意：關於 <code>Vec&lt;T&gt;</code> 型別更多的實作細節，歡迎查閱<a href="../nomicon/vec.html">「The Rustonomicon」</a>。</p>
</blockquote>
<h3><a class="header" href="#遍歷-vector-的元素" id="遍歷-vector-的元素">遍歷 Vector 的元素</a></h3>
<p>如果我們想要依序存取 vector 中每個元素的話，我們可以遍歷所有元素而不必用索引一個一個取得。範例 8-8 闡釋了如何使用 <code>for</code> 迴圈來取得一個 <code>i32</code> vector 中每個元素的不可變引用並印出他們。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-8：使用 <code>for</code> 迴圈遍歷 vector 中每個元素</span></p>
<p>我們還可以遍歷可變 vector 中的每個元素取得可變引用來改變每個元素。像是範例 8-9 就使用 <code>for</code> 迴圈來爲每個元素加上 <code>50</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-9：遍歷 vector 中的元素取得可變引用</span></p>
<p>要改變可變引用指向的數值，在使用 <code>+=</code> 運算子之前，我們需要使用解引用運算子（<code>*</code>）來取得 <code>i</code> 的數值。我們會在第十五章的<a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">「使用解引用運算子追蹤指標的數值」</a>段落來講解更多解引用運算子的細節。</p>
<h3><a class="header" href="#使用枚舉來儲存多種型別" id="使用枚舉來儲存多種型別">使用枚舉來儲存多種型別</a></h3>
<p>在本章的一開始，我們說 vector 只能儲存同型別的數值。這在某些情況會很不方便，一定會有場合是要儲存不同型別到一個列表中的。幸運的是，枚舉的變體是定義在相同的枚舉型別，所以當我們需要在 vector 儲存不同型別的元素時，我們可以用枚舉來定義！</p>
<p>舉例來說，假設我們想從表格中的一行取的數值，但是有些行內的列會包含整數、浮點數以及一些字串。我們可以定義一個枚舉，其變體會持有不同的數值型別，然後所有的枚舉變體都會被視爲相同型別：就是它們的枚舉。接著我們就可以建立一個擁有此枚舉型別的 vector，最終達成持有不同行邊。如範例 8-10 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-10：用 <code>enum</code> 定義儲存不同型別的枚舉並作爲 vector 的型別</span></p>
<p>Rust 需要在編譯時期知道 vector 的型別以及要在堆積上用到多少記憶體才能儲存每個元素。這樣做第二個好處是我們能知道此 vector 會顯式哪些型別。如果 Rust 允許 vector 一次持有任意型別的話，在對 vector 中每個元素進行處理時，可能就會有一或多種型別會產生錯誤。使用枚舉和 <code>match</code> 表達式讓 Rust 可以在編譯期間確保每個可能的情形都已經處理完善了，如同第六章提到的一樣。</p>
<p>當你在寫程式時，如果你無法確切知道執行時程式所處理的所有型別的話，枚舉就不管用了。這時使用特徵物件會比較好，我們會在第十七章再來解釋。</p>
<p>現在我們已經講了一些 vector 常見的用法，有時間的話記得到<a href="../std/vec/struct.Vec.html">vector 的 API 技術文件</a>瞭解標準函式庫中 <code>Vec&lt;T&gt;</code> 所有實用的方法。舉例來說，除了 <code>push</code> 方法以外，還有個 <code>pop</code> 方法可以移除並回傳最後一個元素。接下來讓我們看看下一個集合型別：<code>String</code>！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch08-01-vectors.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過字串儲存-utf-8-編碼的文字" id="透過字串儲存-utf-8-編碼的文字">透過字串儲存 UTF-8 編碼的文字</a></h2>
<p>我們已經在第四章提到字串（String），但現在我們要更加深入探討。Rustaceans 初心者常常會卡在三個環節：Rust 傾向於回報可能的錯誤、字串的資料結構比開發者所熟悉的還要複雜，以及 UTF-8。這些要素讓來自其他程式語言背景的開發者會遇到一些困難。</p>
<p>我們會在集合章節討論字串的原因是，字串本身就是位元組的集合，且位元組作爲文字呈現時，它會提供一些實用的方法。在此段落我們將和其他集合型別一樣討論 <code>String</code> 的操作，像是建立、更新與讀取。我們還會討論到 <code>String</code> 與其他集合不一樣的地方，像是 <code>String</code> 的索引就比其他集合還複雜，因爲它會依據人們對於 <code>String</code> 資料型別的理解而有所不同。</p>
<h3><a class="header" href="#什麼是字串" id="什麼是字串">什麼是字串？</a></h3>
<p>首先我們要好好定義<em>字串（String）<em>這個術語。Rust 在核心語言中只有一個字串型別，那就是字串 slice <code>str</code>，它通常是以借用的形式存在 <code>&amp;str</code>。在第四章中我們提到</em>字串 slice</em>是一個針對存在某處的  UTF-8 編碼資料的引用。舉例來說，字串字面值（String literals）就儲存在程式的二進制檔案中，因此就是字串 slice。</p>
<p><code>String</code> 型別是 Rust 標準函式庫所提供的型別，並不是核心語言內建的型別，它是可增長的、可變的、可擁有所有權的 UTF-8 編碼字串型別。當 Rustaceans 提及 Rust 中的「字串」時，他們通常指的是 <code>String</code> 以及字串 slice <code>&amp;str</code> 型別，而不只是其中一種型別。雖然此段落大部分都在討論 <code>String</code>，這兩個型別都時常用在 Rust 的標準函式庫中，且 <code>String</code> 與字串 slices 都是 UTF-8 編碼的。</p>
<p>Rust 的標準函式庫還包含了其他種類的字串型別，像是 <code>OsString</code>、<code>OsStr</code>、<code>CString</code> 以及 <code>CStr</code>。函式庫 crates 更可以提供儲存字串資料的更多選項。你應該會注意到這些型別的結尾都是 <code>String</code> 和 <code>Str</code>，它們分別代表擁有所有權與借用的變體。就像你之前看到的 <code>String</code> 和 <code>str</code> 型別一樣。這些字串型別可以儲存不同編碼的文字或者以不同的記憶體形式呈現。我們不會在本章節討論這些字串型別，要是你想知道如何或何時使用它們的話，你可以查閱它們的 API 技術文件。</p>
<h3><a class="header" href="#建立新的字串" id="建立新的字串">建立新的字串</a></h3>
<p>許多 <code>Vec&lt;T&gt;</code> 可使用的方法在 <code>String</code> 也都能用，像是用 <code>new</code> 函式建立新的字串，如範例 8-11 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-11：建立新的空 <code>String</code></span></p>
<p>此行會建立新的字串叫做 <code>s</code> ，我們之後可以在寫入資料。不過通常我們會希望建立字串的同時能夠初始化資料。爲此我們可以使用 <code>to_string</code> 方法，任何有實作 <code>Display</code> 特徵的型別都可以使用此方法，就像字串字面值的使用方式一樣。範例 8-12 就展示了兩種例子。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let data = &quot;initial contents&quot;;

    let s = data.to_string();

    // the method also works on a literal directly:
    let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-12：從字串字面值使用 <code>to_string</code> 方法來建立 <code>String</code></span></p>
<p>此程式碼建立了一個字串內容爲 <code>initial contents</code>。</p>
<p>我們也可以用函式 <code>String::from</code> 從字串字面值建立 <code>String</code>。範例 8-13 的程式碼和使用 <code>to_string</code> 的範例 8-12 效果一樣。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-13：使用函式 <code>String::from</code> 從字串字面值建立 <code>String</code></span></p>
<p>因爲字串用在許多地方，我們可以使用許多不同的通用字串 API 供我們選擇。有些看起來似乎是多餘的，但是它們都有一席之地的！在上面的範例中 <code>String::from</code> 和 <code>to_string</code> 都在做相同的事，所以你的選擇在於喜好風格上。</p>
<p>另外記得字串是 UTF-8 編碼的，所以我們可以包含任何正確編碼的資料，如範例 8-14 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let hello = String::from(&quot;السلام عليكم&quot;);
    let hello = String::from(&quot;Dobrý den&quot;);
    let hello = String::from(&quot;Hello&quot;);
    let hello = String::from(&quot;שָׁלוֹם&quot;);
    let hello = String::from(&quot;नमस्ते&quot;);
    let hello = String::from(&quot;こんにちは&quot;);
    let hello = String::from(&quot;안녕하세요&quot;);
    let hello = String::from(&quot;你好&quot;);
    let hello = String::from(&quot;Olá&quot;);
    let hello = String::from(&quot;Здравствуйте&quot;);
    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-14：用字串儲存各種語言打招呼的文字</span></p>
<p>以上全是合理的 <code>String</code> 數值。</p>
<h3><a class="header" href="#更新字串" id="更新字串">更新字串</a></h3>
<p>就和 <code>Vec&lt;T&gt;</code> 一樣，如果你插入更多資料的話，<code>String</code> 可以增長大小並變更其內容。除此之外你也可以使用 <code>+</code> 運算子或 <code>format!</code> 巨集來串接 <code>String</code> 數值。</p>
<h4><a class="header" href="#使用-push_str-和-push-追加字串" id="使用-push_str-和-push-追加字串">使用 <code>push_str</code> 和 <code>push</code> 追加字串</a></h4>
<p>我們可以使用 <code>push_str</code> 方法來追加一個字串 slice 使字串增長，如範例 8-15 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-15：使用 <code>push_str</code> 方法向 <code>String</code> 追加字串 slice</span></p>
<p>在這兩行之後，<code>s</code> 會包含 <code>foobar</code>。<code>push_str</code> 方法取得的是字串 slice 因爲我們並不需要取得參數的所有權。舉例來說範例 8-16 就說明了如果 <code>s2</code> 在追加其內容給 <code>s1</code> 之後卻不能使用的話，就很不妙了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-16：在內容追加給 <code>String</code> 後繼續使用字串 slice</span></p>
<p>如果 <code>push_str</code> 方法會取得 <code>s2</code> 的所有權，我們就無法在最後一行印出其數值了。幸好這段程式碼是可以執行的！</p>
<p>而 <code>push</code> 方法會取得一個字元作爲參數並加到 <code>String</code> 上。範例 8-17 顯示了一個使用 <code>push</code> 方法將字母 <em>l</em> 加到 <code>String</code> 的程式碼。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-17：使用 <code>push</code> 將一個字元加到 <code>String</code></span></p>
<p>此程式碼的結果就是 <code>s</code> 會包含 <code>lol</code>。</p>
<h4><a class="header" href="#使用--運算子或-format-巨集串接字串" id="使用--運算子或-format-巨集串接字串">使用 <code>+</code> 運算子或 <code>format!</code> 巨集串接字串</a></h4>
<p>你通常會想要組合兩個字串在一起，其中一種方式是用 <code>+</code> 運算子。如範例 8-18 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hello, &quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + &amp;s2; // 注意到 s1 被移動因此無法再被使用
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-18：使用 <code>+</code> 運算子組合兩個 <code>String</code> 數值成一個新的 <code>String</code> 數值</span></p>
<p>程式碼最後的字串 <code>s3</code> 就會獲得 <code>Hello, world!</code>。<code>s1</code> 之所以在相加後不再有效，以及 <code>s2</code> 是使用引用的原因，都和我們使用 <code>+</code> 運算子時呼叫的方法簽名有關。<code>+</code> 運算子使用的是 <code>add</code> 方法，其簽名會長得像這樣：</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>這不全是標準函式庫中實際的簽名，在標準函式庫中 <code>add</code> 是用泛型（generics）定義。我們在此看到的是使用實際型別指明泛型的 <code>add</code> 簽名。我們會在第十章討論到泛型。此簽名給了一些我們需要瞭解 <code>+</code> 運算子的一些線索。</p>
<p>首先 <code>s2</code> 有 <code>&amp;</code> 代表我們是將第二個字串的<em>引用</em>與第一個字串相加，因爲函式 <code>add</code> 中的參數 <code>s</code> 說明我們只能將 <code>&amp;str</code> 與 <code>String</code> 相加，我們無法將兩個 <code>String</code> 數值相加。但等等 <code>&amp;s2</code> 是 <code>&amp;String</code> 才對，並非 <code>add</code> 第二個參數所指定的 <code>&amp;str</code>。爲何範例 8-18 可以編譯呢？</p>
<p>我們可以在 <code>add</code> 的呼叫中使用 <code>&amp;s2</code> 的原因是因爲編譯器可以<em>強制（coerce）</em> <code>&amp;String</code> 引數轉換成 <code>&amp;str</code>。當我們我們呼叫 <code>add</code> 方法時，Rust <em>強制解引用（deref coercion</em>）*讓 <code>&amp;s2</code> 變成 <code>&amp;s2[..]</code>。我們會在第十五章深入探討強制解引用。因爲 <code>add</code> 不會取得 <code>s</code> 參數的所有權，<code>s2</code> 在此運算後仍然是個有效的 <code>String</code>。</p>
<p>再來，我們可以看到 <code>add</code> 的簽名會取得 <code>self</code> 的所有權，因爲 <code>self</code> <em>沒有</em> <code>&amp;</code>。這代表範例 8-18 的 <code>s1</code> 會移動到 <code>add</code> 的呼叫內，在之後就不再有效。所以雖然然 <code>let s3 = s1 + &amp;s2;</code> 看起來像是它拷貝了兩個字串的值並產生了一個新的，但此陳述式實際上是取得 <code>s1</code> 的所有權、追加一份 <code>s2</code> 的複製內容、然後回傳最終結果的所有權。換句話說，雖然它看起來像是產生了很多拷貝，但實際上並不是。此實作反而比較有效率。</p>
<p>如果我們需要串接數個字串的話，<code>+</code> 運算子的行爲看起來就顯得有點笨重了：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>此時 <code>s</code> 會是 <code>tic-tac-toe</code>。有這麼多的 <code>+</code> 和 <code>&quot;</code> 字元，我們很難看清楚發生什麼事。如果要完成更複雜的字串組合的話，我們可以使用 <code>format!</code> 巨集：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼一樣能設置 <code>s</code> 爲to <code>tic-tac-toe</code>。<code>format!</code> 巨集運作的方式和 <code>println!</code> 一樣，但不會將輸出結果顯示在螢幕上，它做的是回傳內容的 <code>String</code>。使用 <code>format!</code> 的程式碼版本看起來比較好讀懂，而且不會取走任何參數的所有權。</p>
<h3><a class="header" href="#索引字串" id="索引字串">索引字串</a></h3>
<p>在其他許多程式語言中，使用索引引用字串來取得獨立字元是有效且常見的操作。然而在 Rust 中如果你嘗試對 <code>String</code> 使用索引語法的話，你會得到錯誤。請看看範例 8-19 這段無效的程式碼。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
    let h = s1[0];
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 8-19：嘗試在字串使用索引語法</span></p>
<p>此程式會有以下錯誤結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `std::string::String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<p>錯誤訊息與提示告訴了我們 Rust 字串並不支援索引。但爲何不支援呢？要回答此問題，我們需要先討論 Rust 如何儲存字串進記憶體的。</p>
<h4><a class="header" href="#內部呈現" id="內部呈現">內部呈現</a></h4>
<p><code>String</code> 基本上就是 <code>Vec&lt;u8&gt;</code> 的封裝。讓我們看看範例 8-14 中一些正確編碼爲 UTF-8 字串的例子，像是這一個：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span><span class="boring">    let hello = String::from(&quot;Здравствуйте&quot;);
</span>    let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>在此例中 <code>len</code> 會是 4，也就是 vector 儲存的字串「Hola」長度爲 4 個位元組。每個字母在用 UFT-8 編碼時長度均爲 1 個位元組。那接下來這段呢？（請注意字串的開頭是西里爾字母 Ze 的大寫，而不是阿拉伯數字 3）</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from(&quot;السلام عليكم&quot;);
</span><span class="boring">    let hello = String::from(&quot;Dobrý den&quot;);
</span><span class="boring">    let hello = String::from(&quot;Hello&quot;);
</span><span class="boring">    let hello = String::from(&quot;שָׁלוֹם&quot;);
</span><span class="boring">    let hello = String::from(&quot;नमस्ते&quot;);
</span><span class="boring">    let hello = String::from(&quot;こんにちは&quot;);
</span><span class="boring">    let hello = String::from(&quot;안녕하세요&quot;);
</span><span class="boring">    let hello = String::from(&quot;你好&quot;);
</span><span class="boring">    let hello = String::from(&quot;Olá&quot;);
</span>    let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">    let hello = String::from(&quot;Hola&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>你可能會以爲這字串的長度爲 12，然而 Rust 給的答案卻是 24。這是將「Здравствуйте」用 UTF-8 編碼後的位元組長度，因爲該字串的每個 Unicode 純量都佔據兩個位元組。因此字串位元組的索引不會永遠都能對應到有效的 Unicode 純量數值。我們用以下無效的 Rust 程式碼進一步說明：</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p><code>answer</code> 的數值會是多少呢？會是第一個字母 <code>З</code> 嗎？當經過 UTF-8 編碼時，<code>З</code> 的第一個位元組會是 <code>208</code> 然後第二個是 <code>151</code>。所以 <code>answer</code> 實際上會拿到 <code>208</code>，但 <code>208</code> 本身又不是個有效字元。回傳 <code>208</code> 可能不會是使用者想要的，他們希望的應該是此字串的第一個字母，但這是 Rust 在位元組索引 0 唯一能回傳的資料。就算字串都只包含拉丁字母，使用者通常也不會希望看到位元組數值作爲回傳值。如果 <code>&amp;&quot;hello&quot;[0]</code> 是有效程式碼且會回傳位元組數值的話，它會回傳的是 <code>104</code> 並非 <code>h</code>。爲了預防回傳意外數值進而導致無法立刻察覺的錯誤，Rust 不會成功編譯這段程式碼，並在開發過程前期就杜絕誤會發生。</p>
<h4><a class="header" href="#位元組純量數值與形素群集我的天啊" id="位元組純量數值與形素群集我的天啊">位元組、純量數值與形素群集！我的天啊！</a></h4>
<p>UTF-8 還有一個重點是在 Rust 中我們實際上可以有三種觀點來理解字串：位元組、純量數值（scalar values）以及形素群集（grapheme clusters，最接近人們常說的「<em>字母</em>」）。</p>
<p>如果我們觀察用天成體寫的印度語「नमस्ते」，它存在 vector 中的 <code>u8</code> 數值就會長這樣：</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>這 18 個位元組是電腦最終儲存的資料？如果我們用 Unicode 純量數值觀察的話，也就是 Rust 的 <code>char</code> 型別，這些位元組會組成像這樣：</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>這邊有六個 <code>char</code> 數值，但第四個和第六個卻不是字母，它們是單獨存在不具任何意義的變音符號。最後如果我們以形素群集的角度來看的話，我們就會得到一般人所說的構成此印度語的四個字母：</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust 提拱多種不同的方式來解釋電腦中儲存的原始字串資料，讓每個程式無論是何種人類語言的資料，都可以選擇它們需要的呈現方式。</p>
<p>Rust 還有一個不允許索引 <code>String</code> 來取得字元的原因是因爲，索引運算必須永遠預期是花費常數時間（O(1)）。但在 <code>String</code> 上無法提供這樣的效能保證，因爲 Rust 會需要從索引的開頭遍歷每個內容才能決定多少有效字元存在。</p>
<h3><a class="header" href="#字串-slice-1" id="字串-slice-1">字串 slice</a></h3>
<p>索引字串通常不是個好點子，因爲字符串索引要回傳的型別是不明確的，是要一個位元組數值、一個字元、一個形素群集還是一個字串 slice 呢。因此如果你真的想要使用索引建立字串 slice 的話，Rust 會要你更明確些。要明確指定你的索引與你想要的字串 slice，與其在 <code>[]</code> 只使用一個數字來索引，你可以在 <code>[]</code> 指定一個範圍來建立包含特定位元組的字串 slice：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p><code>s</code> 在此會是 <code>&amp;str</code> 並包含字串前 4 個位元組。稍早我們提過這些字元各佔 2 個位元組，所以這裡的 <code>s</code> 就是 <code>Зд</code>。</p>
<p>那如果我們只用 <code>&amp;hello[0..1]</code> 呢？答案是 Rust 會和在 vector 中取得無效索引一樣在執行時恐慌：</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2069:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>你在使用範圍來建立字串 slice 時要格外小心，因爲這樣做有可能會使你的程式崩潰。</p>
<h3><a class="header" href="#遍歷字串的方法" id="遍歷字串的方法">遍歷字串的方法</a></h3>
<p>幸運的是你有其他方法來取得字串的元素。</p>
<p>如果你需要對每個獨立的 Unicode 純量型別做運算的話，最好的方式是使用 <code>chars</code> 方法。對「नमस्ते」呼叫 <code>chars</code> 會將六個擁有 <code>char</code> 型別的數值拆開並回傳，這樣一來你就可以遍歷每個元素：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會顯示以下輸出：</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>而 <code>bytes</code> 方法會回傳每個原始位元組，可能會在某些場合適合你：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會印出此 <code>String</code> 的 18 個位元組：</p>
<pre><code class="language-text">224
164
// --snip--
165
135
</code></pre>
<p>請確定你已經瞭解有效的 Unicode 純量數值可能不止佔 1 個位元組。</p>
<p>而要從字串取得形素群集的話就非常複雜了，所以標準函式庫並未提供這項功能。如果你需要的話，<a href="https://crates.io/">crates.io</a> 上會有提供這項功能的 crate。</p>
<h3><a class="header" href="#字串並不簡單" id="字串並不簡單">字串並不簡單</a></h3>
<p>總結來說，字串是很複雜的。不同的程式語言會選擇不同的決定來呈現給程式設計師。Rust 選擇正確處理 <code>String</code> 的方式作爲所有Rust 程式的預設行爲，這也代表開發者在處理 UTF-8 資料時需要多加考量。這樣的取捨的確對比其他程式語言來說，增加了不少字串的複雜程度，但是這能讓你在開發週期免於處理非 ASCII 字元相關的錯誤。</p>
<p>讓我們接下去開一個較簡單地集合吧：雜湊映射（hash maps）！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch08-02-strings.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過雜湊映射儲存鍵值配對" id="透過雜湊映射儲存鍵值配對">透過雜湊映射儲存鍵值配對</a></h2>
<p>我們最後一個常見的集合是<em>雜湊映射（hash map）</em>，<code>HashMap&lt;K, V&gt;</code> 型別會儲存一個鍵（key）型別 <code>K</code> 對應到一個數值（value）型別 <code>V</code>。它透過*雜湊函式（hashing function）*來決定要將這些鍵與值放在記憶體何處。許多程式語言都有支援這種類型的資料結構，不過通常它們會提供不同的名稱，像是 hash、map、object、hash table、dictionary 或 associative array 等等。</p>
<p>雜湊映射適合用於當你不想像 vector 那樣用索引搜尋資料，而是透過一個可以爲任意型別的鍵來搜尋的情況。舉例來說，在比賽中我們可以使用雜湊映射來儲存每隊的分數，每個鍵代表對與名稱，而每個值代表隊伍分數。給予一個隊伍名稱，你就能取得該隊伍分數。</p>
<p>我們會在此段落介紹雜湊映射的基本 API，但還有很多實用的函式定義在標準函式庫的 <code>HashMap&lt;K, V&gt;</code> 中，所以別忘了查閱標準函式庫的技術文件來瞭解更多資訊。</p>
<h3><a class="header" href="#建立新的雜湊映射" id="建立新的雜湊映射">建立新的雜湊映射</a></h3>
<p>你可以用 <code>new</code> 建立一個空的雜湊映射並用 <code>insert</code> 加入新元素。在範例 8-20 我們追蹤兩支隊伍的分數，分別爲藍隊與黃隊。藍隊初始分數有 10 分，黃隊則有 50 分。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-20：建立新的雜湊映射並插入一些鍵值</span></p>
<p>注意到我們需要先使用 <code>use</code> 將標準函式庫的 <code>HashMap</code> 集合引入。在我們介紹的三個常見集合中，此集合是最少被用到的，所以它並沒有包含在 prelude 內讓我們能自動引用。雜湊映射也沒有像前者那麼多標準函式庫提供的支援，像是內建建構它們的巨集。</p>
<p>和 vector 一樣，雜湊映射會將它們的資料儲存在堆積上。此 <code>HashMap</code> 得鍵是 <code>String</code> 型別而值是 <code>i32</code> 型別。和 vector 一樣，雜湊函式宣告後就都得是同類的，所有的鍵都必須是同型別，且所有的值也都必須是同型別。</p>
<p>另一種建構雜湊映射的方式爲使用疊代器並在一個元組組成的 vector 中使用 <code>collect</code> 方法，其中每個元組都包含一個鍵與值的配對。我們會在第十三章的<a href="ch13-02-iterators.html">「使用疊代器來處理一系列的項目」</a><!-- ignore -->段落中深入探討疊代器與它們相關的方法。<code>collect</code> 方法會將收集的資料轉換成其他集合型別，包含 <code>HashMap</code>。舉例來說，如果我們有兩個 vector 分別是隊伍名稱與隊伍分數的話，我們可以使用 <code>zip</code> 方法來產生由元組組成的 vector，其中「Blue」會與 10 配對，以此類推。然後我們就能用 <code>collect</code> 方法將元組 vector 轉換成雜湊映射，如範例 8-21 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
    let initial_scores = vec![10, 50];

    let mut scores: HashMap&lt;_, _&gt; =
        teams.into_iter().zip(initial_scores.into_iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-21：從隊伍列表與分數列表來產生雜湊映射</span></p>
<p><code>HashMap&lt;_, _&gt;</code> 的型別詮釋是必要的，因爲 <code>collect</code> 可以產生不同種類的資料結構，而除非你指明不然 Rust 無法知道你要何種型別。但在指明鍵值型別的參數中，我們卻使用底線。這是因爲 Rust 可以依據 vector
的資料型別推導出雜湊映射的型別。在範例 8-21 中的鍵型別就會是 <code>String</code> 然後值的型別就會是 <code>i32</code>，如同範例 8-20 的型別一樣。</p>
<h3><a class="header" href="#雜湊映射與所有權" id="雜湊映射與所有權">雜湊映射與所有權</a></h3>
<p>像是 <code>i32</code> 這種有實作 <code>Copy</code> 特徵的型別其數值可以被拷貝進雜湊映射之中。但對於像是 <code>String</code> 這種擁有所有權的數值則會被移動到雜湊映射，並成爲該數值新的擁有者，如範例 8-22 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let field_name = String::from(&quot;Favorite color&quot;);
    let field_value = String::from(&quot;Blue&quot;);

    let mut map = HashMap::new();
    map.insert(field_name, field_value);
    // field_name and field_value are invalid at this point, try using them and
    // see what compiler error you get!
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-22：展示當鍵值插入雜湊映射後就會擁有它們</span></p>
<p>我們之後就無法使用變數 <code>field_name</code> 和 <code>field_value</code>，因爲它們的值已經透過呼叫 <code>insert</code> 被移入雜湊映射之中。</p>
<p>如果我們插入雜湊映射的數值是引用的話，該值就不會被移動到雜湊映射之中。不過該值的引用就必須一直有效，至少直到該雜湊映射離開作用域爲止。我們會在第十章的<a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“透過生命週期驗證引用”</a><!-- ignore --> 段落討落更多細節。</p>
<h3><a class="header" href="#取得雜湊映射的數值" id="取得雜湊映射的數值">取得雜湊映射的數值</a></h3>
<p>我們可以透過 <code>get</code> 方法並提供鍵來取得其在雜湊映射對應的值，如範例 8-23 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-23：取得雜湊映射中藍隊的分數</span></p>
<p><code>score</code> 在此將會是對應藍隊的分數，而且結果會是 <code>Some(&amp;10)</code>。結果是使用 <code>Some</code> 的原因是因爲 <code>get</code> 回傳的是 <code>Option&lt;&amp;V&gt;</code>。如果雜湊映射中該鍵沒有對應值的話，<code>get</code> 就會回傳 <code>None</code>。所以程式會需要透過我們在第六章談到的方式處理 <code>Option</code>。</p>
<p>我們也可以使用 <code>for</code> 迴圈用類似的方式來遍歷雜湊映射中每個鍵值配對：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{}: {}&quot;, key, value);
    }
<span class="boring">}
</span></code></pre></pre>
<p>此程式會以任意順序印出每個配對：</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3><a class="header" href="#更新雜湊映射" id="更新雜湊映射">更新雜湊映射</a></h3>
<p>雖然鍵值配對的數量可以增加，但每個鍵同一時間就只能有一個對應的值而已。當你想要改變雜湊映射的資料的話，你必須決定如何處理當一個鍵已經有一個值的情況。你可以不管舊的值，直接用新值取代。你也可以保留舊值、忽略新值，只有在該鍵<em>尚未</em>擁有對應數值時才賦值給它。或者你也可以將舊值與新值組合起來。讓我們看看分別怎麼處理吧！</p>
<h4><a class="header" href="#覆蓋數值" id="覆蓋數值">覆蓋數值</a></h4>
<p>如果我們在雜湊映射插入一個鍵值配對，然後又在相同鍵插入不同的數值的話，該鍵相對應的數值就會被取代。如範例 8-24 雖然我們呼叫了兩次 <code>insert</code>，但是雜湊映射只會保留一個鍵值配對，因爲我們向藍隊的鍵插入了兩次數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-24：替換某個特定鍵對應的數值</span></p>
<p>此程式碼會印出 <code>{&quot;Blue&quot;: 25}</code>，原本的數值 <code>10</code> 會被覆蓋。</p>
<h4><a class="header" href="#只在鍵沒有值的情況下插入數值" id="只在鍵沒有值的情況下插入數值">只在鍵沒有值的情況下插入數值</a></h4>
<p>通常檢查某個特定的鍵有沒有數值，如果沒有的話才插入數值是很常見的。雜湊映射提供了一個特別的 API 叫做 <code>entry</code> 讓你可以用想要檢查的鍵作爲參數。<code>entry</code> 方法的回傳值是一個枚舉叫做 <code>Entry</code>，它代表了一個可能存在或不存在的數值。假設我們想要檢查黃隊的鍵有沒有對應的數值。如果沒有的話，我們想插入 50。而對藍隊也一樣。使用 <code>entry</code> API 的話，程式碼會長得像範例 8-25。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-25：使用 <code>entry</code> 方法在只有該鍵尚無任何數值時插入數值</span></p>
<p><code>Entry</code> 中的 <code>or_insert</code> 方法定義了如果 <code>Entry</code> 的鍵有對應的數值的話，就回傳該值得可變引用；如果沒有的話，那就插入參數作爲新數值，並回傳此值的可變引用。這樣的技巧比我們親自寫邏輯還來的清楚，而且更有利於借用檢查器的檢查。</p>
<p>執行範例 8-25 的程式碼會印出 <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>。第一次 <code>entry</code> 的呼叫會對黃隊插入數值 50，因爲黃隊尚未有任何數值。第二次 <code>entry</code> 的呼叫則不會改變雜湊映射，因爲藍隊已經有數值 10。</p>
<h4><a class="header" href="#依據舊值更新數值" id="依據舊值更新數值">依據舊值更新數值</a></h4>
<p>雜湊映射還有另一種常見的用法是，依照鍵的舊數值來更新它。舉例來說，範例 8-26 展示了一支如何計算一些文字內每個單字各出現多少次的程式碼。我們使用雜湊映射，鍵爲單字然後值爲我們每次追蹤計算對應單字出現多少次的次數。如果我們是第一次看到該單字的話，我們插入數值 0。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::collections::HashMap;

    let text = &quot;hello world wonderful world&quot;;

    let mut map = HashMap::new();

    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);
        *count += 1;
    }

    println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 8-26：使用雜湊映射儲存單字與次數來計算每個字出現的次數</span></p>
<p>此程式碼會印出 <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>。<code>or_insert</code> 方法會回傳該鍵對應數值的可變引用（<code>&amp;mut V</code>）。在此我們將可變引用儲存在 <code>count</code> 變數中，所以要賦值的話，我們必須先使用 <code>*</code> 來解引用（dereference）<code>count</code>。可變引用會在 <code>for</code> 結束時離開作用域，所以所有的改變都是安全的且符合借用規則。</p>
<h3><a class="header" href="#雜湊函式" id="雜湊函式">雜湊函式</a></h3>
<p><code>HashMap</code> 預設是使用一種「密碼學安全（cryptographically strong）」<sup class="footnote-reference"><a href="#siphash">1</a></sup>的雜湊函式（hashing function），這可以抵禦阻斷服務（Denial of Service, DoS）的攻擊。這並不是最快的雜湊演算法，但爲了提升安全性唲犧牲一點效能是值得的。如果你做評測時覺得預設的雜湊函式太慢無法滿足你的需求的話，你可以指定不同的 <em>hasher</em> 來切換成其他雜湊函式。Hasher 是一個有實作 <code>BuildHasher</code> 特徵的型別。我們會在第十章討論到特徵以及如何實作它們。你不必從頭自己實作一個 hasher，<a href="https://crates.io/">crates.io</a> 上有其他 Rust 使用者分享的函式庫，其中就有不少提供許多常見雜湊演算法的 hasher 實作。</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.131002.net/siphash/siphash.pdf">https://www.131002.net/siphash/siphash.pdf</a></p>
</div>
<h2><a class="header" href="#總結-6" id="總結-6">總結</a></h2>
<p>當你的程式需要儲存、取得、修改資料時，vector、字串與雜湊映射可以提供大量的功能。以下是一些你應該能夠解決的練習題：</p>
<ul>
<li>給予一個整數列表，請使用 vector 並回傳算數平均數、中位數（排序列表後正中間的值）以及眾數（出現最多次的值，雜湊映射在此應該會很有用）。</li>
<li>將字串轉換成 pig latin。每個單字的第一個字母爲子音的話，就將該字母移到單字後方，並加上「ay」，所以「first」會變成「irst-fay」。而單字第一個字母爲母音的話，就在單字後方加上「hay」，所以「apple」會變成「apple-hay」。請注意要考慮到 UTF-8 編碼！</li>
<li>使用雜湊映射與 vector 來建立文字介面，讓使用者能新增員工名字到公司內的一個部門。舉來來說「Add Sally to Engineering」或「Add Amir to Sales」。然後讓使用者可以索取一個部門所有的員工列表，或是依據部門用字點順序排序，取得公司內所有的員工。</li>
</ul>
<p>標準函式庫的 API 技術文件有詳細介紹 vector、字串與雜湊映射的所有方法，這對於這些練習題應該會很有幫助！</p>
<p>我們現在已經開始遇到有可能會運作失敗的複雜程式了，所以接下來正是來討論錯誤處理的時候！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch08-03-hash-maps.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h1><a class="header" href="#錯誤處理" id="錯誤處理">錯誤處理</a></h1>
<p>Rust 對可靠性的注重也包含錯誤處理。錯誤是重試開發中不可避免的一環，所以 Rust 有一些特色能夠處理發生錯誤的情形。在許多情況下，Rust 要求你要任知道可能出錯的地方，並在編譯前採取行動。這樣的要求能讓你的程式更穩定，確保你能發現錯誤並在程式碼發佈到生產環境前妥善處理它們！</p>
<p>Rust 將錯誤分成兩大類：*可復原的（recoverable）<em>和</em>不可復原的（unrecoverable）*錯誤。像是找不到檔案這種可復原的錯誤，回報問題給使用者並重試是很合理的。而不可復原的錯誤就會是程式錯誤的跡象，像是嘗試取得陣列結尾之後的位置。</p>
<p>許多語言不會區分這兩種錯誤，並以相同的方式處理，使用像是例外（exceptions）這樣統一的機制處理。Rust 沒有例外處理機制，取而代之的是它對可復原的錯誤提供 <code>Result&lt;T, E&gt;</code> 型別，對不可復原的錯誤使用 <code>panic!</code> 將程式停止執行。本章節會先介紹 <code>panic!</code> 再來討論 <code>Result&lt;T, E&gt;</code> 數值的回傳。除此之外，我們也將探討何時該從錯誤中復原，何時該選擇停止程式。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch09-00-error-handling.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#對無法復原的錯誤使用-panic" id="對無法復原的錯誤使用-panic">對無法復原的錯誤使用 <code>panic!</code></a></h2>
<p>有時後壞事就是壞發生在你的程式中，這本來就是你沒辦法全部避免的。在這種情況，Rust 有提供 <code>panic!</code> 巨集。當 <code>panic!</code> 巨集執行時，你的程式就會印出程式出錯的訊息，展開並清理堆疊，然後離開程式。這常用來處理當程式遇到某種錯誤時，開發者不清楚如何處理該錯誤的狀況。</p>
<blockquote>
<h3><a class="header" href="#恐慌時該解開堆疊還是直接終止" id="恐慌時該解開堆疊還是直接終止">恐慌時該解開堆疊還是直接終止</a></h3>
<p>當恐慌（panic）發生時，程式預設會開始做*解開（unwind）<em>堆疊的動作，這代表 Rust 會回溯整個堆疊，並清理裡每個它遇到的函式資料。但是這樣回溯並清理的動做很花力氣。另一種方式是直接</em>終止（abort）*程式而不清理，程式使用的記憶體會需要由作業系統來清理。如果你需要你的專案產生的二進制檔案越小越好，你可以從解開切換成終止，只要在 <em>Cargo.toml</em> 檔案中的 <code>[profile]</code> 段落加上 <code>panic = 'abort'</code> 就好。舉例來說，如果你希望在發佈模式（release mode）恐慌時直接終止，那就加上：</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>讓我們先在小程式內試試呼叫 <code>panic!</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>當你執行程式時，你會看到像這樣的結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p><code>panic!</code> 的呼叫導致印出了最後兩行的錯誤訊息。第一行顯示了我們的恐慌訊息以及該恐慌是在原始程式碼何處發生的：<em>src/main.rs:2:5</em> 指的是它發生在我們的 <em>src/main.rs</em> 檔案第二行第五個字元。</p>
<p>在此例中，該行指的就是我們寫的程式碼。如果我們查看該行，我們會看到 <code>panic!</code> 巨集的呼叫。在其他情形，<code>panic!</code> 的呼叫可能會發生在我們呼叫的程式碼內，所以錯誤訊息回報的檔案名稱與行數可能就會是其他人呼叫 <code>panic!</code> 巨集的程式碼，而不是因爲我們的程式碼才導致 <code>panic!</code> 的呼叫。我們可以在呼叫 <code>panic!</code> 程式碼的地方使用 backtrace 來找出出現問題的地方。接下來我們就會深入瞭解 backtrace。</p>
<h3><a class="header" href="#使用-panic-backtrace" id="使用-panic-backtrace">使用 <code>panic!</code> Backtrace</a></h3>
<p>讓我們看看另一個例子，這是函式庫發生錯誤而呼叫 <code>panic!</code>，而不是來自於我們在程式碼自己呼叫的巨集。範例 9-1 是個嘗試從 vector 取得元素的例子。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">範例 9-1：嘗試取得超出 vector 長度的元素，進而導致 <code>panic!</code> 被呼叫</span></p>
<p>我們在這邊嘗試取得 vector 中第 100 個元素（不過因爲索引從零開始，所以是索引 99），但是它只有 3 個元素。在此情況下，Rust 就會恐慌。使用 <code>[]</code> 會回傳元素，但是如果你傳遞了無效的索引，Rust 就回傳不了正確的元素。</p>
<p>在 C 中，嘗試讀取資料結構結束之後的元素屬於未定義行爲。你可能會得到該記憶體位置對應其資料結構的元素，即使該記憶體完全不屬於該資料結構。這就稱做*緩衝區過讀（buffer overread）*而且會導致安全漏洞。攻擊者可能故意操縱該索引來取得在資料結構後面他們原本不應該讀寫的值。</p>
<p>爲了保護你的程式免於這樣的漏洞，如果你嘗試用一個不存在的索引讀取元素的話，Rust 會停止執行並拒絕繼續運作下去。讓我們嘗試執行並看看會如何：</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>此錯誤指向了一個不是我們寫的檔案 <em>libcore/slice/mod.rs</em>。這是實作 <code>slice</code> 的 Rust 原始程式碼。當我們在我們的 <code>v</code> 使用 <code>[]</code> 時就會執行 <em>libcore/slice/mod.rs</em> 內的程式碼，而這正是 <code>panic!</code> 實際發生的地方。</p>
<p>下一行提示告訴我們可以設置 <code>RUST_BACKTRACE</code> 環境變數來取得 backtrace 以知道錯誤發生時到底發生什麼事。<em>backtrace</em> 是一個函式列表，指出得到此錯誤時到底依序呼叫了哪些函式。Rust 的 backtraces 運作方式和其他語言一樣：讀取 backtrace 關鍵是從最一開始讀取直到你看到你寫的檔案。那就會是問題發生的源頭。你寫的程式碼以上的行數就是你所呼叫的程式，而以下則是其他呼叫你的程式碼的程式。這些行數可能還會包含 Rust 核心程式碼、標準函式庫程式碼，或是你所使用的 crate。我們設置 <code>RUST_BACKTRACE</code> 環境變數的值不爲 0，來嘗試取得 backtrace 吧。你應該會看到和範例 9-2 類似的結果。</p>
<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88
   1: backtrace::backtrace::trace_unsynchronized
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:84
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:61
   4: core::fmt::ArgumentV1::show_usize
   5: std::io::Write::write_fmt
             at src/libstd/io/mod.rs:1426
   6: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:65
   7: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:50
   8: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:193
   9: std::panicking::default_hook
             at src/libstd/panicking.rs:210
  10: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:471
  11: rust_begin_unwind
             at src/libstd/panicking.rs:375
  12: core::panicking::panic_fmt
             at src/libcore/panicking.rs:84
  13: core::panicking::panic_bounds_check
             at src/libcore/panicking.rs:62
  14: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806
  15: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2657
  16: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/vec.rs:1871
  17: panic::main
             at src/main.rs:4
  18: std::rt::lang_start::{{closure}}
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  19: std::rt::lang_start_internal::{{closure}}
             at src/libstd/rt.rs:52
  20: std::panicking::try::do_call
             at src/libstd/panicking.rs:292
  21: __rust_maybe_catch_panic
             at src/libpanic_unwind/lib.rs:78
  22: std::panicking::try
             at src/libstd/panicking.rs:270
  23: std::panic::catch_unwind
             at src/libstd/panic.rs:394
  24: std::rt::lang_start_internal
             at src/libstd/rt.rs:51
  25: std::rt::lang_start
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  26: panic::main
</code></pre>
<p><span class="caption">範例 9-2：當 <code>RUST_BACKTRACE</code> 設置時，透過呼叫 <code>panic!</code> 產生的 backtrace</span></p>
<p>輸出結果有點多啊！你看到的實際輸出可能會因你的作業系統與 Rust 版本而有所不同。要取得這些資訊的 backtrace，除錯符號（debug symbols）必須啟用。當我們在使用 <code>cargo build</code> 或 <code>cargo run</code> 且沒有加上 <code>--release</code> 時，除錯符號預設是啟用的。</p>
<p>在範例 9-2 的輸出結果中，第 17 行的 backtrace 指向了我們專案中產生問題的地方：<em>src/main.rs</em> 中的第四行。如果我們不想讓程式恐慌，我們就要來調查我們所寫的程式中第一個被錯誤訊息指向的位置。在範例 9-1 中，我們爲了寫是如何使用 backtrace，故意寫出會恐慌的程式碼。要修正的方法就是不要向只有 3 個元素的 vector 要求取得索引 99 的值。當在未來你的程式碼恐慌時，你會需要知道是程式碼中的什麼動作造成的、什麼數值導致恐慌以及正確的程式碼該怎麼處理。</p>
<p>我們會在本章節<a href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">「要 <code>panic!</code> 還是不要 <code>panic!</code>」</a><!-- ignore -->的段落中再回來看 <code>panic!</code> 並研究何時該與不該使用 <code>panic!</code> 來處理錯誤條件。接下來，我們要看如何使用 <code>Result</code>來處理可回復的錯誤。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch09-01-unrecoverable-errors-with-panic.md">e5ed971</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#result-與可復原的錯誤" id="result-與可復原的錯誤"><code>Result</code> 與可復原的錯誤</a></h2>
<p>大多數的錯誤沒有嚴重到需要讓整個程式停止執行。有時後當函式失敗時，你是可以輕易理解並作出反應的。舉例來說，如果你嘗試開啟一個檔案，但該動作卻因爲沒有該檔案而失敗的話，你可能會想要建立檔案，而不是終止程序。</p>
<p>回憶一下第二章的<a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“使用 <code>Result</code> 型別處理可能的錯誤”</a><!-- ignore -->提到 <code>Result</code> 枚舉的定義有兩個變體 <code>Ok</code> 和 <code>Err</code>，如以下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>T</code> 和 <code>E</code> 是泛型型別參數，我們會在第十章深入討論泛型。你現在需要知道的事 <code>T</code> 代表我們在成功時會在 <code>Ok</code> 變體回傳的型別，而 <code>E</code> 則代表失敗時在 <code>Err</code> 變體會回傳的錯誤型別。因爲 <code>Result</code> 有這些泛型型別參數，我們可以將 <code>Result</code> 型別和標準函式庫運用到它的函式用在許多不同場合，讓成功與失敗時回傳的型別不相同。</p>
<p>讓我們呼叫一個可能會失敗的函式並回傳 <code>Result</code> 型別。在範例 9-3 我們嘗試開啟一個檔案。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 9-3：嘗試開啟一個檔案</span></p>
<p>我們怎麼知道 <code>File::open</code> 會回傳 <code>Result</code>呢？我們可以查閱<a href="../std/index.html">標準函式庫的 API 技術文件</a><!-- ignore -->，或者我們也可以親自去問編譯器！如果我們給予 <code>f</code> 一個型別詮釋，但是我們知道它和函式回傳值<em>並不</em>相同，接著嘗試編譯程式碼的話，編譯器會告訴我們型別不服。錯誤訊息會告訴我們 <code>f</code> <em>該有</em>何種型別。讓我們試試看！我們知道 <code>File::open</code> 的回傳型別不是 <code>u32</code>，所以讓我們改變 <code>let f</code> 成這樣：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let f: u32 = File::open(&quot;hello.txt&quot;);
<span class="boring">}
</span></code></pre>
<p>嘗試編譯的話會給我們以下輸出結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `std::result::Result&lt;std::fs::File, std::io::Error&gt;`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
</code></pre>
<p>這告訴我們函式 <code>File::open</code> 的回傳型別爲 <code>Result&lt;T, E&gt;</code>。泛型參數 <code>T</code> 在此已經被指明成功時會用到的型別 <code>std::fs::File</code>，也就是檔案的句柄（handle）。用於錯誤時的 <code>E</code> 型別則是 <code>std::io::Error</code>。</p>
<p>這樣的回傳型別代表 <code>File::open</code> 的呼叫在成功時會回傳我們可以讀寫的檔案句柄，但該函式呼叫也可能失敗。舉例來說，該檔案可能會不存在，或者我們沒有檔案的存取權限。<code>File::open</code> 需要有某種方式能告訴我們它的結果是成功或失敗，並回傳檔案句柄或是錯誤資訊。這樣的資訊正是 <code>Result</code> 枚舉想表達的。</p>
<p>如果 <code>File::open</code> 成功的話，變數 <code>f</code> 的數值就會獲得包含檔案句柄的 <code>Ok</code> 實例。如果失敗的話，<code>f</code> 的值就會是包含爲何產生該錯誤的資訊的 <code>Err</code> 實例。</p>
<p>我們需要讓範例 9-3 的程式碼依據 <code>File::open</code> 回傳不同的結果採取不同的動作。範例 9-4 展示了其中一種處理 <code>Result</code> 的方式，我們使用第六章提到的 <code>match</code> 表達式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    };
}
</code></pre></pre>
<p><span class="caption">範例 9-4：使用 <code>match</code> 表達式來處理回傳的 <code>Result</code> 變體</span></p>
<p>和 <code>Option</code> 枚舉一樣，<code>Result</code> 枚舉與其變體都會透過 prelude 引入作用域，所以我們不需要指明 <code>Result::</code>，可以直接在 <code>match</code> 的分支中使用 <code>Ok</code> 和 <code>Err</code> 變體。</p>
<p>我們在此告訴 Rust 結果是 <code>Ok</code> 的話，就回傳 <code>Ok</code> 變體中內部的 <code>file</code>，然後我們就可以將檔案句柄賦值給變數 <code>f</code>。在 <code>match</code> 之後，我們就可以適用檔案句柄來讀寫。</p>
<p><code>match</code> 的另一個分支則負責處理我們從 <code>File::open</code> 中取得的 <code>Err</code> 數值。在此範例中，我們選擇呼叫 <code>panic!</code> 巨集。如果檔案 <em>hello.txt</em> 不存在我們當前的目錄的話，我們就會執行此程式碼，接著就會看到來自 <code>panic!</code> 巨集的輸出結果：</p>
<pre><code class="language-text">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>如往常一樣，此輸出告訴我們哪裡出錯了。</p>
<h3><a class="header" href="#配對不同種的錯誤" id="配對不同種的錯誤">配對不同種的錯誤</a></h3>
<p>範例 9-4 的程式碼不管 <code>File::open</code> 爲何失敗都會呼叫 <code>panic!</code>。我們希望做的是依據不同的錯誤原因採取不同的動作，如果 <code>File::open</code> 是因爲檔案不存在的話，我們想要建立檔案並回傳新檔案的句柄。如果 <code>File::open</code> 是因爲其他原因失敗的話，像是我們沒有開啟檔案的權限，我們仍然要像範例 9-4 這樣呼叫 <code>panic!</code>。範例 9-5 就這樣對 <code>match</code> 表達式加了更多條件。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error)
            }
        },
    };
}
</code></pre>
<p><span class="caption">範例 9-5：針對不同種類的錯誤採取不同動作</span></p>
<p><code>File::open</code> 在 <code>Err</code> 變體的回傳型別爲 <code>io::Error</code>，這是標準函式庫提供的結構體。此結構體有個 <code>kind</code> 方法讓我們可以取得 <code>io::ErrorKind</code> 數值。標準函式庫提供的枚舉 <code>io::ErrorKind</code> 有從 <code>io</code> 運算可能發生的各種錯誤。我們想處理的變體是 <code>ErrorKind::NotFound</code>，這指的是我們嘗試開啟的檔案還不存在。所以我們對 <code>f</code> 配對並在用 <code>error.kind()</code> 繼續配對下去。</p>
<p>我們像從內部配對檢查 <code>error.kind()</code> 的回傳值是否是 <code>ErrorKind</code> 枚舉中的 <code>NotFound</code> 變體。如果是的話，我們就嘗試使用 <code>File::create</code> 建立檔案。不過 <code>File::create</code> 也可能會失敗，所以我們需要第二個內部 <code>match</code> 表達式來處理。如果檔案無法建立的話，我們就會印出不同的錯誤訊息。第二個分支的外部 <code>match</code> 分支保持不變，如果程式遇到其他錯誤的話就會恐慌。</p>
<p>我們用的 <code>match</code> 的確有點多！<code>match</code> 表達式雖然很實用，不過它的行爲非常基本。在第十三章你會學到閉包（closure），<code>Result&lt;T, E&gt;</code> 型別有很多接收閉包並採用 <code>match</code> 實作的方法。使用那些方法可以讓你的程式碼更簡潔。更熟練的 Rustacean 可能會像這樣寫範例 9-5 的程式數碼：</p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<p>雖然此程式碼的行爲和範例 9-5 一樣，但他沒有包含任何 <code>match</code> 表達式而且更易閱讀。當你讀完第十三章後，別忘了回來看看此範例，並查閱標準函式庫中的 <code>unwrap_or_else</code> 方法。除此方法以外，還有更多方法可以來解決處理錯誤時龐大的 <code>match</code> 表達式。</p>
<h3><a class="header" href="#錯誤發生時產生恐慌的捷徑unwrap-與-expect" id="錯誤發生時產生恐慌的捷徑unwrap-與-expect">錯誤發生時產生恐慌的捷徑：<code>unwrap</code> 與 <code>expect</code></a></h3>
<p>雖然 <code>match</code> 已經足以勝任指派的任務了，但它還是有點冗長，而且可能無法正確傳遞錯誤的嚴重性。<code>Result&lt;T, E&gt;</code> 型別有非常多的輔助方法來執行不同的任務。其中一個方法就是 <code>unwrap</code>，這是和我們在範例 9-4 所寫的 <code>match</code> 表達式一樣，擁有類似效果的捷徑方法。如果 <code>Result</code> 的值是 <code>Ok</code> 變體，<code>unwrap</code>會回傳 <code>Ok</code> 裡面的值；如果 <code>Result</code> 是 <code>Err</code> 變體的話，<code>unwrap</code> 會呼叫 <code>panic!</code> 巨集。以下是使用 <code>unwrap</code> 的方式：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>如果我們沒有 <em>hello.txt</em> 這個檔案並執行此程式碼的話，我們會看到從 <code>unwrap</code> 方法所呼叫的 <code>panic!</code> 回傳訊息：</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>還有另一個方法 <code>expect</code> 和 <code>unwrap</code> 類似，不過能讓我們選擇 <code>panic!</code> 回傳的錯誤訊息。使用 <code>expect</code> 而非 <code>unwrap</code> 並提供完善的錯誤訊息哦可以表明你的意圖，讓追蹤恐慌的源頭更容易。<code>expect</code> 的語法看起來就像這樣：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p>我們使用 <code>expect</code> 的方式和 <code>unwrap</code> 一樣，不是回傳檔案句柄就是呼叫 <code>panic!</code> 巨集。使用 <code>expect</code> 呼叫 <code>panic!</code> 時的錯誤訊息會是我們傳遞給 <code>expect</code> 的參數，而不是像 <code>unwrap</code> 使用 <code>panic!</code> 預設的訊息。訊息看起來就會像這樣：</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<p>由於此錯誤訊息指明了我們想表達的訊息「Failed to open hello.txt」，我們比較能知道此錯誤訊息是從哪裡發生的。如果我們在多處使用 <code>unwrap</code>，我們會需要一些時間才能理解 <code>unwrap</code> 是從哪裡引發恐慌的，因爲 <code>unwrap</code> 很可能會顯示相同的訊息。</p>
<h3><a class="header" href="#傳播錯誤" id="傳播錯誤">傳播錯誤</a></h3>
<p>當你在寫某函式實作時，要是它的呼叫的程式碼可能會失敗，與其直接在此函式處理錯誤，你可以回傳錯誤給呼叫此程式的程式碼，由它們絕對如何處理。這稱之爲*傳播（propagating）*錯誤並讓呼叫者可以有更多的控制權，因爲比起你程式碼當下的內容，回傳的錯誤可能提供更多資訊與邏輯以利處理。</p>
<p>舉例來說，範例 9-6 展示了一個從檔案讀取使用者名稱的函式。如果檔案不存在或無法讀取的話，此函式會回傳該錯誤給呼叫此函式的程式碼。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-6：使用 <code>match</code> 回傳錯誤給呼叫者的函式</span></p>
<p>此函式還能在更簡化，但我們要先繼續手動處理來進一步探討錯誤處理，最後我們會展示最精簡的方式。讓我們先看看此函式的回傳型別 <code>Result&lt;String, io::Error&gt;</code>。這代表此函式回傳的型別爲 <code>Result&lt;T, E&gt;</code>，而泛型型別 <code>T</code> 已經指明爲實際型別 <code>String</code> 然後泛型型別 <code>E</code> 也已經指明爲實際型別 <code>io::Error</code>。如果函式正確無誤的話，程式碼會呼叫此函式並收到擁有 <code>String</code> 的 <code>Ok</code> 數值。如果程式遇到任何問題的話，呼叫此函式的程式碼就會獲得擁有包含有關問題發生資訊的 <code>io::Error</code> 實例的 <code>Err</code> 數值。我們選擇 <code>io::Error</code> 作爲使函式的回傳值是因爲它正是 <code>File::open</code> 函式和 <code>read_to_string</code> 方法失敗時的回傳的錯誤型別。</p>
<p>函式本體從呼叫 <code>File::open</code> 開始，然後我們使用 <code>match</code> 回傳 <code>Result</code> 數值，就和範例 9-4 的 <code>match</code> 類似，但與其在 <code>Err</code> 情形時呼叫 <code>panic!</code>，我們儘早回傳 <code>File::open</code> 的錯誤型別給呼叫者。如果 <code>File::open</code> 成功的話，我們就將檔案句柄賦值給變數 <code>f</code> 並繼續執行下去。</p>
<p>接著我們在變數 <code>s</code> 建立新的 <code>String</code> 並對檔案句柄 <code>f</code> 呼叫 <code>read_to_string</code> 方法來讀取檔案內容至 <code>s</code>。<code>read_to_string</code> 也會回傳 <code>Result</code> 因爲它也可能失敗，就算 <code>File::open</code> 是執行成功的。所以我們需要另一個 <code>match</code> 來處理該 <code>Result</code>，如果 <code>read_to_string</code> 成功的話，我們的函式就是成功的，然後在 <code>Ok</code> 回傳 <code>s</code> 中該檔案的使用者名稱。如果 <code>read_to_string</code> 失敗的話，我們就像處理 <code>File::open</code> 的 <code>match</code> 一樣回傳錯誤值。不過我們不需要顯式寫出 <code>return</code>，因爲這是函式中的最後一個表達式。</p>
<p>呼叫此程式碼的程式就會需要處理包含使用者名稱的 <code>Ok</code> 數值以及包含 <code>io::Error</code> 的 <code>Err</code> 數值。我們不會知道呼叫此程式碼的人會如何處理這些數值。舉例來說，如果呼叫此程式碼而獲得錯誤的話，它可能選擇呼叫 <code>panic!</code> 讓程式崩潰，或者使用預設的使用者名稱從檔案以外的地方尋找該使用者。所以我們傳播所有成功或錯誤的資訊給呼叫者，讓它們能妥善處理。</p>
<p>這樣傳播錯誤的模式是非常常見的，所以 Rust 提供了 <code>?</code> 來簡化流程。</p>
<h4><a class="header" href="#傳播錯誤的捷徑-運算子" id="傳播錯誤的捷徑-運算子">傳播錯誤的捷徑：<code>?</code> 運算子</a></h4>
<p>範例 9-7 是另一個 <code>read_username_from_file</code>的實作，擁有和範例 9-6 一樣的效果，不過這次使用了 <code>?</code> 運算子。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-7：使用 <code>?</code> 運算子回傳錯誤給呼叫者的函式</span></p>
<p>定義在 <code>Result</code> 數值後的 <code>?</code> 運作方式幾乎與範例 9-6 的 <code>match</code> 表達式處理 <code>Result</code> 的方式一樣。如果 <code>Result</code> 的數值是 <code>Ok</code> 的話，<code>Ok</code> 內的數值就會從此表達式回傳，然後程式就會繼續執行。如果數值是 <code>Err</code> 的話，<code>Err</code> 就會使用 <code>return</code> 關鍵字作為整個函式的回傳值回傳，讓錯誤數值可以傳遞給呼叫者的程式碼。</p>
<p>不過範例 9-6 的 <code>match</code> 表達式做的事和 <code>?</code> 運算子做的事還是有不同的地方：<code>?</code> 運算子呼叫所使用的錯誤數值會傳遞到 <code>from</code> 函式中，這是定義在標準函式庫的 <code>From</code> 特徵中，用來將錯誤從一種型別轉換另一種型別。當 <code>?</code> 運算子呼叫 <code>from</code> 函式時，接收到的錯誤型別會轉換成目前函式回傳值的錯誤型別。這在當函式要回傳一個錯誤型別來代表所有函式可能的失敗是很有用的，即使可能會失敗的原因有很多種。只要每個錯誤型別都有實作 <code>from</code> 函式來將自己轉換成要回傳的錯誤型別，<code>?</code> 運算子就能自動作轉換。</p>
<p>在範例 9-7 中，在 <code>File::open</code> 的結尾中 <code>?</code> 回傳 <code>Ok</code> 中的數值給變數 <code>f</code>。如果有錯誤發生時，<code>?</code> 運算子會提早回傳整個函式並將 <code>Err</code> 的數值傳給呼叫的程式碼。同理也適用在呼叫 <code>read_to_string</code> 結尾的 <code>?</code>。</p>
<p><code>?</code> 運算子可以消除大量樣板程式碼並讓函式實作更簡單。我們還可以再進一步將方法直接串接到 <code>?</code> 後來簡化程式碼，如範例 9-8 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-8：在 <code>?</code> 運算子後方串接方法呼叫</span></p>
<p>我們將建立新 <code>String</code> 的變數 <code>s</code> 移到函式的開頭，這部分沒有任何改變。再來與建立變數 <code>f</code> 的地方不同的是，我們直接將 <code>read_to_string</code> 串接到 <code>File::open(&quot;hello.txt&quot;)?</code> 的結果後方。我們在 <code>read_to_string</code> 呼叫的結尾還是有 <code>?</code>，然後我們還是在 <code>File::open</code> 和 <code>read_to_string</code> 成功沒有失敗時，回傳包含 <code>s</code> 的 <code>Ok</code> 數值。函式達成的效果仍然與範例 9-6 與 9-7 相同。這只是一個比較不同但慣用的寫法。</p>
<p>說到此函式不同的寫法，範例 9-9 展示了另一個更短的寫法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-9：使用 <code>fs::read_to_string</code> 而不是開啟檔案後才讀取</span></p>
<p>讀取檔案至字串中算是個常見動作，所以 Rust 提供了一個方便的函式 <code>fs::read_to_string</code> 來開啟檔案、建立新的 <code>String</code>、讀取檔案內容、將內容放入該 <code>String</code> 並回傳它。不過使用 <code>fs::read_to_string</code> 就沒有機會讓我們來解釋所有的錯誤處理，所以我們一開始才用比較長的寫法。</p>
<h4><a class="header" href="#-運算子可以用在回傳-result-的函式" id="-運算子可以用在回傳-result-的函式"><code>?</code> 運算子可以用在回傳 <code>Result</code> 的函式</a></h4>
<p><code>?</code> 可以用在回傳型別為 <code>Result</code> 的函式，因為它與範例 9-6 的 <code>match</code> 表達式有相同的運作方式。<code>match</code> 的 <code>return Err(e)</code> 會要求 <code>Result</code> 作為回傳型別。所以函式回傳值也需要是 <code>Result</code> 才能與此 <code>return</code> 相容。</p>
<p>讓我們看看如果我們在 <code>main</code> 使用 <code>?</code> 運算子的話會發生什麼事情，你應該還記得此函式的回傳型別為 <code>()</code>：</p>
<pre><code class="language-rust ignore does_not_compile">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>當我們編譯此程式碼時，我們會獲得以下錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hello.txt&quot;)?;
  | |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
</code></pre>
<p>此錯誤告訴我們只能在回傳型別為 <code>Result</code> 或 <code>Option</code> 或其他有實作 <code>std::ops::Try</code> 的型別的函式才能使用 <code>?</code> 運算子。如果你寫的程式碼函式中沒有回傳任何這些型別，而你想要在呼叫回傳型別為 <code>Result&lt;T, E&gt;</code> 的函式使用 <code>?</code>，你有兩種解決辦法。第一個辦法是如果沒有任何限制阻止你的話，你可以變更你函式的回傳型別為 <code>Result&lt;T, E&gt;</code>。另一個則是依據你認為合適的情形下使用 <code>match</code> 或任何一種 <code>Result&lt;T, E&gt;</code> 的方法來處理 <code>Result&lt;T, E&gt;</code>。</p>
<p><code>main</code> 是特別的函式，所以我們必須限制它的回傳型別。其中一種 main 的有效回傳型別是 <code>()</code>，而為了方便，它還能有另一個有效回傳型別 <code>Result&lt;T, E&gt;</code>，如以下所示：</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<p><code>Box&lt;dyn Error&gt;</code> 型別使用了特徵物件（trait object）我們會在第十七章的<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">「允許不同型別數值的特徵物件」“允許不同型別數值的特徵物件”</a><!-- ignore -->討論到。現在你可以將 <code>Box&lt;dyn Error&gt;</code> 視為它是「任何種類的錯誤」。這樣 <code>main</code> 中的回傳型別就會允許 <code>?</code> 了。</p>
<p>現在我們已經討論了呼叫 <code>panic!</code> 與回傳 <code>Result</code> 的細節。現在讓我們回到何時該使用何種辦法的主題上吧。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch09-02-recoverable-errors-with-result.md">e5ed971</a></li>
<li>updated: 2020-09-14</li>
</ul>
</blockquote>
<h2><a class="header" href="#要-panic-還是不要-panic" id="要-panic-還是不要-panic">要 panic! 還是不要 panic!</a></h2>
<p>所以你該如何決定何時要呼叫 panic! 還是要回傳 Result 呢？當程式碼恐慌時，就沒有任何回復的方式。你可以在任何錯誤場合呼叫 <code>panic!</code>，無論是可能或不可能復原的情況。不過這樣你就等於替呼叫你的程式碼的呼叫者做出決定，讓情況變成無法復原的錯誤了。當你選擇回傳 <code>Result</code> 數值，你將決定權交給呼叫者的程式碼。呼叫者可能會選擇符合當下場合的方式嘗試復原錯誤，或者它可以選擇 Err 內的數值是不可回復的，所以它就呼叫 panic! 讓你原本可回復的錯誤轉成不可回復。因此，當你定義可能失敗的函式時預設回傳 Result 是不錯的選擇。</p>
<p>在少數情況下，程式碼恐慌會比回傳 Result 來得恰當。讓我們來探討為何在範例、程式碼原型與測試選擇恐慌會比較好。然後我們將討論到一種編譯器無法辨別出不可能失敗，但人類的你卻可以的情況。本章節會總結一些通用指導原則來決定何時在函式庫程式碼中恐慌。</p>
<h3><a class="header" href="#範例程式碼原型與測試" id="範例程式碼原型與測試">範例、程式碼原型與測試</a></h3>
<p>當你在寫解釋一些概念的範例時，寫出完善錯誤處理的範例，反而會讓範例變得較不清楚。在範例中，，使用像是 unwrap 這樣會恐慌的方法可以被視為是一種要求使用者自行決定如何處理錯誤的表現，因為他們可以依據程式碼執行的方式來修改此方法。</p>
<p>同樣地 unwrap 與 expect 方法也很適用在試做原型，你可以在決定準備開始處理錯誤前使用它們。它們會留下清楚的痕跡，當你準備好要讓程式碼更穩固時，你就能回來修改。</p>
<p>如果有方法在測試內失敗時，你會希望整個測試都失敗，就算該方法不是要測試的功能。因為 panic! 會將測試標記為失敗，所以在此呼叫 unwrap 或 expect 是很正確的。</p>
<h3><a class="header" href="#當你知道的比編譯器還多的時候" id="當你知道的比編譯器還多的時候">當你知道的比編譯器還多的時候</a></h3>
<p>如果你知道一些編譯器不知道的邏輯的話，直接在 Result 呼叫 unwrap 來直接取得 Ok 的數值是很有用的。你還是會有個 <code>Result</code> 數值需要做處理，你呼叫的程式碼還是有機會失敗的，就算在你的特定場合中邏輯上是不可能的。如果你能保證在親自審閱程式碼後，你絕對不可能會有 <code>Err</code> 變體的話，那麼呼叫 <code>unwrap</code> 是完全可以接受的。以下範例就是如此：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    use std::net::IpAddr;

    let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>我們傳遞寫死的字串來建立 <code>IpAddr</code> 的實例。我們可以看出 <code>127.0.0.1</code> 是完全合理的 IP 位址，所以這邊我們可以直接 <code>unwrap</code>。不過使用寫死的合理字串並不會改變 <code>parse</code> 方法的回傳型別，我們還是會取得 <code>Result</code> 數值，編譯器仍然會要我們處理 <code>Result</code> 並認爲 <code>Err</code> 變體是有可能發生的。因爲編譯器並沒有聰明到可以看出此字串是個有效的 IP 位址。如果 IP 位址的字串是來自使用者輸入而非我們寫死進程式的話，它<em>的確</em>有可能會失敗，這時我們就得要認真處理 <code>Result</code> 了。</p>
<h3><a class="header" href="#錯誤處理的指導原則" id="錯誤處理的指導原則">錯誤處理的指導原則</a></h3>
<p>當你的程式碼可能會導致嚴重狀態的話，就建議讓你的程式恐慌。這裡的嚴重狀態是指一些假設、保證、協議或不可變性被打破時的狀態，像是當你的程式碼有無效的數值、互相矛盾的數值或缺少數值。另外還加上以下情形：</p>
<ul>
<li>該嚴重狀態並非平時<em>預期</em>會發生的。</li>
<li>你的程式在此時需要避免這種嚴重狀態。</li>
<li>你所使用的型別沒有適合的方式能夠處理此嚴重狀態。</li>
</ul>
<p>如果有人呼叫了你的程式碼卻傳遞了不合理的數值，最好的辦法是呼叫 <code>panic!</code> 並警告使用你函式庫的人他們程式碼錯誤發生地位置，好讓他們在開發時就能修正。同樣地，<code>panic!</code> 也適合用於如果你呼叫了你無法掌控的外部程式碼，然後它回傳了你無法修正的無效狀態。</p>
<p>不過如果失敗是可預期的，回傳 <code>Result</code> 就會比呼叫 <code>panic!</code> 來得好。類似的例子有，語法分析器 （parser）收到格式錯誤的資訊，或是 HTTP 請求回傳了一個狀態，告訴你已經達到請求上限了。在這樣的案例，回傳 <code>Result</code> 代表失敗是預期有時會發生的，而且呼叫者必須決定如何處理。</p>
<p>當你的程式碼針對數值進行運算時，你的程式需要先驗證該數值，如果數值無效的話就要恐慌。這是基於安全原則，嘗試對無效資料做運算的話可能會導致你的程式碼產生漏洞。這也是標準函式庫在你嘗試取得超出界限的記憶體存取會呼叫 <code>panic!</code> 的主要原因。嘗試取得不屬於當前資料結構的記憶體是常見的安全問題。函式通常都會訂下一些<em>合約（contracts）</em>，它們的行爲只有在輸入資料符合特定要求時才帶有保障。當違反合約時恐慌是十分合理的，因爲違反合約就代表這是呼叫者的錯誤，這不是你的程式碼該主動處理的錯誤。事實上，呼叫者也沒有任何合理的理由來復原這樣的錯誤。函式的合約應該要寫在函式的技術文件中解釋，尤其是違反時會恐慌的情況。</p>
<p>然而要在你的函式寫一大堆錯誤檢查有時是很冗長且麻煩的。幸運的是你可以利用 Rust 的型別系統（以及編譯器的型別檢查）來幫你完成檢驗。如果你的函式用特定型別作物喔爲參數的話，你就可以認定你的程式邏輯是編輯器已經幫你確保你拿到的數值是有效的。舉例來說，如果你有個一型別而非 <code>Option</code> 的話，你的程式就會預期取得<em>某個值</em>而不是<em>沒拿到值</em>。你的程式就不必處理 <code>Some</code> 和 <code>None</code> 這兩個變體情形，它只會有一種情況並絕對會拿到數值。要是有人沒有傳遞任何值給你的函式會根本無法編譯，所以你的函式就不需要在執行時做檢查。另一個例子是使用非帶號整數像是 <code>u32</code> 來確保參數不會是負數。</p>
<h3><a class="header" href="#建立自訂型別來驗證" id="建立自訂型別來驗證">建立自訂型別來驗證</a></h3>
<p>讓我們來試著使用 Rust 的型別系統來進一步確保我們擁有有效數值，並建立自訂型別來驗證。回想一下第二章的猜謎遊戲，我們的程式碼要使用者從 1 到 100 之間猜一個數字。在開始與祕密數字做比較之前，我們從未驗證使用者輸入的值，我們只驗證了它是否爲正的。在這種情況帶來的後果還不算嚴重：我們還是會顯示「Too high」或「Too low」。但是我們可以改善這段來引導使用者輸入有效數值，並在使用者輸入時猜了超出範圍的數字或字母時呈現不同行爲。</p>
<p>我們可以將輸入的猜測分析改成 <code>i32</code> 而非 <code>u32</code> 來允許負數，並檢查數字是否在範圍內，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span>    loop {
        // --snip--

<span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;The secret number will be between 1 and 100.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
<span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span>    }
<span class="boring">}
</span></code></pre>
<p><code>if</code> 表達式檢查我們的數值是否超出範圍，如果是的話就告訴使用者問題原因，並呼叫 <code>continue</code> 來進行下一次的猜測循環，要求再猜一次。在 <code>if</code> 表達式之後我們就能用已經知道範圍是在 1 到 100 的 <code>guess</code> 與祕密數字做比較。</p>
<p>不過這並非理想解決方案：如果程式必定要求數值一定要是 1 到 100，而且我們有很多函式都有此需求的話，在每個函式都檢查就太囉唆了（而且可能會影響效能）。</p>
<p>對此我們可以建立一個新的型別，並且建立一個驗證產生實例的函式，這樣我們就不必在每個地方都做驗證。這樣一來函式就可以安全地以這個新型別作爲簽名，並放心地使用收到的數值。範例 9-10 顯示了定義 <code>Guess</code> 型別的例子，它的 <code>new</code> 函式只會在接收值爲 1 到 100 時纔會建立 <code>Guess</code> 實例。</p>
<!-- Deliberately not using rustdoc_include here; the `main` function in the
file requires the `rand` crate. We do want to include it for reader
experimentation purposes, but don't want to include it for rustdoc testing
purposes. -->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 9-10：只會擁有 1 到 100 的 <code>Guess</code> 型別</span></p>
<p>首先我們定義了一個結構體叫做 <code>Guess</code>，其欄位叫做 <code>value</code> 並會持有 <code>i32</code>。這就是數字會被儲存的地方。</p>
<p>接著我們實作一個 <code>Guess</code> 的關聯函式叫做 <code>new</code> 來建立 <code>Guess</code> 的值。<code>new</code> 函式定義的參數叫做 <code>value</code> 並擁有型別 <code>i32</code>，且最後會回傳 <code>Guess</code>。函式 <code>new</code> 本體中的程式碼會驗證 <code>value</code> 確保它位於 1 到 100 之間。如果 <code>value</code> 沒有通過驗證，我們呼叫 <code>panic!</code> 來警告呼叫此程式碼的開發者，他們可能有需要修正的程式錯誤，因爲使用超出範圍的 <code>value</code> 來建立 <code>Guess</code> 違反了 <code>Guess::new</code> 的合約。<code>Guess::new</code> 會恐慌的情況需要在公開的 API 技術文件中提及。我們會在第十四章討論如何寫出技術文件並在 API 技術文件中指出可能發生 <code>panic!</code> 的情形。如果 <code>value</code> 通過驗證的話，我們就建立一個新的 <code>Guess</code> 並將參數 <code>value</code> 賦值給 <code>value</code> 欄位，最後回傳 <code>Guess</code>。</p>
<p>接著我們實作了個方法叫做 <code>value</code>，它會借用 <code>self</code> 且沒有任何參數，並會回傳 <code>i32</code>。這種方法有時會被稱爲 <em>getter</em>，因爲它的目的是從它的欄位中取得一些資料並回傳它。此公開方法是必要的，因爲 <code>Guess</code> 結構體中的 <code>value</code> 欄位是私有的。將 <code>Guess</code> 結構體的 <code>value</code> 欄位設爲私有是很重要的，這樣就無法直接設置 <code>value</code> ，模組外的程式碼<em>必須</em>使用 <code>Guess::new</code> 函式來建立 <code>Guess</code> 的實例，因而確保 <code>Guess</code> 不可能會有沒有經過 <code>Guess::new</code> 函式驗證的 <code>value</code>。</p>
<p>這樣當函式的參數或回傳值只能是數字 1 到 100 的話，它的簽名就能使用或回傳 <code>Guess</code> 而不是 <code>i32</code>，因此就不必在它的本體內做任何額外檢查。</p>
<h2><a class="header" href="#總結-7" id="總結-7">總結</a></h2>
<p>Rust 的錯誤檢查功能的設計旨在協助你寫出可靠的程式碼。<code>panic!</code> 巨集告訴你的程式遇到了它無法處理的狀態，並讓你告訴程序停止，而不是繼續嘗試使用無效或不正確的數值。<code>Result</code> 枚舉使用 Rust 的型別系統來指出可能會失敗的運算，並讓你的程式碼有辦法回復。你可以使用 <code>Result</code> 來告訴使用你的程式碼的呼叫者，他們需要處理可能成功與失敗的情形。在適當的場合使用 <code>panic!</code> 與 <code>Result</code> 能讓你的程式碼在不可避免的問題中更加可靠。</p>
<p>現在你已經看過標準函式庫中 <code>Option</code> 與 <code>Result</code> 使用泛型的優勢了，就讓我們來討論泛型如何運作的，以及你如何在程式碼中使用它們。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch09-03-to-panic-or-not-to-panic.md">e5ed971</a></li>
<li>updated: 2020-09-14</li>
</ul>
</blockquote>
<h1><a class="header" href="#泛型型別特徵與生命週期" id="泛型型別特徵與生命週期">泛型型別、特徵與生命週期</a></h1>
<p>每個程式語言都有能夠高效處理概念複製的工具。在 Rust 此工具就是<em>泛型（generics）</em>。泛型是實際型別或其他屬性的抽象替代。當我們在寫程式碼時，我們可以表達泛型的行爲，或是它們與其他泛型有何關聯，而不必在編譯與執行程式時知道它們實際上是什麼。</p>
<p>和函式有辦法能接收多種未知數值作爲參數來執行相同程式碼，函式可以接受一些泛型型別參數，而不是實際型別像是 <code>i32</code> 或 <code>String</code>。事實上我們已經在第六章的 <code>Option&lt;T&gt;</code>、第八章的 <code>Vec&lt;T&gt;</code> 和 <code>HashMap&lt;K, V&gt;</code> 以及第九章的 <code>Result&lt;T, E&gt;</code> 使用過泛型了。在本章節，你將會探索如何用泛型定義你自己的型別、函式與方法！</p>
<p>首先我們會先檢視如何提取參數來減少重複的程式碼。接著我們會以相同的技巧使用泛型將兩個只有參數型別不同的函式轉變成泛型函式。我們還會解釋如何在結構體和枚舉使用泛型型別。</p>
<p>再來你會學會如何使用*特徵（traits）*來定義共同行爲。你可以組合特徵與泛型型別來限制泛型型別只適用在有特定行爲的型別，而不是任意型別。</p>
<p>最後我們會來介紹<em>生命週期（lifetimes）</em>，一種能讓編譯器知道引用如何互相關聯的泛型。生命週期讓我們能在許多情況下借用數值，同時能確保編譯器會檢查這些引用是有效的。</p>
<h2><a class="header" href="#提取函數來減少重複性" id="提取函數來減少重複性">提取函數來減少重複性</a></h2>
<p>在我們深入泛型語法之前，讓我門先來看如何不用泛型型別的情況下，用提取函式的方式減少重複的程式碼。之後我們就會用此方式來提取泛型函式！和你透過找出重複的程式碼來提取程式一樣，你也將找出重複的函式來轉成泛型。</p>
<p>讓我們考慮一支尋找列表中最大數字的小城市，如範例 10-1 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
<span class="boring">    assert_eq!(largest, 100);
</span>}
</code></pre></pre>
<p><span class="caption">範例 10-1：在數字列表中尋找最大數字的程式碼</span></p>
<p>此程式碼儲存整數列表到變數 <code>number_list</code> 並將列表第一個數字放入變數 <code>largest</code>。接著他會遍歷列表中的所有元素，如果目前數字比 <code>largest</code> 內儲存的數字還大的話，它就會替代成該變數的值。.不過如果目前數值小於或等於最大值的話，變數就不會被改變，程式會接續檢查列表中的下一個數字。在考慮完列表中的所有數字後，<code>largest</code> 就應該會拿到最大數字，在此例就是 100。</p>
<p>要從兩個不同的數字列表中找到最大值的話，我們可以重複範例 10-1 的程式碼，然後在程式中兩個不同的地方使用相同的邏輯，如範例 10-2 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">範例 10-2：在<em>兩個</em>數字列表中尋找最大值</span></p>
<p>雖然這樣的程式碼能執行，寫出重複的程式碼很囉唆而且容易出錯。我們可以每次變更此程式碼時就得更新程式碼中許多地方。</p>
<p>要去除重複的部分，我們可以建立一層抽象，定義一個可以處理任意整數列表作爲參數的函式。這樣的解決辦法讓我們的程式更清晰，而且讓我們能抽象表達出從列表中尋找最大值這樣的概念。</p>
<p>在範例 10-3 我們提取了尋找最大值的程式碼成一個函式叫做 <code>largest</code>。不像範例 10-1 只能從特定列表尋找最大值，此程式可以從兩個不同的列表尋找最大值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(result, &amp;100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(result, &amp;6000);
</span>}
</code></pre></pre>
<p><span class="caption">範例 10-3：抽象出尋找最大值的概念並用在兩個不同的列表</span></p>
<p><code>largest</code> 函式有個參數 <code>list</code> 可以代表我們傳遞給函式的 <code>i32</code> 型別 slice。所以當我們呼叫此函式時，程式可以依據我們傳入的特定數值執行。</p>
<p>總結來說，以下是我們將範例 10-2 的程式碼轉換成範例 10-3 的步驟：</p>
<ol>
<li>找出重複的程式碼。</li>
<li>將重複的程式碼提取置函式本體內，並指定函式簽名輸入與回傳數值。</li>
<li>更新重複使用程式碼的實例，改呼叫我們定義的函式。</li>
</ol>
<p>接我們將以相同的步驟來使用泛型來減少重複的程式碼。就像函式本體可以抽象出 <code>list</code> 而不用特定數值，泛型允許程式碼執行抽象型別。</p>
<p>舉例來說，假數我們有兩個函式：一個會找出 <code>i32</code> 型別 slice 中的最大值而另一個會找出 <code>char</code> 型別 slice 的最大值。我們要如何刪除重複的部分呢？讓我們拭目以待！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch10-00-generics.md">e5ed971</a></li>
<li>updated: 2020-09-14</li>
</ul>
</blockquote>
<h2><a class="header" href="#泛型資料型別" id="泛型資料型別">泛型資料型別</a></h2>
<p>我們可以使用泛型（generics）來建立項目的定義，像是函式簽名或結構體，讓我們在之後可以使用在不同的實際資料型別。讓我們先看看如何使用泛型定義函式、枚舉與方法。然後我們會在來看泛型對程式碼的效能影響如何。</p>
<h3><a class="header" href="#在函式中定義" id="在函式中定義">在函式中定義</a></h3>
<p>當要使用泛型定義函數時，我們通常會將泛型置於函式簽名中指定參數與回傳值資料型別的位置。照樣做能讓我們的程式碼更具彈性並向呼叫者提供更多功能，同時還能防止重複程式碼。</p>
<p>接續我們 <code>largest</code> 函式的例子，範例 10-4 展示了兩個都在 slice 上尋找最大值的函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; &amp;char {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">    assert_eq!(result, &amp;100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
<span class="boring">    assert_eq!(result, &amp;'y');
</span>}
</code></pre></pre>
<p><span class="caption">範例 10-4：兩個名稱與其簽名中的型別都不同的函式</span></p>
<p><code>largest_i32</code> 函式和我們在範例 10-3 提取的函式一樣都是尋找 slice 中最大的 <code>i32</code>。而 <code>largest_char</code> 函式則尋找 slice 中最大的 <code>char</code>。函式本體都擁有相同的程式碼，讓我以讓我們來開始用泛型型別參數來消除重複的部分，轉變成只有一個函式吧。</p>
<p>要在我們新定義的函式中參數化型別的話，我們需要爲參數型別命名，就和我們在函式中的參數數值所做的一樣。你可以用任何標識符來命名型別參數名稱。但我們習慣上會用 <code>T</code>，因爲 Rust 的參數名稱都盡量很短，常常只會有一個字母，而且 Rust 對於型別命名的慣用規則是駝峰式大小寫（CamelCase）。所以 <code>T</code> 作爲「type」的簡稱是大多數 Rust 程式設計師的選擇。</p>
<p>當我們在函式本體使用參數時，我們必須在簽名中宣告參數名稱，編譯器才能之當該名稱代表什麼。同樣地，當我們要在函式簽名中使用型別參數名稱，我們必須在使用前宣告該型別參數名稱。要定義泛型 <code>largest</code> 函式的話，我們在函式名稱與參數列表之間加上尖括號，其內就是型別名稱的宣告，如以下所示：</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
</code></pre>
<p>我們可以這樣理解定義：函式 <code>largest</code> 有泛型型別 <code>T</code>，此函式有一個參數叫做 <code>list</code>，他的型別爲數值 <code>T</code> 的 slice。<code>largest</code> 函式會回傳與型別 <code>T</code> 相同型別的值。</p>
<p>範例 10-5 顯示了使用泛型資料型別於函式簽名組合出的 <code>largest</code> 函式。此範例還展示了我們如何依序用 <code>i32</code> 和 <code>cahr</code> 的 slice 呼叫函式。注意此程式碼尚未能編譯，不過我們會在本章之後修改它。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {
    let mut largest = &amp;list[0];

    for item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">範例 10-5：使用函式型別參數定義的 <code>largest</code> 函式，但現在還不能編譯</span></p>
<p>如果我們現在就編譯程式碼的話，我們會得到此錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>註釋中提到了 <code>std::cmp::PartialOrd</code> 這個<em>特徵（trait）</em>。我們會在下個段落來討論特徵。現在此錯誤告訴我們 <code>largest</code> 本體無法適用於所有可能的 <code>T</code> 型別，因爲我們想要在本體中比較型別 <code>T</code> 的數值，我們只能在能夠排序的型別中做比較。要能夠比較的話，標準函式庫有提供 <code>std::cmp::PartialOrd</code> 特徵讓你可以針對你的型別來實作（請查閱附錄 C 來瞭解更多此特徵的細節）。你會在<a href="ch10-02-traits.html#traits-as-parameters">「特徵作爲參數」</a><!-- ignore -->的段落學習到如何指定特定泛型型別擁有特定特徵。不過先讓先我們探索其他泛型型別參數使用的方式。</p>
<h3><a class="header" href="#在結構體中定義" id="在結構體中定義">在結構體中定義</a></h3>
<p>我們一樣能以 <code>&lt;&gt;</code> 語法來對結構體中一或多個欄位使用泛型型別參數。範例 10-6 顯示了如何定義 <code>Point&lt;T&gt;</code> 結構體並讓 <code>x</code> 與 <code>y</code> 可以是任意型別數值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">範例 10-6：<code>Point&lt;T&gt;</code> 結構體的 <code>x</code> 與 <code>y</code> 會有型別 <code>T</code> 的數值</span></p>
<p>在結構體定義使用泛型的語法與函式定義類似。首先，我們在結構體名稱後方加上尖括號，並在其內宣告型別參數名稱。接著我們能在原本指定實際資料型別的地方，使用泛型型別來定義結構體。</p>
<p>注意到我們使用了一個泛型型別來定義 <code>Point&lt;T&gt;</code>，此定義代表 <code>Point&lt;T&gt;</code> 是某型別 <code>T</code> 下之通用的，而且欄位 <code>x</code> 與 <code>y</code> 擁有<em>相同</em>型別，無論最終是何種型別。如果我們用不同的型別數值來建立 <code>Point&lt;T&gt;</code> 實例，我們的程式碼會無法編譯，如範例 10-7 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">範例 10-7：欄位 <code>x</code> 與 <code>y</code> 必須是相同型別，因爲它們擁有相同的泛型資料型別 <code>T</code></span></p>
<p>在此例中，當我們賦值 5 給 <code>x</code> 時，我們讓編譯器知道 <code>Point&lt;T&gt;</code> 實例中的泛型型別 <code>T</code> 會是整數。然後我們將 4.0 賦值給 <code>y</code>，這應該要和 <code>x</code> 有相同型別，所以我們會獲得以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>要將結構體 <code>Point</code> 的 <code>x</code> 與 <code>y</code> 定義成擁有不同型別確仍然是泛型的話，我們可以使用多個泛型型別參數。舉例來說，在範例 10-8 我們改變了 <code>Point</code> 的定義爲擁有兩個泛型型別 <code>T</code> 與 <code>U</code>，<code>x</code> 擁有型別 <code>T</code> 而 <code>y</code> 擁有型別 <code>U</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">範例 10-8：<code>Point&lt;T, U&gt;</code> 擁有兩個泛型惜別，所以 <code>x</code> 和 <code>y</code> 可以有不同的型別數值</span></p>
<p>現在這些所有的 <code>Point</code> 實例都是允許的了！你要在定義中使用多少泛型型別參數都沒問題，但用太多的話會讓你的程式碼難以閱讀。當你的程式碼需要使用大量泛型的話，通常代表你的程式碼需要重新組織成更小的元件。</p>
<h3><a class="header" href="#在枚舉中定義" id="在枚舉中定義">在枚舉中定義</a></h3>
<p>如同結構體一樣，我們可以定義枚舉讓它們的變體擁有泛型資料型別。讓我們看看我們在第六章標準函式庫提供的 <code>Option&lt;T&gt;</code> 枚舉：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>此定義現在對你來說應該就說的通了。如同你所看到的 <code>Option&lt;T&gt;</code> 枚舉有個泛型型別參數 <code>T</code> 以及兩個變體：<code>Some</code> 擁有型別 <code>T</code> 的數值；而 <code>None</code> 則是不具任何數值的變體。使用 <code>Option&lt;T&gt;</code> 枚舉我們可以表達出一個可能擁有的數值這樣的抽象概念。而且因爲 <code>Option&lt;T&gt;</code> 是泛型，不管可能的數值型別爲何，我們都能使用此抽象。</p>
<p>枚舉也能有數個泛型型別。我們在第九章所使用枚舉 <code>Result</code> 的定義就是個例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Result</code> 枚舉有兩個泛型型別 <code>T</code> 和 <code>E</code> 且有兩個變體：<code>Ok</code> 擁有型別 <code>T</code> 的數值；而 <code>Err</code> 擁有型別 <code>E</code> 的數值。這樣的定義讓我們很方便能表達 <code>Result</code> 枚舉可能擁有一個成功的數值（返回型別 <code>T</code> 的數值）或失敗的數值（回傳型別爲 <code>E</code> 的錯誤值）。事實上這就是我們在範例 9-3 開啓檔案的方式，當我們成功開啟檔案時的 <code>T</code> 就會是型別 <code>std::fs::File</code>，然後當開啟檔案會發生問題時 <code>E</code> 就會是型別 <code>std::io::Error</code>。</p>
<p>當你發現你的程式碼有許多結構體或枚舉都只有儲存的值有所不同時，你可以使用泛型行別來避免重複。</p>
<h3><a class="header" href="#在方法中定義" id="在方法中定義">在方法中定義</a></h3>
<p>我們可以對結構體或枚舉定義方法（如第五章所述）並也可以使用泛型型別來定義。範例 10-9 展示了我們在範例 10-6 定義的結構體 <code>Point&lt;T&gt;</code> 並實作了一個叫做 <code>x</code> 的方法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">範例 10-9：在 <code>Point&lt;T&gt;</code> 結構體實作一個方法叫叫做 <code>x</code>，其會回傳 <code>x</code> 欄位中型別爲 <code>T</code> 的引用</span></p>
<p>我們在這 <code>Point&lt;T&gt;</code> 定義了一個方法叫做 <code>x</code> 並回傳欄位 <code>x</code> 的資料引用。</p>
<p>注意到我們需要在 <code>impl</code> 宣告 <code>T</code>，這樣才代表我們指的是在型別 <code>Point&lt;T&gt;</code> 實作方法。在 <code>impl</code> 之後宣告泛型型別 <code>T</code>，Rust 可以識別出 <code>Point</code> 尖括號內的型別爲泛型型別而非實際型別。</p>
<p>舉例來說，我們可以只針對 <code>Point&lt;f32&gt;</code> 的實例來實作方法，而非適用於任何泛型型別的 <code>Point&lt;T&gt;</code> 實例。在範例 10-10 我們使用了實例型別 <code>f32</code> 而沒有在 <code>impl</code> 宣告任何型別。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-10：一個只適用於擁有泛型 <code>T</code> 結構體其中的特定實際型別的 <code>impl</code> 區塊</span></p>
<p>此程式碼代表 <code>Point&lt;f32&gt;</code> 會有個方法叫做 <code>distance_from_origin</code> 但其他 <code>Point&lt;T&gt;</code> 只要 <code>T</code> 不是型別 <code>f32</code> 的實例都不會定義此方法。此方法測量我們的點距離座標 (0.0, 0.0) 有多遠並使用只有浮點數型別能使用的數學運算。</p>
<p>在結構體定義中的泛型型別參數不總會是和結構體方法簽名中的會是相同型別。舉例來說，範例 10-11 在範例 10-8 的 <code>Point&lt;T, U&gt;</code> 定義了一個方法 <code>mixup</code>。該方法會取得另一個 <code>Point</code> 作爲參數，不過其可能會與我們噓覺的 <code>mixup</code> 方法中<code>self</code> <code>Point</code> 的型別有所相異。此方法使用 <code>self</code> 的 <code>Point</code>（型別爲 <code>T</code>）的 <code>x</code> 值與由參數傳進來的 <code>Point</code>（型別爲 <code>W</code>）的 <code>y</code> 值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">範例 10-11：結構體定義中使用不同的泛型型別的方法</span></p>
<p>在 <code>main</code> 中，我們定義了一個 <code>Point</code>，其 <code>x</code> 型別爲 <code>i32</code>（數值爲 <code>5</code>），<code>y</code> 型別爲 <code>f64</code>（數值爲 <code>10.4</code>）。變數 <code>p2</code> 是個 <code>Point</code> 結構體，<code>x</code> 爲字串 slice（數值爲 <code>&quot;Hello&quot;</code>），<code>y</code> 爲 <code>char</code>（數值爲 <code>c</code>）。在 <code>p1</code> 呼叫 <code>mixup</code> 並加上引數 <code>p2</code> 的話會給我們 <code>p3</code>，它的 <code>x</code> 會有型別 <code>i32</code>，因爲 <code>x</code> 來自 <code>p1</code>。而且變數 <code>p3</code> 還會有型別爲 <code>char</code> 的 <code>y</code>，因爲 <code>y</code> 來自 <code>p2</code>。<code>println!</code> 巨集的呼叫就會顯示 <code>p3.x = 5, p3.y = c</code>。</p>
<p>此例是是爲了展示一些泛型參數是透過 <code>impl</code> 宣告而有些則是透過方法定義來得。在此，泛型參數 <code>T</code> 和 <code>U</code> 是宣告在 <code>impl</code> 之後，因爲它們與結構體定義有關聯。而在 <code>fn mixup</code> 之後宣告的泛型參數只和該方法有關。</p>
<h3><a class="header" href="#使用泛型的程式碼效能" id="使用泛型的程式碼效能">使用泛型的程式碼效能</a></h3>
<p>你可能會好奇當你使用泛型型別參數會不會有執行時的消耗。好消息是 Rust 實作泛型的方式讓你使用泛型的的程式碼跑得不會比使用實際型別還來的慢。</p>
<p>Rust 在編譯時對使用泛型的程式碼進行單態化（monomorphization）。<em>單態化</em>是個讓泛型程式碼轉換成特定程式碼的過程，在編譯時填入實際的型別。</p>
<p>在此過程中，編譯器會做與我們在範例 10-5 建立泛型函式相反的事：編譯器檢查所有泛型程式碼被呼叫的地方，並依據泛型程式碼被呼叫的情況產生實際型別的程式碼。</p>
<p>讓我們看看這在標準函式庫的枚舉 <code>Option&lt;T&gt;</code> 中是怎麼做到的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>當 Rust 編譯此程式碼時中，他會進行單態話。在此過程中，會讀取 <code>Option&lt;T&gt;</code> 實例中使用的數值並識別出兩種 <code>Option&lt;T&gt;</code>：一種是 <code>i32</code> 而另一種是 <code>f64</code>。接著它就會將 <code>Option&lt;T&gt;</code> 的泛型定義展開爲 <code>Option_i32</code> 和 <code>Option_f64</code>，以此替換函式定義爲特定型別。</p>
<p>單態化的版本看起來會像這樣，泛型 <code>Option&lt;T&gt;</code> 會被替換成編譯器定義的特定定義：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>因爲 Rust 會編譯泛型程式碼成個別實例的特定型別，我們使用泛型就不會造成任何執行時消耗。當程式執行時，它就會和我們親自寫重複定義的版本一樣。單態化的過程讓 Rust 的泛型在執行時十分有效率。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch10-01-syntax.md">e5ed971</a></li>
<li>updated: 2020-09-14</li>
</ul>
</blockquote>
<h2><a class="header" href="#特徵定義共同行爲" id="特徵定義共同行爲">特徵：定義共同行爲</a></h2>
<p>*特徵（trait）*會告訴 Rust 編譯器特定型能與其他型別共享的功能。我們可以使用特徵定義來抽象出共同行爲。我們可以使用特徵界限（trait bounds）來指定泛型爲擁有特定行爲的任意型態。</p>
<blockquote>
<p>注意：特徵類似於其他語言常稱作*介面（interfaces）*的功能，但還是有些差異。</p>
</blockquote>
<h3><a class="header" href="#定義特徵" id="定義特徵">定義特徵</a></h3>
<p>一個型別的行爲包含我們對該型別可以呼叫的方法。如果我們可以對不同型別呼叫相同的方法，這些型別就能定義共同行爲了。特徵定義是一個將方法簽名統整起來，來達成一些目的而定義一系列行爲的方法。</p>
<p>舉例來說，如果我們有數個結構體各自擁有不同種類與不同數量的文字：結構體 <code>NewsArticle</code> 儲存特定地點的新聞故事，然後 <code>Tweet</code> 則有最多 280 字元的內容，且有個欄位來判斷是全新的推文、轉推或其他推文的回覆。</p>
<p>我們想要建立個多媒體資料庫來顯示可能存在 <code>NewsArticle</code> 或 <code>Tweet</code> 實例的資料總結。要達成此目的的話，我們需要每個型別的總結，且我們需要呼該要該實例的 <code>summarize</code> 方法來索取總結。範例 10-12 顯示了表達此行爲的 <code>Summary</code> 特徵定義。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-12：<code>Summary</code> 特徵包含 <code>summarize</code> 方法所定義的行爲</span></p>
<p>我們在此使用 <code>trait</code> 關鍵字定義一個特徵，其名稱爲 <code>Summary</code>。在大括號中，我們宣告方法簽名來描述有實作此特徵的型別行爲，在此例就是 <code>fn summarize(&amp;self) -&gt; String</code>。</p>
<p>在方法簽名之後，我們並沒有加上大括號提供實作細節，而是使用分號。每個有實作此特徵的型別必須提供其自訂行爲的方法本體。編譯器會強制要求任何有 <code>Summary</code> 特徵的型別都要有定義相同簽名的 <code>summarize</code> 方法。</p>
<p>特徵本體中可以有多個方法，每行會有一個方法簽名並都以分號做結尾。</p>
<h3><a class="header" href="#爲型別實作特徵" id="爲型別實作特徵">爲型別實作特徵</a></h3>
<p>現在我們已經用 <code>Summary</code> 特徵定義了所需的行爲。我們可以在我們多媒體資料庫的型別中實作它。範例 10-13 顯示了 <code>NewsArticle</code> 結構體實作 <code>Summary</code> 特徵的方式，其使用頭條、作者、位置來建立 <code>summerize</code> 的回傳值。至於結構體 <code>Tweet</code>，我們使用使用者名稱加上整個推文的文字來定義 <code>summarize</code>，因爲推文的內容長度已經被限制在 280 個字元以內了。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-13：在型別 <code>NewsArticle</code> 與 <code>Tweet</code> 實作 <code>Summary</code> 特徵</span></p>
<p>爲一個型別實作一個特徵類似於實作一般的方法。不同的地方在於在 <code>impl</code> 之後我們加上的是想要實作的特徵，然後在用 <code>for</code> 關鍵字加上我們想要實作特徵的型別名稱。在 <code>impl</code> 的區塊內我們置入該特徵所定義的方法簽名，我們使用大括號並填入方法本體來爲對特定型別實作出特徵方法的指定行爲。</p>
<p>在實作完後，我們就能像呼叫正常方法一樣，來呼叫 <code>NewsArticle</code> 和 <code>Tweet</code> 實例的方法，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>此程式碼會印出「1 new tweet: horse_ebooks: of course, as you probably already
know, people」。</p>
<p>注意到因爲我們將範例 10-13 的 <code>Summary</code> 特徵、<code>NewsArticle</code> 和 <code>Tweet</code> 型別都定義在 <em>lib.rs</em> ，所以它們都在同個作用域下。如果我們說此 <em>lib.rs</em> 對應的 crate 叫做 <code>aggregator</code>，然後有人想要使用我們 crate 的功能來對他們函式庫作用域中定義的結構體實作 <code>Summary</code> 特徵的話。他們會需要將該特徵引入作用域，可以像這樣指定 <code>use aggregator::Summary;</code>，如此一來就能對他們的型別實作 <code>Summary</code>。<code>Summary</code> 特徵一樣也必須是公開的才能讓其他 crate 使用。這就是爲何我們在範例 10-12 的 <code>trait</code> 前面就加上 <code>pub</code> 關鍵字。</p>
<p>實作特徵時有一個限制，那就是我們只能在該特徵或該型別位於我們的 crate 時，才能對型別實作特徵。舉例來說我們可以對自訂型別像是 <code>Tweet</code> 來實作標準函式庫的 <code>Display</code> 特徵來爲我們 crate <code>aggregator</code> 增加更多功能。因爲 <code>Tweet</code> 位於我們的 <code>aggregator</code> crate 裡面。我們也可以在我們的 crate <code>aggregator</code> 內對 <code>Vec&lt;T&gt;</code> 實作 <code>Summary</code>。因爲特徵 <code>Summary</code> 也位於我們的 <code>aggregator</code> crate 裡面。</p>
<p>但是我們無法對外部型別實作外部特徵。舉例來說我們無法在我們的 <code>aggregator</code> crate 裡面對 <code>Vec&lt;T&gt;</code> 實作 <code>Display</code> 特徵。因爲 <code>Display</code> 與 <code>Vec&lt;T&gt;</code> 都定義在表準函式庫中，並沒有在我們 <code>aggregator</code> crate 裡面。此限制叫做「連貫性（coherence）」是程式屬性的一部分。更具體來說我們會稱作「孤兒原則（orphan rule）」，因爲上一代（parent）型別不存這在。此原則能確保其他人的程式碼不會破壞你的程式碼，反之亦然。沒有此原則的話，兩個 crate 可以都對相同型別實作相同特徵，然後 Rust 就會不知道該用哪個實作。</p>
<h3><a class="header" href="#預設實作" id="預設實作">預設實作</a></h3>
<p>有時候對特徵內的一些或所有方法定義預設行爲是很實用的，而不必要求每個型別都實作所有方法。然後當我們對特定型別實作特徵時，我們可以保留或覆蓋每個方法的預設行爲。</p>
<p>範例 10-14 展示如何在 <code>Summary</code> 特徵內指定  <code>summarize</code> 方法的預設字串，而不必像範例 10-12 只定義了方法簽名。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-14：<code>Summary</code> 特徵定義了 <code>summarize</code> 方法的預設實作</span></p>
<p>要使用預設實作來總結 <code>NewsArticle</code> 而不是定義自訂實作的話，我們可以指定一個空的 <code>impl</code> 區塊，像是 <code>impl Summary for NewsArticle {}</code>。</p>
<p>我們沒有直接對 <code>NewsArticle</code> 定義 <code>summarize</code> 方法，因爲我們使用的是預設實作並聲明對 <code>NewsArticle</code> 實作 <code>Summary</code> 特徵。所以最後我們仍然能在 <code>NewsArticle</code> 實例中呼叫 <code>summarize</code>，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>此程式碼會印出 <code>New article available! (Read more...)</code>。</p>
<p>建立 <code>summarize</code> 的預設實作不會影響範例 10-13 中 <code>Tweet</code> 實作的 <code>Summary</code>。因爲要取代預設射實作的語法，與當沒有預設實作時實作特徵方法的語法是一樣的。</p>
<p>預設實作也能呼叫同特徵中的其他方法，就算那些方法沒有預設實作。這樣一來，特徵就可以提供一堆實用的功能，並要求實作者只需處理一小部分就好。舉例來說，我們可以定義 <code>Summary</code> 特徵，使其擁有一個必須要實作的<code>summarize_author</code> 方法，以及另一個擁有預設實作會呼叫 <code>summarize_author</code> 的方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>要使用這個版本的 <code>Summary</code>，我們只需要在對型別實作特徵時定義 <code>summarize_author</code> 就好：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>在我們定義 <code>summarize_author</code> 之後，我們可以在結構體 <code>Tweet</code> 的實例呼叫 <code>summarize</code>，然後 <code>summarize</code> 的預設實作會呼叫我們提供的 <code>summarize_author</code>。因爲我們已經定義了<code>summarize_author</code>，且 <code>Summary</code> 特徵有提供 <code>summarize</code> 方法的預設實作，所以我們不必在寫任何程式碼。</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>此程式碼會印出 <code>1 new tweet: (Read more from @horse_ebooks...)</code>。</p>
<p>注意要是有對相同方法覆寫實作的話，就無法呼叫預設實作。</p>
<h3><a class="header" href="#特徵作爲參數" id="特徵作爲參數">特徵作爲參數</a></h3>
<p>現在你知道如何定義與實作特徵，我們可以來探討如何使用特徵來定義函式來接受多種不同的型別。</p>
<p>舉例來說，在範例 10-13 我們對 <code>NewsArticle</code> 與 <code>Tweet</code> 實作了 <code>Summary</code> 特徵。我們可以定義一個函式 <code>notify</code> 使用它自己的參數 <code>item</code> 來呼叫 <code>summarize</code> 方法，所以此參數的型別預期有實作 <code>Summary</code> 特徵。
爲此我們可以使用 <code>impl Trait</code> 語法，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>與其在 <code>item</code> 參數指定實際型別，我們用的是 <code>impl</code> 關鍵字並加上特徵名稱。這樣此參數就會接受任何有實作指定特徵的型別。在 <code>notify</code> 本體中我們就可以用 <code>item</code> 呼叫 <code>Summary</code> 特徵的任何方法，像是 <code>summarize</code>。我們可以呼叫 <code>notify</code> 並傳遞任何 <code>NewsArticle</code> 或 <code>Tweet</code> 的實例。但如果用其他型別像是 <code>String</code> 或 <code>i32</code> 來呼叫此程式碼的話會無法編譯，因爲那些型別沒有實作 <code>Summary</code>。</p>
<h4><a class="header" href="#特徵界限語法" id="特徵界限語法">特徵界限語法</a></h4>
<p><code>impl Trait</code> 語法看起來很直觀，不過它其實是一個更長格式的語法糖，這個格式稱之爲「特徵界限（trait bound）」，它長得會像這樣：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>此格式等同於之前段落的範例，只是比較長一點。我們將特徵界限置於泛型型別參數的宣告中，在尖括號內接在冒號之後。</p>
<p><code>impl Trait</code> 語法比較方便，而且在簡單的案例中可以讓程式碼比較簡潔；特徵界限語法則適合用於其他比較複雜的案例。舉例來說我們可以有兩個有實作 <code>Summary</code> 的參數，使用 <code>impl Trait</code> 語法看起來會像這樣：</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>如果我們想要此函式允許 <code>item1</code> 和 <code>item2</code> 是不同型別的話，使用 <code>impl Trait</code> 的確是正確的（只要它們都有實作 <code>Summary</code>）。不過如果我們希望兩個參數都是同一型別的話，我們就得使用特徵界限來表達，如以下所示：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p>泛型型別 <code>T</code> 作爲 <code>item1</code> 和 <code>item2</code> 的參數會限制函式，讓傳遞給 <code>item1</code> 和 <code>item2</code> 參數的數值型別必須相同。</p>
<h4><a class="header" href="#透過--來指定多個特徵界限" id="透過--來指定多個特徵界限">透過 <code>+</code> 來指定多個特徵界限</a></h4>
<p>我們也可以指定不只一個特徵界限。假設我們還想要 <code>notify</code> 中的 <code>item</code> 不只能夠呼叫 <code>summarize</code> 方法，還能顯示格式化訊息的話，我們可以在 <code>notify</code> 定義中指定 <code>item</code> 必須同時要有 <code>Display</code> 和
<code>Summary</code>。這可以使用 <code>+</code> 語法來達成：</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p><code>+</code> 也能用在泛型型別的特徵界限中：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>有了這兩個特徵界限，<code>notify</code> 本體就能呼叫 <code>summarize</code> 以及使用 <code>{}</code> 來格式化 <code>item</code>。</p>
<h4><a class="header" href="#透過-where-來使特徵界限更清楚" id="透過-where-來使特徵界限更清楚">透過 <code>where</code> 來使特徵界限更清楚</a></h4>
<p>使用太多特徵界限也會帶來壞處。每個泛型都有自己的特徵界限，所以有數個泛型型別的函式可以在函式名稱與參數列表之間包含大量的特徵界限資訊，讓函式簽名難以閱讀。因此 Rust 有提供另一個在函式簽名之後指定特徵界限的語法 <code>where</code>。所以與其這樣寫：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p>我們可以這樣寫 <code>where</code> 的語法，如以下所示：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>此函式簽名就沒有這麼複雜了，函式名稱、參數列表與回傳型別能靠得比較近，就像沒有一堆特徵界限的函式一樣。</p>
<h3><a class="header" href="#返回有實作特徵的型別" id="返回有實作特徵的型別">返回有實作特徵的型別</a></h3>
<p>我們也能在回傳的位置使用 <code>impl Trait</code> 語法來回傳某個有實作特徵的型別數值，如以下所示：</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p>將 <code>impl Summary</code> 作爲回傳型別的同時，我們在函式 <code>returns_summarizable</code> 指定回傳有實作 <code>Summary</code> 特徵的型別而不必指出實際型別。在此例中，<code>returns_summarizable</code> 回傳 <code>Tweet</code>，但呼叫此函式的程式碼不會知道。</p>
<p>回傳一個只有指定所需實作特徵的型別的能力在閉包（closures）與疊代器（iterators）中非常有用，我們會在第十三章介紹它們。閉包與疊代器能建立只有編譯器知道的型別，或是太長而難以指定的型別。<code>impl Trait</code> 語法允許你不用寫出很長的型別，而是只要指定函數會回傳有實作 <code>Iterator</code> 特徵的型別就好。</p>
<p>然而如果你使用 <code>impl Trait</code> 的話，你就只能回傳單一型別。舉例來說此程式碼指定回傳型別爲 <code>impl Summary</code> ，但是寫說可能會回傳 <code>NewsArticle</code> 或 <code>Tweet</code> 的話就會無法執行：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<p>寫說可能返回 <code>NewsArticle</code> 或 <code>Tweet</code> 的話是不被允許的，因爲 <code>impl Trait</code> 語法會限制在編譯器中最終決定的型別。我們會在第十七章的<a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">「允許不同型別數值的特徵物件」</a><!-- ignore -->來討論如何寫出這種行爲的函式。</p>
<h3><a class="header" href="#透過特徵界限修正-largest-函式" id="透過特徵界限修正-largest-函式">透過特徵界限修正 <code>largest</code> 函式</a></h3>
<p>現在你既然已經知道如何使用泛型型別參數來指定你想使用的行爲，就讓我們回到範例 10-5 來使用泛型型別參數來修正 <code>largest</code> 函式的定義吧！上次我們試著執行此程式時，我們獲得這樣的錯誤：</p>
<pre><code class="language-text">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>在 <code>largest</code> 我們想要用大於（<code>&gt;</code>）運算子比較兩個型別的爲 <code>T</code> 的數值。由於該運算子是從標準函式庫中的特徵 <code>std::cmp::PartialOrd</code> 的預設方法所定義的，我們希望在 <code>T</code> 中加上 <code>PartialOrd</code> 的特徵界限，讓函式可以比較任意型別的 slice。我們不需要將 <code>PartialOrd</code> 引入作用域因爲它由 prelude 提供。請變更 <code>largest</code> 的簽名如以下所示：</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">    let mut largest = list[0];
</span><span class="boring">
</span><span class="boring">    for &amp;item in list {
</span><span class="boring">        if item &gt; largest {
</span><span class="boring">            largest = item;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    largest
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let number_list = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;number_list);
</span><span class="boring">    println!(&quot;The largest number is {}&quot;, result);
</span><span class="boring">
</span><span class="boring">    let char_list = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;char_list);
</span><span class="boring">    println!(&quot;The largest char is {}&quot;, result);
</span><span class="boring">}
</span></code></pre>
<p>這次編譯程式碼時，我們會得到不同的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>此錯誤的關鍵在 <code>cannot move out of type [T], a non-copy slice</code>。在我們非泛型版本的函式 <code>largest</code> 中，我們只有嘗試尋找 <code>i32</code> 或 <code>char</code> 的最大值。如同第四章<a href="ch04-01-what-is-ownership.html#stack-only-data-copy">「只在堆疊上的資料：拷貝（Copy）」</a><!-- ignore -->段落所提到的，像 <code>i32</code> 和 <code>char</code> 這樣的型別是已知大小可以存在堆疊上，所以它們有實作 <code>Copy</code> 特徵。但當我們建立泛型函式 <code>largest</code> 時，<code>list</code> 參數就有可能拿到沒有實作 <code>Copy</code> 特徵的型別。隨後導致我們無法將 <code>list[0]</code> 移出給變數 <code>largest</code>，最後產生錯誤。</p>
<p>要限制此程式碼只允許有實作 <code>Copy</code> 特徵的型別，我們可以再 <code>T</code> 的特徵界限中加上 <code>Copy</code>！範例 10-15 展示了泛型函式 <code>largest</code> 完整的程式碼，只要我們傳遞給函式的 slice 數值型別有實作 <code>PartialOrd</code><em>和</em> <code>Copy</code> 特徵的話（像是 <code>i32</code> 和 <code>char</code>），就能編譯成功。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">範例 10-15：一個適用於任何實作 <code>PartialOrd</code> 與 <code>Copy</code> 特徵的泛型的 <code>largest</code> 函式</span></p>
<p>如果我們不想要限制函式 <code>largest</code> 只接受實作 <code>Copy</code> 特徵的型別，我們可以在 <code>T</code> 中改指定 <code>Clone</code> 而非 <code>Copy</code>。這樣當我們想要 <code>largest</code> 取得所有權，我們就可以克隆 slice 的數值。使用 <code>clone</code> 函式代表我們對於像是 <code>String</code> 這樣擁有堆積資料的型別，可能會產生更多堆積分配。而如果我們處理的資料很龐大的話，堆積分配的速度可能就會很慢。</p>
<p>另一種實作 <code>largest</code> 的方法是我們可以來回傳 slcie 中 <code>T</code> 數值的引用。如果我們將回傳型別改成 <code>&amp;T</code> 而非 <code>T</code>，也就是改變函式本體來回傳引用的話，我們就不需要 <code>Clone</code> 或 <code>Copy</code> 特徵界限，也能避免堆積分配。請試著自己實作這個解決辦法看看吧！</p>
<h3><a class="header" href="#透過特徵界限來選擇性實作方法" id="透過特徵界限來選擇性實作方法">透過特徵界限來選擇性實作方法</a></h3>
<p>在有使用泛型型別參數 <code>impl</code> 區塊中使用特徵界限，我們可以選擇性地對有實作特定特徵的型別來時錯方法。舉例來說，範例 10-16 的 <code>Pair&lt;T&gt;</code> 只有在其內部型別 <code>T</code> 有實作能夠做比較的 <code>PartialOrd</code> 特徵以及能夠顯示在螢幕的 <code>Display</code> 特徵的話，才會實作 <code>cmp_display</code> 方法。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-16：依據特徵界限來選擇性地在泛型型別實作方法</span></p>
<p>我們還可以對有實作其他特徵的型別選擇性地來實作特徵。對滿足特徵界限的型別實作特徵會稱之爲<em>毯子實作（blanket implementations）</em>，這被廣泛地用在 Rust 標準函式庫中。舉例來說，標準函式庫會對任何有實作 <code>Display</code> 特徵的型別實作 <code>ToString</code>。標準函式庫中的 <code>impl</code> 區塊會有類似這樣的程式碼：</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>因爲標準函式庫有此毯子實作，我們可以在任何有實作 <code>Display</code> 特徵的型別呼叫 <code>ToString</code> 特徵的 <code>to_string</code> 方法。舉例來說，我們可以像這樣將整數轉變成對應的 <code>String</code> 數值，因爲整數有實作 <code>Display</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>毯子實作在特徵技術文件的「Implementors」段落有做說明。</p>
<p>特徵與特徵界限讓我們能使用泛型型別參數來減少重複的程式碼的同時，告訴編譯器該泛型型別該擁有何種行爲。編譯器可以利用特徵界限資訊來檢查程式碼提供的實際型別有沒有符合特定行爲。在動態語言中，我們要是呼叫一個該型別沒有的方法的話，我們會在執行時才發生錯誤。但是 Rust 將此錯誤移到執行期間，讓我們必須在程式能夠執行之前確保有修正此問題。除此之外，我們還不用寫在執行時檢查此行爲的程式碼，因爲我們已經在編譯時就檢查了。這麼做我們可以在不失去泛型彈性的情況下，提升效能。</p>
<p>另一種我們已經看過的泛型爲<em>生命週期（lifetimes）</em>。不同於確保一個型別有沒有我們要的行爲，生命週期確保我們在需要引用的時候，它們都是有效的。讓我們來看看生命週期是怎麼做到的。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch10-02-traits.md">e5ed971</a></li>
<li>updated: 2020-09-15</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過生命週期驗證引用" id="透過生命週期驗證引用">透過生命週期驗證引用</a></h2>
<p>我們在第四章的<a href="ch04-02-references-and-borrowing.html#%E5%BC%95%E7%94%A8%E8%88%87%E5%80%9F%E7%94%A8">「引用與借用」</a><!-- ignore -->段落沒談到的是，Rust 中的每個引用都有個<em>生命週期（lifetime）</em>，這是決定該引用是否有效的作用域。大多情況下生命週期是隱式且可推導出來得，就像大多情況下型別是可推導出來的。當多種型別都有可能時，我們就得詮釋型別。同樣地，當生命週期的引用能以不同方式關聯的話，我們就得詮釋生命週期。Rust 要求我們用泛型生命週期參數來詮釋引用之間的關係，以確保實際在執行時的引用絕對是有效的。</p>
<p>生命週期的概念與其他程式語言有的工具都大相徑庭，這讓生命週期成爲 Rust 最獨特的特色。雖然我們不會在此章涵蓋所有生命週期的內容，但是我們講些你可能遇到生命週期的常見場景，來讓你更加熟悉這個概念。</p>
<h3><a class="header" href="#透過生命週期預防迷途引用" id="透過生命週期預防迷途引用">透過生命週期預防迷途引用</a></h3>
<p>生命週期最主要的目的就是要預防迷途引用（dangling references），其會導致程式引用到其他資料，而非它原本想要的引用。請看一下範例 10-17 的程式，它有一個外部作用域與內部作用域。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 10-17：嘗試使用其值已經離開作用域的引用</span></p>
<blockquote>
<p>注意：範例 10-17、10-18 與 10-24 宣告變數時都沒有給予初始數值，所以變數名稱可以存在於外部作用域。乍看之下這似乎違反 Rust 不存在空值的原則。但是如果我們嘗試在賦值前使用變數的話，我們就會獲得編譯期錯誤，這證明 Rust 的確不允許空值。</p>
</blockquote>
<p>外部作用域宣告了一個沒有初始值的變數 <code>r</code>，然後內部作用域宣告了一個初始值爲 5 的變數 <code>x</code>。在內部作用域中，我們嘗試將 <code>x</code> 的引用賦值給 <code>r</code>。然後內部作用域結束後，我們嘗試印出 <code>r</code>。此程式碼不會編譯成功，因爲數值 <code>r</code> 指向的數值在我們嘗試使用它時已經離開作用域。以下是錯誤訊息。</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>變數 <code>x</code> 「存在的不夠久」。原因是因爲當內部作用域在第 7 行結束時，<code>x</code> 會離開作用域。但是 <code>r</code> 卻還在外部作用域中有效，我們會說的「活得比較久」。如果 Rust 允許此程式碼可以執行的話，<code>r</code> 就會引用到 <code>x</code> 離開作用域後被釋放的記憶體位置，然後我們嘗試對 <code>r</code> 做的事情都不會是正確的了。所以 Rust 如何決定此程式碼無效呢？它使用了借用檢查器。</p>
<h3><a class="header" href="#借用檢查器" id="借用檢查器">借用檢查器</a></h3>
<p>Rust 編譯器有個*借用檢查器（borrow checker）*會比較作用域來檢測所有的借用是否有效。範例 10-18 顯示了範例 10-17 的程式碼，但加上了變數生命週期的詮釋。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 10-18：變數 <code>r</code> 與 <code>x</code> 的生命週期詮釋，分別以 <code>'a</code> 和 <code>'b</code> 作爲表示</span></p>
<p>我們在此定義 <code>r</code> 的生命週期詮釋爲 <code>'a</code> 而 <code>x</code> 的生命週期爲 <code>'b</code>。如同你所見，內部的 <code>'b</code> 區塊比外部的 <code>'a</code> 生命週期區塊還小。在編譯期間，Rust 會比較兩個生命週期的大小，並看出 <code>r</code> 有生命週期 <code>'a</code> 但它引用的記憶體有生命週期 <code>'b</code>。程式被回絕的原因是因爲 <code>'b</code> 比 <code>'a</code> 還短：被引用的對象比引用者存在的時間還短。</p>
<p>範例 10-19 修正了此程式碼讓它不會存在迷途引用，並能夠正確編譯。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-19：一個有效引用，因爲資料比引用的生命週期還長</span></p>
<p><code>x</code> 在此有生命週期 <code>'b</code>，此時它比 <code>'a</code> 還長。這代表 <code>r</code> 可以引用 <code>x</code>，因爲 Rust 知道 <code>r</code> 的引用在 <code>x</code> 是有效的時候永遠是有效的。</p>
<p>現在你知道引用的生命週期，以及 Rust 如何分析生命週期以確保引用永遠有效了。讓我們來探索函式中參數與回傳值的泛型生命週期。</p>
<h3><a class="header" href="#函式中的泛型生命週期" id="函式中的泛型生命週期">函式中的泛型生命週期</a></h3>
<p>讓我們寫個回傳兩個字串 slice 中較長者的函式。此函式會回傳兩個字串 slice 並回傳一個字串 slcie。在我們實作 <code>longest</code> 函式後，範例 10-20 的程式碼應該要印出 <code>The longest string is abcd</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">範例 10-20：<code>main</code> 函式呼叫 <code>longest</code> 函式來找出兩個字串 slice 中較長的</span></p>
<p>注意我們需要函式接收的字串 slice 屬於引用，因爲我們不希望 <code>longest</code> 函式會取得它參數的所有權。第四章的<a href="ch04-03-slices.html#%E5%AD%97%E4%B8%B2-slice-%E4%BD%9C%E7%88%B2%E5%8F%83%E6%95%B8">「字串 Slice 作爲參數」</a><!-- ignore -->段落有提到爲何範例 10-20 的參數正是我們所想要使用的參數。</p>
<p>如果我們嘗試實作 <code>longest</code> 函式時，如範例 10-21 所示，它不會編譯過。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">範例 10-21：回傳兩個字串中較長者的 <code>longest</code> 函式實作，不過無法編譯成功</span></p>
<p>我們會看到以下關於生命週期的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>提示文字表示回傳型別需要有一個泛型生命週期參數，因爲 Rust 無法辨別出回傳的引用指的是 <code>x</code> 還是 <code>y</code>。事實上，我們也不知道，因爲函式本體中的 <code>if</code> 區塊會回傳 <code>x</code> 引用而 <code>else</code> 區塊會回傳 <code>y</code> 引用！</p>
<p>當我們定義函式時，我們不知道傳遞進此函式的實際數值會是什麼，所以我們不知道到底是 <code>if</code> 或 <code>else</code> 的區塊會被執行。我們也不知道傳遞進來的引用實際的生命週期爲何，所以我們無法像範例 10-18 和 10-19 那樣觀察作用域，來判定我們回傳的引用會永遠有效。要修正此錯誤，我們要加上泛型生命週期參數來定義引用之間的關係，所以借用檢查器能夠進行分析。</p>
<h3><a class="header" href="#生命週期詮釋語法" id="生命週期詮釋語法">生命週期詮釋語法</a></h3>
<p>生命週期詮釋不會改變引用能存活多久。就像當函式簽名指定了一個泛型型別參數時，函式變能夠接受任意型別一樣。函式可以指定一個泛型生命週期參數，這樣函式就能接受任何生命週期。生命週期詮釋描述了數個引用的生命週期之間互相的關係，而不會影響其生命週期。</p>
<p>生命週期詮釋的語法有一點不一樣：生命週期參數的名稱必須以撇號（<code>'</code>）作爲開頭，通常全是小寫且很短，就像泛型型別一樣。大多數的人會使用名稱 <code>'a</code>。我們將生命週期參數置於引用的 <code>&amp;</code> 之後，並使用空格區隔詮釋與引用的型別。</p>
<p>以下是一些例子：沒有生命週期參數的 <code>i32</code> 引用、有生命週期 <code>'a</code> 的 <code>i32</code> 引用以及有生命週期 <code>'a</code> 的 <code>i32</code> 可變引用。</p>
<pre><code class="language-rust ignore">&amp;i32        // 一個引用
&amp;'a i32     // 一個有顯式生命週期的引用
&amp;'a mut i32 // 一個有顯式生命週期的可變引用
</code></pre>
<p>只有自己一個生命週期本身沒有多少意義，因爲該詮釋是爲了告訴 Rust 數個引用的泛型生命週期參數之間互相的關係。舉例來說，我們有個函式其參數 <code>first</code> 是個 <code>i32</code> 的引用而生命週期爲 <code>'a</code>。此函式還有另一個參數 <code>second</code> 是另一個 <code>i32</code> 的引用而且生命週期也是 <code>'a</code>。生命週期詮釋意味著引用 <code>first</code> 與 <code>second</code> 必須與此泛型生命週期存活的一樣久。</p>
<h3><a class="header" href="#函式簽名中的生命週期詮釋" id="函式簽名中的生命週期詮釋">函式簽名中的生命週期詮釋</a></h3>
<p>現在讓我們研究 <code>longest</code> 函式中的生命週期詮釋吧。如同泛型型別參數，我們需要在函式名稱與參數列表之間的尖括號內宣告泛型生命週期參數。我們想在此簽名表達的是所有參數與回傳值的引用都必須有相同的生命週期。我們將生命週期命名爲 <code>'a</code> 然後將它加到每個引用，如範例 10-22 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p><span class="caption">範例 10-22：<code>longest</code> 函式定義指定所有簽名中的引用必須有相同的生命週期 <code>'a</code></span></p>
<p>此程式碼能夠編譯成功並產生我們希望在範例 10-20 的 <code>main</code> 函式中得到的結果。</p>
<p>此函式簽名告訴 Rust 它有個生命週期 <code>'a</code>，函式的兩個參數都是字串 slice，並且會與生命週期<code>'a</code>。此函式簽名還靠素了 Rust 從函式回傳的字串 slice 也會和生命週期 <code>'a</code> 存活的一樣久。實際上它代表 <code>longest</code> 函式回傳引用的生命週期與傳入時字串長度較短的引用的生命週期一樣。這些限制是我們希望 Rust 去強制執行的。記住當我們在此函式簽名指定生命週期參數時，我們不會變更任何傳入或傳出數值的生命週期。我們只是告訴借用檢查器應該要拒絕任何沒有服從這些限制的數值。注意到 <code>longest</code> 函式不需要知道 <code>x</code> 和 <code>y</code> 實際上會活多久，只需要知道有某個作用域會用 <code>'a</code> 取代來滿足此簽名。</p>
<p>當要在函式詮釋生命週期時，詮釋會爲於函式簽名中，而不是函式本體。Rust 可以不用任何協助就能分析函式中的程式碼。然而當函式擁有傳入或傳出外部程式碼的引用時，Rust 無法自己判別出參數與回傳值的生命週期。每次函式呼叫時的生命週期可能都不一樣。這就是爲何我們得親自詮釋生命週期。</p>
<p>當我們向 <code>longest</code> 傳入實際引用時，<code>'a</code> 實際替代的生命週期爲 <code>x</code> 作用域與 <code>y</code> 作用域重疊得部分。換句話說，泛型生命週期 <code>'a</code> 取得的生命週期會等於 <code>x</code> 與 <code>y</code> 的生命週期中較短的。因爲我們將回傳引用詮釋了相同的生命週期參數 <code>'a</code>，回傳引用的生命週期也會保證在 <code>x</code> 和 <code>y</code> 的生命週期較短的結束前有效。</p>
<p>讓我們來看看如何透過傳入不同實際生命週期的引用來使生命週期詮釋能限制 <code>longest</code> 函式，如範例 10-23 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-23使用 <code>longest</code> 函式並傳入 <code>String</code> 數值的引用，但兩個參數的實際生命週期均不相同</span></p>
<p>在此例中 <code>string1</code> 在外部作用域結束前都有效，而 <code>string2</code> 在內部作用域結束前都有效，然後 <code>result</code> 會取得某個有效引用直到內部作用域結束爲止。執行此程式的話，你會看到借用檢查器認可此程式碼，它會編譯成功然後印出 <code>The longest string is long string is long</code>。</p>
<p>接下來，讓我們寫一個範例能要求 <code>result</code> 生命週期的引用必須是兩個引數中較短的才行。我們會移動變數 <code>result</code> 的宣告到外部作用域，但保留變數 <code>result</code> 的賦值與 <code>string2</code> 一樣在內部作用域。然後我們也將使用到 <code>result</code> 的 <code>println!</code> 移到外部作用域，緊接在內部作用域結束之後。如範例 10-24 所示，此程式碼會編譯不過。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 10-24：嘗試在 <code>string2</code> 離開作用域後使用 <code>result</code></span></p>
<p>當我們嘗試編譯此程式碼，我們會看到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>錯誤訊息表示要讓 <code>result</code> 在 <code>println!</code> 陳述式有效的話，<code>string2</code> 必須在外部作用域結束前都是有效的。Rust 會知道是因爲我們在函式的參數與回傳值使用相同的生命週期 <code>'a</code> 來詮釋。</p>
<p>身爲人類我們能看出此程式碼的 <code>string1</code> 字串長度的確比 <code>string2</code> 長，因此 <code>result</code> 會包含 <code>string1</code> 的引用。因爲 <code>string1</code> 尚未離開作用域，所以 <code>string1</code> 的引用在 <code>println!</code> 陳述式中仍然是有效的才對。然而編譯器在此情形會無法看出引用是有效的。所以我們才告訴 Rust <code>longest</code> 函式回傳引用的生命週期等同於傳入引用中較短的生命週期。這樣一來借用檢查器就會否決範例 10-24 的程式碼，因爲它可能會有無效的引用。</p>
<p>歡迎嘗試設計更多採用不同數值與不同生命週期的引用作爲 <code>longest</code> 函式參數與回傳值的實驗，並在編譯前假設你的實驗會不會通過借用檢查器，然後看看你的理解是不是正確的！</p>
<h3><a class="header" href="#深入理解生命週期" id="深入理解生命週期">深入理解生命週期</a></h3>
<p>你要指定生命週期參數的方式取決於函式的行爲。舉例來說如果我們改變函式 <code>longest</code> 的實作爲永遠只回傳第一個參數而不是最長的字串 slice，我們就不需要在參數 <code>y</code> 指定生命週期。以下的程式碼就能編譯：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<p>在此例中，我們指定生命週期參數 <code>'a</code> 給參數 <code>x</code> 與回傳型別，但參數 <code>y</code> 則沒有，因爲 <code>y</code> 的生命週期與 <code>x</code> 和回傳型別的生命週期之間沒有任何關係。</p>
<p>當函式回傳引用時，回傳型別的生命週期參數必須符合其中一個參數的生命週期參數。如果回傳引用<em>沒有</em>和任何參數有關聯的話，代表它引用的是函式本體中的數值。但這會是迷途引用，因爲該數值會在函式結尾離開作用域。請看看以下嘗試在函式 <code>longest</code> 的實作做法，它並不會編譯成功：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>我們在這邊雖然有對回傳型別指定生命週期參數 <code>'a</code>，但此實作還是會失敗，因爲回傳值的生命週期與參數的生命週期完全無關。以下是我們獲得的錯誤訊息：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>問題在於 <code>result</code> 會離開作用域並在 <code>longest</code> 函式結尾被清除。我們卻嘗試從函式中回傳 <code>result</code> 的引用。我們無法指定生命週期參數來改變迷途引用，而且 Rust 不會允許我們將建立迷途引用。在此例中，最好的解決辦法是回傳有所有權的資料型別而非引用，並讓呼叫的函式自行決定如何清理數值。</p>
<p>總結來說，生命週期語法是用來連接函式中不同參數與回傳值的生命週期。一旦連結起來，Rust 就可以獲得足夠的資訊來確保記憶體安全的運算並防止會產生迷途指標或違反記憶體安全的操作。</p>
<h3><a class="header" href="#結構體定義中的生命週期詮釋" id="結構體定義中的生命週期詮釋">結構體定義中的生命週期詮釋</a></h3>
<p>目前爲止，我們只定義過擁有所有權的結構體。結構體其實也能持有引用，不過我們會需要在結構體定義中每個引用加上生命週期詮釋。範例 10-25 有個持有字串 slice 的結構體 <code>ImportantExcerpt</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p><span class="caption">範例 10-25：擁有引用的結構體，所以它的定義需要加上生命週期詮釋</span></p>
<p>此結構體有個欄位 <code>part</code> 並擁有字串 slice 引用。如同泛型資料型別，我們在結構體名稱之後的尖括號內宣告泛型生命週期參數，所以我們就可以在結構體定義的本體中使用生命週期參數。此詮釋代表 <code>ImportantExcerpt</code> 的實例不能比它持有的欄位 <code>part</code> 活得還久。</p>
<p><code>main</code> 函式在此產生一個結構體 <code>ImportantExcerpt</code> 的實例並持有一個引用，其爲變數 <code>novel</code> 所擁有的 <code>String</code> 中的第一個句子的引用。<code>novel</code> 的資料是在 <code>ImportantExcerpt</code> 實例之前建立的。除此之外，<code>novel</code> 在 <code>ImportantExcerpt</code> 離開作用於之前不會離開作用域，所以 <code>ImportantExcerpt</code> 實例中的引用是有效的。</p>
<h3><a class="header" href="#生命週期省略" id="生命週期省略">生命週期省略</a></h3>
<p>你已經學到了每個引用都有個生命週期，而且你需要在有使用引用的函式與結構體中指定生命週期參數。然而在第四章的範例 4-9 我們有可以函式可以不詮釋生命週期並照樣編譯成功，我門在範例 10-26 在展示一次。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 10-26：在範例 4-9 定義過的函式，雖然其參數與回傳值均爲引用，卻仍可編譯成功</span></p>
<p>此函式可以不用生命週期詮釋仍照樣編譯過是有歷史因素的：在早期版本的 Rust（1.0 之前），此程式碼是無法編譯的，因爲每個引用都得有顯示生命週期。在當時的情況下，此函式簽名會長得像這樣：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>在寫了大量的 Rust 程式碼後，Rust 團隊發現 Rust 開發者會在特定情況反復輸入同樣的生命週期詮釋。這些情形都是可預期的，而且可以遵循一些明確的模式。開發者將這些模式加入編譯器的程式碼中，所以借用檢查器可以依據這些情況自行推導生命週期，而讓我們不必顯式詮釋。</p>
<p>這樣的歷史值得提起的原因是因爲很可能會有更多明確的模式被找出來並加到編譯器中，意味著未來對於生命週期詮釋的要求會更少。</p>
<p>被寫進 Rust 引用分析的模式被稱作<em>生命週期省略規則（lifetime elision rules）</em>。這些不是程式設計師要遵守的過烏賊額，而是一系列編譯器能去考慮的情形。而如果你的程式碼符合這些情形時，你就不必顯式寫出生命週期。</p>
<p>省略規則無法提供完整的推導。如果 Rust 能明確套用規則，但在這之後還是有引用存在模棱兩可的生命週期，編譯器就無法猜出剩餘引用的生命週期。在此情況，編譯器不穢亂猜，它會回傳錯誤給你，你可以指定生命週期詮釋來指明引用之間的關係。</p>
<p>在函式或方法參數上的生命週期稱爲<em>輸入生命週期（input lifetimes）</em>，而在回傳值的生命週期則稱爲<em>輸出生命週期（output lifetimes）</em>。</p>
<p>當引用沒有顯式詮釋生命週期時，編譯器會用三項規則來推導它們。第一個規則適用於輸入生命週期，而第二與第三個規則適用於輸出生命週期。如果編譯器處理完這三個規則，卻仍有引用無法推斷出生命週期時，編譯器就會停止並回傳錯誤。適用於 <code>fn</code> 定義的規則一樣適用於 <code>impl</code> 區塊。</p>
<p>第一個規則是每個引用都會有自己的生命週期參數。換句話說，一個函式只有一個參數的話，就只會有一個生命週期：<code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>；一個函式有兩個參數的話，就會有分別兩個生命週期參數：<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>。以此類推。</p>
<p>第二個規則是如果剛好只有一個輸入生命週期參數，該參數就會賦值給所有輸出生命週期參數：<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</p>
<p>第三個規則是如果有多個輸入生命週期參數，但其中一個是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，由於這是方法，<code>self</code> 的生命週期會賦值給所有輸出生命週期參數。此規則讓方法更容易讀寫，因爲不用寫更多符號出來。</p>
<p>讓我們假裝我們是編譯器。我們會檢查這些規則並找出範例 10-26 中函式 <code>first_word</code> 簽名中引用的生命週期。簽名的引用一開始沒有任何生命週期：</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>接著編譯器檢查第一個規則，指明每個參數都有自己的生命週期。我們如往常一樣指定 <code>'a</code>，所以簽名就會變成：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>然後第二個規則也是用因爲這裡剛好就一個輸入生命週期而已。第二個規則指明只有一個輸入生命週期的話，就會賦值給所有其他輸出生命週期。所以簽名現在變成這樣：</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>現在此函式所有的引用都有生命週期了，而且編譯器可以繼續分析，不必要求程式設計師在此詮釋函式簽名的生命週期。</p>
<p>讓我們再看看一個例子，這次是範例 10-21 一開始沒有任何生命週期參數的 <code>longest</code> 函式：</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>讓我們先檢查第一項規則：每個參數都有自己的生命週期。這次我們有兩個參數，所以我們有兩個生命週期：</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>你可以看出來第二個規則並不適用，因爲我們有不止一個輸入生命週期。而第三個也不適用，因爲 <code>longest</code> 是函式而非方法，其參數不會有 <code>self</code> 。遍歷這三個規則下來，我們仍然無法推斷出回傳型別的生命週期。這就是爲何我們嘗試編譯範例 10-21 的程式碼會出錯的原因：編譯器遍歷生命週期省略規則，但仍然無法推導出簽名中所有引用的生命週期。</p>
<p>因爲第三個規則僅適用於方法簽名，我們接下來就會看看這種情況時的生命週期，看看爲何第三個規則讓我們不必常常在方法簽名詮釋生命週期。</p>
<h3><a class="header" href="#在方法定義中的生命週期詮釋" id="在方法定義中的生命週期詮釋">在方法定義中的生命週期詮釋</a></h3>
<p>當我們在有生命週期的結構體上實作方法時，其語法類似於我們在範例 10-11 中泛型型別參數的語法。 宣告並使用生命週期參數的地方會依據它們是否與結構體欄位或方法參數與回傳值相關。</p>
<p>結構體欄位的生命週期永遠需要宣告在 <code>impl</code> 關鍵字後方以及結構體名稱後方，因爲這些生命週期是結構體型別的一部分。</p>
<p>在 <code>impl</code> 區塊中方法簽名的引用可能會與結構體欄位的引用生命週期綁定，或者它們可能是互相獨立的。除此之外，生命週期省略規則常常可以省略方法簽名中的生命週期詮釋。讓我們看看範例 10-25 定義過的 <code>ImportantExcerpt</code> 來作爲範例。</p>
<p>首先我們使用一個方叫做 <code>level</code> 其參數只有 <code>self</code> 的引用而回傳值是 <code>i32</code>，這不是任何引用：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Attention please: {}&quot;, announcement);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>生命週期參數宣告在 <code>impl</code> 之後，而且也要在型別名稱之後加上。但是我們不必在 <code>self</code> 的引用加上生命週期詮釋，因爲其適用於第一個省略規則。</p>
<p>以下是第三個生命週期省略規則適用的地方：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>這裏有兩個輸入生命週期，所以 Rust 用第一個生命週期省略規則給予 <code>&amp;self</code> 和 <code>announcement</code> 它們自己的生命週期。然後因爲其中一個參數是 <code>&amp;self</code>，回傳型別會取得 <code>&amp;self</code> 的生命週期，如此一來所有的生命週期都推導出來了。</p>
<h3><a class="header" href="#靜態生命週期" id="靜態生命週期">靜態生命週期</a></h3>
<p>其中有個特殊的生命週期 <code>'static</code> 我們需要進一步討論，這是指該引用<em>可以</em>存活在整個程式期間。所有的字串字面值都有 <code>'static</code> 生命週期，我們可以這樣詮釋：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>此字串的文字會直接儲存在程式的二進制檔案中，所以永遠有效。因此所有的字串字面值的生命週期都是 <code>'static</code>。</p>
<p>你有時可能會看到錯誤訊息建議使用 <code>'static</code> 生命週期。但在你對引用指明 <code>'static</code> 生命週期前，最好想一下該引用的生命週期是否真的會存在於整個程式期間。就算它可以，你可能也得考慮是不是該活得這麼久。大多數的情況，程式問題都來自於嘗試建立迷途引用或可用的生命週期不符。這樣的情況下，應該是要實際嘗試解決問題，而不是指明 <code>'static</code> 生命週期。</p>
<h2><a class="header" href="#組合泛型型別參數特徵界限與生命週期" id="組合泛型型別參數特徵界限與生命週期">組合泛型型別參數、特徵界限與生命週期</a></h2>
<p>讓我們用一個函式來總結泛型型別參數、特徵界限與生命週期的語法！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Today is someone's birthday!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>這是範例 10-22 會回傳兩個字串 slice 較長者的 <code>longest</code> 函式。不過現在它有個額外的參數 <code>ann</code>，使用的是泛型型別 <code>T</code>，它可以是任何在 <code>where</code> 中所指定有實作 <code>Display</code> 特徵的型別。此額外參數會在函式比較兩個字串 slice 前印出來，這也是爲何需要 <code>Display</code> 特徵界限。因爲生命週期也是一種泛型，生命週期參數 <code>'a</code> 與泛型型別參數 <code>T</code> 都宣告在函式名稱後的尖括號內。</p>
<h2><a class="header" href="#總結-8" id="總結-8">總結</a></h2>
<p>我們在此章節涵蓋了許多內容！現在你已經知道泛型型別參數、特徵與特徵界限以及泛型生命週期參數，你已經準備好能寫出適用於許多不同情況且不重複的程式碼了。泛型型別參數讓你可以讓程式碼適用於不同型別；特徵與特徵界限確保就算型別爲泛型，它們都會有相同的行爲。你還學到了使用生命週期詮釋確保此如此彈性的程式碼不會造成迷途引用。而且這些分析都發生在編譯期間，完全不影響執行時效能！</p>
<p>不管你信不信，本章節還有很多延伸主體可以導論，像是第十七章就會討論特徵物件（trait objects），這是另一個使用特徵的方法。另外還有一些更複雜的場合會涉及到更進階的生命週期詮釋。對此你可能就會想閱讀 <a href="../reference/index.html">Rust Reference</a>。接下來，你想學習如何在 Rust 寫測試，讓你可以確保程式碼能如期執行。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch10-03-lifetime-syntax.md">e5ed971</a></li>
<li>updated: 2020-09-15</li>
</ul>
</blockquote>
<h1><a class="header" href="#編寫自動化測試" id="編寫自動化測試">編寫自動化測試</a></h1>
<p>Edsger W. Dijkstra 曾在 1972 年的演講「謙遜的程式設計師」中提到：「程式測試是個證明程式錯誤存在非常有效的方法，但要證明它不存在卻反而顯得十分無力。」這不代表我們不應該盡可能地做測試！</p>
<p>程式碼的正確性意謂著我們的程式碼可以如我們的預期執行。Rust 就被設計爲特別注重程式的正確性，但正確性是很複雜且難以證明的。Rust 的型別系統就承擔來很大一部分的負擔，但是型別系統還是沒辦法抓到所有不正確的地方。所以 Rust 在語言內提供了編寫自動化程式測試的支援。</p>
<p>舉例來說，假設我們要寫個程式叫做 <code>add_two</code>，其會將傳入任意數字加上 2。此函式簽名接受整數作爲參數並回傳一個整數作爲結果。當我們實作並編譯函式時，Rust 會做所有你已經學過的型別檢查與借用檢查，來確保像是我們不會中傳入 <code>String</code> 數值或任意無效引用至此函式。但 Rust <em>無法</em>檢查會不會執行我們預期此函式會完成的任務，也就是回傳加上 2 的參數。說不等它會將參數加上 10 或減 50！這就是我們要做測試的地方。</p>
<p>舉例來說，我們可以寫測試來判定當我們傳入 <code>3</code> 給函式 <code>add_two</code> 時，回傳值是不是 <code>5</code>。我們可以再變更我們的程式碼時來執行這些測試，以確保原本就正確的行爲不會被改變。</p>
<p>測試是個複雜的技能，雖然我們無法在一個章節就涵蓋如何寫出好測試的細節，但我們還是會討論 Rust 測試功能機制。我們會介紹當你寫測時時可以用的詮釋與巨集、執行測試時的預設行爲與選項以及如何組織測試成單元測試與整合測試。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch11-00-testing.md">e5ed971</a></li>
<li>updated: 2020-09-15</li>
</ul>
</blockquote>
<h2><a class="header" href="#如何寫測試" id="如何寫測試">如何寫測試</a></h2>
<p>測試是一種 Rust 函式來驗證非測試程式碼是否以預期的方式執行。測試函式的本體通常會做三件動作：</p>
<ol>
<li>設置任何鎖需要的資料或狀態。</li>
<li>執行你希望測試的程式碼</li>
<li>判定結果是否與你預期的相符。</li>
</ol>
<p>讓我們看看 Rust 特地提供給測試的功能：包含 <code>test</code> 屬性（attribute）、一些巨集以及 <code>should_panic</code> 屬性。</p>
<h3><a class="header" href="#測試函式剖析" id="測試函式剖析">測試函式剖析</a></h3>
<p>最簡單的形式來看，測試在 Rust 中就是附有 <code>test</code> 屬性的函式。屬性（Attributes）是一種關於某段 Rust 程式碼的詮釋資料（metadata），其中一個例子是我們在第五章使用的 <code>derive</code> 屬性。要將一個函式轉換成測試函式，在 <code>fn</code> 前一行加上 <code>#[test]</code> 即可。當你用 <code>cargo test</code> 命令來執行你的測試時，Rust 會建構一個測試執行檔並執行標有 <code>test</code> 屬性的程式，並回報每個測試函式是否通過或失敗。</p>
<p>當我們用 Cargo 建立新的函式庫專案時，同時會自動建立一個擁有測試函式的測試模組。此模組能協助我們開始寫測試，讓你不必在每次建立新專案時，尋找特定結構體與測試函式的語法。你可以新增多少測試函式與多少測試模組都沒問題！</p>
<p>我們將會透過實驗測試產生的樣板而非實際測試任何程式碼，來探索測試如何運作的每個環節。然後我們會寫些現實世界會寫得測試，呼叫我們寫的程式碼並判定其行爲是否正確。</p>
<p>讓我們建立個函式庫專案叫做 <code>adder</code>：</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>函式庫專案 <code>adder</code> 中的 <em>src/lib.rs</em> 檔案內容會長得像範例 11-1 所示。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 11-1：透過 <code>cargo new</code> 自動產生的測試模組與函式</span></p>
<p>現在我們先忽略開頭前兩行並專注在函式，看看它執行的。注意到 <code>fn</code> 上一行的 <code>#[test]</code> 詮釋：此屬性指出這是測試函式，所以測試者會知道此函式是用來測試的。我們也可以在 <code>tests</code> 模組中加入非測試函式來協助設置常見場景或是執行常見運算，所以我們需要在想要測試的函式前加上 <code>#[test]</code> 屬性。</p>
<p>函式本體使用 <code>assert_eq!</code> 巨集來判定 2 + 2 等於 4。此判定是作爲典型測試的範例格式。讓我們執行它來看看此測試是否會通過。</p>
<p><code>cargo test</code> 命令會執行專案中的所有測試，如範例 11-2 所示。</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p><span class="caption">範例 11-2：執行自動產生的測試的輸出結果</span></p>
<p>Cargo 會編譯並執行測試。在 <code>Compiling</code>、<code>Finished</code> 與 <code>Running</code> 之後會出現 <code>running 1 test</code> 此行。下一行會顯示自動產生的測試函式 <code>it_works</code> 以及測試執行的結果 <code>ok</code>。再來可以看到整體總結，<code>test result: ok.</code> 代表所有測試都有通過，然後 <code>1 passed; 0 failed</code> 指出所有測試成功或失敗的數量。</p>
<p>因爲我們尚未有任何會忽略的程式碼，所以總結會顯示 <code>0 ignored</code>。我們也沒有過濾會值行的測試，所以總結最後顯示 <code>0 filtered out</code>。我們會在下個段落 <a href="ch11-02-running-tests.html#%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BC%8F%E5%A6%82%E4%BD%95%E5%9F%B7%E8%A1%8C">「控制程式如何執行」</a><!-- ignore --> 來討論忽略與過濾測試。</p>
<p><code>0 measured</code> 的統計數值是指評測效能的效能測試。效能測試（Benchmark tests）在本書撰寫時，仍然僅在 nightly Rust 可用。請查閱<a href="../unstable-book/library-features/test.html">效能測試的技術文件</a>來瞭解詳情。</p>
<p>測試輸出結果的下一部分，也就是 <code>Doc-tests adder</code>，是指任何技術文件測試的結果。我們還沒有任何技術文件測試，但是 Rust 可以編譯在 API 技術文件中的任何程式碼範例。此功能能幫助我們將技術文件與程式碼保持同步！我們會在第十四章的 <a href="ch14-02-publishing-to-crates-io.html#%E5%B0%87%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6%E8%A8%BB%E8%A7%A3%E4%BD%9C%E7%88%B2%E6%B8%AC%E8%A9%A6">「將技術文件註解作爲測試」</a><!-- ignore -->段落討論如何寫技術文件測試。現在我們會先忽略 <code>Doc-tests</code> 的輸出結果。</p>
<p>讓我們變更程式碼的名稱來看看測試輸出會變成什麼。將 <code>it_works</code> 函式變更名稱，像是以下改成 <code>exploration</code> 這樣：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>然後在執行一次 <code>cargo test</code>，輸出會顯示 <code>exploration</code> 而非 <code>it_works</code>：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>讓我們在加上另一個測試，不過這次我們要讓測試失敗！測試會在測試函式恐慌時失敗，每個測試會跑在新的執行緒（thread）上，然後當主執行緒看到測試執行緒死亡時，就會將該測試標記爲失敗的。我們有在第九章提及引發恐慌最簡單的辦法，那就是呼叫 <code>panic!</code> 巨集。將它寫入新的測試 <code>another</code> 中，所以你在 <em>src/lib.rs</em> 的檔案中會看到向範例 11-3 這樣。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 11-3：新增第二個會失敗的測試，因爲我們會呼叫 <code>panic!</code> 巨集</span></p>
<p>使用 <code>cargo test</code> 再執行一次測試，輸出結果應該會像範例 11-4 這樣，顯示出我們的 <code>exploration</code> 測試通過但 <code>another</code> 失敗。</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p><span class="caption">範例 11-4：其中一個測試通過，而另一個失敗的輸出結果</span></p>
<p><code>test tests::another</code> 這行會顯示 <code>FAILED</code> 而非 <code>ok</code>。在獨立結果與總結之間出現了兩個新的段落，第一個段落會顯示每個測試失敗的原因細節。在此例中，<code>another</code> 因爲 <em>src/lib.rs</em> 檔案中第十行的恐慌 <code>panicked at 'Make this test fail'</code> 而失敗。下一個段落則是會列出所有失敗的測試，要是測試很多且失敗測試輸出結果很長的話，此資訊就很實用。我們可以使用失敗測試的名稱來只執行這個測試以便除錯。我們會在<a href="ch11-02-running-tests.html#%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BC%8F%E5%A6%82%E4%BD%95%E5%9F%B7%E8%A1%8C">「控制程式如何執行」</a><!-- ignore -->段落討論更多執行測試的方法。</p>
<p>總結會顯示在最後一行，在此例中它表示我們有一個測試結果是 <code>FAILED</code>。也就是我們有一個測試通過，一個測試失敗。</p>
<p>現在你知道測試結果在不同場合看起來的樣子，讓我們來看看除了 <code>panic!</code> 以外對測試也很有幫助的巨集吧。</p>
<h3><a class="header" href="#透過-assert-巨集檢查結果" id="透過-assert-巨集檢查結果">透過 <code>assert!</code> 巨集檢查結果</a></h3>
<p>標準函式庫提供的 <code>assert!</code> 巨集可以在你要確保測試中的一些條件評估爲 <code>true</code> 時使用。我們給予 <code>assert!</code> 巨集一個引數來計算出布林值。如果數值爲 <code>true</code>，<code>assert!</code> 不會做任何動作然後測試就會通過。如果數值爲 <code>false</code>，<code>assert!</code> 巨集會呼叫 <code>panic!</code> 巨集導致測試失敗。使用 <code>assert!</code> 巨集能幫助我們檢查我們的程式碼是否以我們預期的方式運作。</p>
<p>在第五章的範例 5-15，我們有結構體 <code>Rectangle</code> 與方法 <code>can_hold</code>，我們在範例 11-5 再看一次。讓我們將此程式碼寫入 <em>src/lib.rs</em> 檔案中，並寫些對它使用 <code>assert!</code> 巨集的測試。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 11-5：第五章中的結構體 <code>Rectangle</code> 與其方法 <code>can_hold</code></span></p>
<p><code>can_hold</code> 方法會回傳布林值，這代表它是 <code>assert!</code> 巨集的絕佳展示機會。在範例 11-6 中，我們寫了個測試來練習 <code>can_hold</code> 方法，我們建立了一個寬度爲 8 長度爲 7 的 <code>Rectangle</code> 實例，並判定它可以包含另一個寬度爲 5 長度爲 1 的 <code>Rectangle</code> 實例。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 11-6：一支檢查一個大長方形是否能包含一個小長方形的 <code>can_hold</code> 測試</span></p>
<p>注意到我們已經在 <code>tests</code> 模組中加了一行 <code>use super::*;</code>。<code>tests</code> 和一般的模組一樣都遵循我們在第七章<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">「引用模組項目的路徑」</a><!-- ignore -->提及的常見能見度規則。因爲 <code>tests</code> 模組是內部模組，我們需要將外部模組的程式碼引入內部模組的作用域中。我們使用全域運算子（glob）讓外部模組定義的所有程式碼在此 <code>tests</code> 模組都可以使用。</p>
<p>我們將我們的測試命名爲 <code>larger_can_hold_smaller</code>，然後我們建立兩個我們需要用到的 <code>Rectangle</code> 實例。然後我們呼叫 <code>assert!</code> 巨集並將 <code>larger.can_hold(&amp;smaller)</code> 的結果傳給它。此表達式應該要回傳 <code>true</code>，所以我們的程式應該會通過。讓我們看看結果吧！</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>它通過了！讓我們再加另一個測試，這是是判定小長方形無法包含大長方形：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>因爲函式 <code>can_hold</code> 的正確結果在此例爲 <code>false</code>，我們需要將該結果反轉後才能傳給 <code>assert!</code> 巨集。因此我們的測試在 <code>can_hold</code> 回傳 <code>false</code> 時才會通過：</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>兩個測試都過了！現在讓我們看看當我們在程式碼中引入程式錯誤的話，測試結果會爲何。讓我們來改變 <code>can_hold</code> 方法的實作將比較時的大於符號改成小於符號：</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>執行測試的話現在就會顯示以下結果：</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>我們的測試抓到了錯誤！因爲 <code>larger.width</code> 是 8 而 <code>smaller.width</code> 是 5，<code>can_hold</code> 比較寬度時現在會回傳 <code>false</code>，因爲 8 沒有比 5 小。</p>
<h3><a class="header" href="#透過-assert_eq-與-assert_ne-macros測試相等" id="透過-assert_eq-與-assert_ne-macros測試相等">透過 <code>assert_eq!</code> 與 <code>assert_ne!</code> Macros測試相等</a></h3>
<p>有一種常見的測試程式的方式是將程式碼的結果與你預期程式碼會回傳的數值做比較，檢查它們是否相等。你可以使用 <code>assert!</code> 巨集並傳入使用 <code>==</code> 運算子的表達式來辦到。不過這種測試方法是很常見的，所以標準函式庫提供了一對巨集 <code>assert_eq!</code> 與 <code>assert_ne!</code> 來讓你能更方便地測試。這兩個巨集分別比較兩個引數是否相等或不相等。如果判定失敗的話，它們還會印出兩個數值，讓我們能清楚看到<em>爲何</em>測試失敗。相對地，<code>assert!</code> 巨集只會說明它在 <code>==</code> 表達式中取得 <code>false</code> 值，而不會告訴你導致 <code>false</code> 的那兩個值。</p>
<p>在範例 11-7 中，我們寫了個函式叫做 <code>add_two</code> 並對參數加上 <code>2</code> 然後回傳爲結果。然後我們使用 <code>assert_eq!</code> 巨集來測試此函式。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 11-7：使用 <code>assert_eq!</code> 巨集測試函式 <code>add_two</code></span></p>
<p>讓我們檢查後它的確通過了！</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>我們給予 <code>assert_eq!</code> 巨集的第一個引數 <code>4</code> 與呼叫 <code>add_two(2)</code> 的結果相等。測試的結果爲 <code>test tests::it_adds_two ... ok</code> 而 <code>ok</code> 就代表我們的測試通過了！</p>
<p>讓我們在我們的程式碼引入個錯誤，看看使使用 <code>assert_eq!</code> 的測試失敗時看起來爲何。變更函式 <code>add_two</code> 的實作改成加 <code>3</code>：</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>再執行一次測試：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>我們的測試抓到了錯誤！<code>it_adds_two</code> 測試失敗了，並顯示<code>assertion failed: `(left == right)`</code> 然後接著顯示 <code>left</code> 是 <code>4</code> 且 <code>right</code> 是 <code>5</code>。此訊息非常有用，且能幫助我們開始除錯，它代表 <code>assert_eq!</code> 的引數 <code>left</code> 是 <code>4</code> 但是擁有 <code>add_two(2)</code> 的引數 <code>right</code> 卻是 <code>5</code>。</p>
<p>注意到在有些語言或測試框架中，判定兩個數值是否相等的函式的參數會稱作 <code>expected</code> 和 <code>actual</code>，然後它們會因爲指定的引數順序而有差。但在 Rust 中它們被稱爲 <code>left</code> 和 <code>right</code>，且我們預期的值與測試中程式碼產生的值之間的順序沒有任何影響。我們可以在此程式這樣寫判定 <code>assert_eq!(add_two(2), 4)</code>，而錯誤訊息就會顯示成 <code>assertion failed: `(left == right)`</code>，然後 <code>left</code> 會是 <code>5</code> 而 <code>right</code> 會是 <code>4</code>。</p>
<p><code>assert_ne!</code> 巨集會在我們給予的兩個值不相等時通過，相等時失敗。此巨集適用於當我們不確定一個數值<em>會是</em>什麼樣子，但是我們確定知道如果我們程式如預期執行的話，該數值<em>不會</em>是某種樣子。舉例來說，如果我們要測試一個保證會以某種形式更改其輸入的函式，但輸入變更的方式是依照我們執行程式時的當天是星期幾來決定，此時最好的判定方式就是檢查函式的輸出不等於輸入。</p>
<p><code>assert_eq!</code> 和 <code>assert_ne!</code> 巨集底下分別使用了 <code>==</code> 和 <code>!=</code> 運算子。當判定失敗時，巨集會透過除錯格式化資訊來顯示它們的引數，代表要比較的數值必須要實作 <code>PartialEq</code> 和 <code>Debug</code> 特徵。所有的基本型別與大多數標準函式庫中提供的型別都有實作這些特徵。對於你自己定義的結構體與枚舉，你需要實作 <code>PartialEq</code>，這樣該型別的數值才能判定相等或不相等。你需要實作 <code>Debug</code> 來顯示判定失敗時的數值。因爲這兩個特徵都是可推導的特徵，就像第五章的範例 5-12 所寫的那樣，我們通常只要在你定義的結構體或枚舉前加上 <code>#[derive(PartialEq, Debug)]</code> 的詮釋就好。你可以查閱附錄 C <a href="appendix-03-derivable-traits.html">“可推導的特徵,”</a><!-- ignore --> 來發現更多可推導的特徵。</p>
<h3><a class="header" href="#加入自訂失敗訊息" id="加入自訂失敗訊息">加入自訂失敗訊息</a></h3>
<p>你可以寫一個一個與失敗訊息一同顯示的自訂訊息，作爲 <code>assert!</code>、<code>assert_eq!</code> 與 <code>assert_ne!</code> 巨集的選擇性引數。任何指定在 <code>assert!</code> 一個必要引數或 <code>assert_eq!</code> 和 <code>assert_ne!</code> 兩個必要引數後方的任何引數都會傳給 <code>format!</code> 巨集（我們在第八章<a href="ch08-02-strings.html#%E4%BD%BF%E7%94%A8-%E9%81%8B%E7%AE%97%E5%AD%90%E6%88%96-format-%E5%B7%A8%E9%9B%86%E4%B8%B2%E6%8E%A5%E5%AD%97%E4%B8%B2">“Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro”</a><!-- ignore -->的段落討論過），所以你可以傳入一個包含 <code>{}</code> 佔位符（placeholder）的格式化字串以及其對應的數值。自訂訊息可以用來紀錄判定的意義，當測試失敗時，你可以更清楚知道程式碼的問題。</p>
<p>舉例來說，假設我們有個函式會以收到的名字像人們打招呼，而且我們希望測試我們傳入的名字有出現在輸出：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>此函式的要求還沒完全確定，而我們招呼開頭的文字 <code>Hello</code> 很可能會在之後改變。我們決定當需求改變時，我們不想要得同時更新測試。所以我們不打算檢查 <code>greeting</code> 函式回傳的整個數值，我們只需要判定輸出有沒有包含輸入參數。</p>
<p>讓我們將錯誤引進程式中吧，將 <code>greeting</code> 改成不會包含 <code>name</code> 然後看看測試會怎麼失敗：</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>執行此程式會產生以下錯誤：</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(&quot;Carol&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>此結果指出判定失敗以及發生的位置。現在要是錯誤訊息可以提供我們從 <code>greeting</code> 函式取得的數值就更好了。讓我們來在測試函式中加入自訂訊息，該訊息會是個格式化字串，並有個佔位符（placeholder）來填入我們從 <code>greeting</code> 函式取得的確切數值：</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hello!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Greeting did not contain name, value was `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span></code></pre>
<p>現在當我們執行測試，我們能從錯誤訊息得到更多資訊：</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>我們可以看到我們實際從測試輸出拿到的數值，這能幫助我們除錯找到實際發生什麼，而不只是預期會是什麼。</p>
<h3><a class="header" href="#透過-should_panic-檢查恐慌" id="透過-should_panic-檢查恐慌">透過 <code>should_panic</code> 檢查恐慌</a></h3>
<p>除了檢查我們的程式碼有沒有回傳我們預期的正確數值，檢查我們的程式碼有沒有如我們預期處理錯誤條件也是很重要的。舉例來說，考慮我們在第九章範例 9-10 建立的 <code>Guess</code> 型別。其他使用 <code>Guess</code> 的程式碼保證會拿到數值爲 1 到 100 的 <code>Guess</code> 實例。我們可以寫個會恐慌的程式，嘗試用範圍之外的數字建立 <code>Guess</code> 實例。</p>
<p>爲此我們可以加上另一個屬性 <code>should_panic</code> 到我們的測試函式。此屬性讓函式的程式碼恐慌時才會通過測試，反之如果函式的程式碼沒有恐慌的話測試就會失敗。</p>
<p>範例 11-8 展示一支檢查 <code>Guess::new</code> 是否以我們預期的錯誤條件出錯的測試。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 11-8：測試造成 <code>panic!</code> 的條件</span></p>
<p>我們將 <code>#[should_panic]</code> 屬性置於 <code>#[test]</code> 屬性之後與測試函式之前。讓我們看看測試通過的結果：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>看起來不錯！現在讓我們將錯誤引入程式碼中，移除會讓 <code>new</code> 函式在數值大於 100 會恐慌的程式碼：</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>當我們執行範例 11-8 的測試，它就會失敗：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>我們在此情況得到的訊息並不是很有用，但是當我們查看測試函式，我們會看到它詮釋了 <code>#[should_panic]</code>。這個測試失敗代表測試函式內的程式碼沒有造成恐慌。</p>
<p>使用 <code>should_panic</code> 的測試可能會有點模棱兩可，因爲它們只代表該程式碼會造成某種恐慌而已。<code>should_panic</code> 測試只要是有恐慌都會通過，就算是不同於我們預期發生地恐慌而造成的也一樣。要讓測試 <code>should_panic</code> 更精準的話，我們可以加上選擇性的 <code>expected</code> 參數到 <code>should_panic</code> 中。這樣測試就會確保錯誤訊息會包含我們所寫的文字。舉例來說，範例 11-9 更改了 <code>Guess</code> 讓 <code>new</code> 函式會依據數值太大或大小而有不同的錯誤訊息。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 11-9：只在造成 <code>panic!</code> 的特定錯誤訊息會通過的測試</span></p>
<p>此測試會通過是因爲我們在 <code>should_panic</code> 屬性加上的 <code>expected</code> 就是 <code>Guess::new</code> 函式恐慌時的子字串。我們也可以指定整個恐慌訊息，在此例的話就是 <code>Guess value must be less than or equal to 100, got 200.</code>。你在 <code>should_panic</code> 所指定的預期參數取決於該恐慌訊息是獨特或動態的，以及你希望你的測試要多精準。在此例中，恐慌訊息的子訊息就足以確認測試函式中的程式碼會執行 <code>else if value &gt; 100</code> 的分支。</p>
<p>爲了觀察擁有 <code>expected</code> 訊息的 <code>should_panic</code> 失敗時會發生什麼事。讓我同樣再次將錯誤引入程式中，將 <code>if value &lt; 1</code> 與 <code>else if value &gt; 100</code> 的區塊本體對調：</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>這次當我們執行 <code>should_panic</code> 測試，它就會失敗：</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;Guess value must be less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>錯誤訊息表示此程式碼的確有如我們預期地恐慌，但是恐慌訊息並沒有包含預期的字串 <code>'Guess value must be less than or equal to 100'</code>。在此例我們的會得到的恐慌訊息爲 <code>Guess value must be greater than or equal to 1, got 200.</code>。這樣我們就能尋找錯誤在哪了！</p>
<h3><a class="header" href="#在測試中使用-resultt-e" id="在測試中使用-resultt-e">在測試中使用 <code>Result&lt;T, E&gt;</code></a></h3>
<p>目前爲止，我們的測試在失敗時就會恐慌。我們也可以寫出使用 <code>Result&lt;T, E&gt;</code> 的測試！以下是範例 11-1 的測試，不過重寫成 <code>Result&lt;T, E&gt;</code> 的版本並回傳 <code>Err</code> 而非恐慌：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
</code></pre></pre>
<p><code>it_works</code> 函式現在有個回傳型別 <code>Result&lt;(), String&gt;</code>。在函式本體中，我們不再呼叫 <code>assert_eq!</code> 巨集，而是當測試成功時回傳 <code>Ok(())</code>，當程式失敗時回傳存有 <code>String</code> 的 <code>Err</code>。</p>
<p>測試中回傳 <code>Result&lt;T, E&gt;</code> 讓你可以在測試本體中使用問號運算子，這樣能方便地寫出任何運算回傳 <code>Err</code> 時該失敗的測試。</p>
<p>不過你就不能將 <code>#[should_panic]</code> 詮釋用在使用 <code>Result&lt;T, E&gt;</code> 的測試。當程式該失敗時，你必須直接回傳 <code>Err</code> 數值。</p>
<p>現在你知道了各種寫測試的方法，讓我們看看執行程式時發生了什麼事，並探索我們可以對 <code>cargo test</code> 使用的選項。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch11-01-writing-tests.md">e5ed971</a></li>
<li>updated: 2020-09-15</li>
</ul>
</blockquote>
<h2><a class="header" href="#控制程式如何執行" id="控制程式如何執行">控制程式如何執行</a></h2>
<p>就像 <code>cargo run</code> 會編譯你的程式碼並執行產生的二進制檔案，<code>cargo test</code> 會在測試模式編譯你的程式碼並執行產生的測試二進制檔案。你可以指定命令列選項來改變 <code>cargo test</code> 的預設行爲。舉例來說 <code>cargo test</code> 預設行爲產生的二進制執行檔會平行執行所有測試並獲取測試執行時產生的輸出，讓測試各自的輸出結果不會顯示出來，以更容易讀取相關測試的結果。</p>
<p>有些命令列選項用於 <code>cargo test</code> 而有些則用於產生的測試二進制檔案。要分開這兩種引數，你可以先寫奧用於 <code>cargo test</code> 的引數然後加上 <code>--</code> 分隔線來區隔要用於測試二進制檔案的引數。執行 <code>cargo test --help</code> 可以顯示你能用在 <code>cargo test</code> 的選項，而執行 <code>cargo test -- --help</code> 在則會顯示你在 <code>--</code> 之後能用的選項。</p>
<h3><a class="header" href="#平行或接續執行測試" id="平行或接續執行測試">平行或接續執行測試</a></h3>
<p>當你執行數個測試時，它們預設會使用執行緒（thread）來平行執行。這樣測試可以更快完成，讓你可以從你或其他人的程式碼更快獲得回饋。因爲測試是同時一起執行的，請確保你的測試並不依賴其他測試或是共享的狀態。這包含共享環境，像是目前的工作目錄或是環境變數。</p>
<p>舉例來說，假設你的每個測試都會執行些程式碼會在硬碟上產生一個檔案叫做 <em>test-output.txt</em> 並將一些資料寫入檔案中。然後每個測試讀取檔案中的資料，並判定該檔案有沒有包含特定的值，而這個值在每個測試都不相同。因爲測試同時執行，其中的測試可以能覆蓋其他測試寫入與讀取的內容。這樣其他測試就會失敗，並不是因爲程式碼不正確，而是因爲平行執行時該測試會被其他測試所影響。其中一個解決辦法是確保每個測試都寫入不同的檔案，或者也可以選擇一次只執行一個測試。</p>
<p>如果你不想平行執行測試，或者你想要能更加掌控使用的執行緒數量，你可以傳遞 <code>--test-threads</code> 的選項以及你希望在測試執行檔使用的執行緒數量。請看一下以下範例：</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>我們將測試執行緒設爲 <code>1</code>，告訴程式不要做任何平行化。使用一條執行緒執行測試會比平行執行它們還來的久，但是如果測試有共享狀態的話，它們就會不互相影響到對方了。</p>
<h3><a class="header" href="#顯示函式輸出結果" id="顯示函式輸出結果">顯示函式輸出結果</a></h3>
<p>如果測試通過的話，Rust 的測試函式庫預設會獲取所有印出的標準輸出。舉例來說，如果我們在測試中呼叫 <code>println!</code> 然後測試通過的話，我們不會在終端機看到 <code>println!</code> 的輸出，我們只會看到一行表達測試通過的訊息。如果測試失敗，我們才會看到所有印出的標準輸出與失敗訊息。</p>
<p>舉例來說，範例 11-10 有個蠢蠢的函式只會印出它的參數並回傳 10，以及一個會通過的測試與一個會失敗的測試。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics"><span class="boring">fn main() {}
</span><span class="boring">
</span>fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
</code></pre></pre>
<p><span class="caption">範例 11-10：測試會呼叫 <code>println!</code> 的函式</span></p>
<p>當我們使用 <code>cargo test</code> 執行這些程式時，我們會看到以下輸出結果：</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>注意到此輸出結果我們看不到 <code>I got the value 4</code>，這是當測試通過時印出的訊息。這個輸出被獲取走了。而測試會失敗的標準輸出 <code>I got the value 8</code> 則會出現在測試總結輸出的段落上，並同時顯示錯誤發生的原因。</p>
<p>如果我們希望在測試通過時也能看到印出的數值，我們可以用 <code>--show-output</code> 告訴 Rust 也在成功的測試顯示輸出結果。</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>當我們使用 <code>--show-output</code> 再次執行範例 11-10 的話，我們就能看到以下輸出：</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
I got the value 4


successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<h3><a class="header" href="#透過名稱來執行部分測試" id="透過名稱來執行部分測試">透過名稱來執行部分測試</a></h3>
<p>有時執行完整所有的測試會很花時間。如果你正專注於程式碼的特定部分，你可能會想要只執行與該程式碼有關的測試。你可以向 <code>cargo test</code> 傳遞你想要執行的測試名稱作爲引數。</p>
<p>爲了解釋如何執行部分測試，我們將爲 <code>add_two</code> 函式建立三個測試，如範例 11-11 所示，然後選擇其中一個執行。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 11-11：三個名稱不同的測試</span></p>
<p>如果我們沒有傳遞任何引數來執行測試的話，如我們前面看過的一樣，所有測試會平行執行：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/adder-92948b65e88960b4

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<h4><a class="header" href="#執行單獨一個測試" id="執行單獨一個測試">執行單獨一個測試</a></h4>
<p>我們可以傳遞任何測試函式的名稱給 <code>cargo test</code> 來只執行該測試：</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

</code></pre>
<p>只有名稱爲 <code>one_hundred</code> 的測試會執行，其他兩個的名稱並不符合。測試輸出會在總結的最後顯示 <code>2 filtered out</code> 告訴我們除了命令列執行的測試以外，還有更多其他測試。</p>
<p>我們無法用此方式指定多個測試名稱，只有第一個傳給 <code>cargo test</code> 有用。但我們有其他方式能執行數個測試。</p>
<h4><a class="header" href="#過濾執行數個測試" id="過濾執行數個測試">過濾執行數個測試</a></h4>
<p>我們可以指定部分測試名稱，然後任何測試名稱中有相符的就會被執行。舉例來說，因爲我們有兩個測試的名稱都包含 <code>add</code>，我們可以透過執行 <code>cargo test add</code> 來執行這兩個測試：</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

</code></pre>
<p>此命令會執行所有名稱中包含 <code>add</code> 的測試，並過濾掉 <code>one_hundred</code> 的測試名稱。另外測試所在的模組也屬於測試名稱中，所以我們可以透過過濾模組名稱來執行該模組的所有測試。</p>
<h3><a class="header" href="#忽略某些測試除非特別指定" id="忽略某些測試除非特別指定">忽略某些測試除非特別指定</a></h3>
<p>有時後有些特定的測試執行會花非常多時間，所以你可能希望在執行 <code>cargo test</code> 時能排除它們。與其列出所有你想要的測試作爲引數，你可以在花石間的測試前加上 <code>ignore</code> 屬性詮釋來排除它們，如以下所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>對於想排除的測試，我們在 <code>#[test]</code> 之後我們加上 <code>#[ignore]</code>。現在當我們執行我們的測試時，<code>it_works</code> 會執行但 <code>expensive_test</code> 就不會：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p><code>expensive_test</code> 函式會列在 <code>ignored</code>，如果我們希望只執行被忽略的測試，我們可以使用 <code>cargo test -- --ignored</code>：</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>透過控制哪些測試能執行，你能夠確保快速執行 <code>cargo test</code>。當你有時間能夠執行 <code>ignored</code> 的測試時，你可以執行 <code>cargo test -- --ignored</code> 來等待結果。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch11-02-running-tests.md">e5ed971</a></li>
<li>updated: 2020-09-17</li>
</ul>
</blockquote>
<h2><a class="header" href="#測試組織架構" id="測試組織架構">測試組織架構</a></h2>
<p>如同本章開頭提到的，測試是個複雜的領域，不同的人可能使用不同的術語與組織架構。Rust 社群將測試分爲兩大分類術語：<em>單元測試（unit tests）<em>和</em>整合測試（integration tests）</em>。單元測試比較小且較專注，傾向在隔離環境中一次只測試一個模組，且能夠測試私有介面。整合測試對於你的函式庫來說是個完全外部的程式碼，所以會如其他外部程式碼一樣使用你的程式碼，只能使用公開介面且每個測試可能會有數個模組。</p>
<p>這兩種測試都很重要，且能確保函式庫每個部分能在分別或一起執行的情況下，如你預期的方式運作。</p>
<h3><a class="header" href="#單元測試" id="單元測試">單元測試</a></h3>
<p>單元測試的目的是要在隔離其他程式碼的狀況下測試每個程式碼單元，迅速查明程式碼有沒有如預期或非預期的方式運作。你會將單元測試放在 <em>src</em> 目錄中每個你要測試的程式同個檔案下。我們常見的做法是在每個檔案建立一個模組 <code>tests</code> 來包含測試函式，並用 <code>cfg(test)</code> 來詮釋模組</p>
<h4><a class="header" href="#測試模組與-cfgtest" id="測試模組與-cfgtest">測試模組與 <code>#[cfg(test)]</code></a></h4>
<p>測試模組上的 <code>#[cfg(test)]</code> 詮釋會告訴 Rust 當你執行 <code>cargo test</code> 才會編譯並執行測試程式碼。而不是當你執行 <code>cargo build</code>。當你想要建構函式庫時，這能節省編譯時間並降低編譯出的檔案所佔的空間，因爲這些測試沒有被包含到。整合測試位於不同目錄，所以它們不需要 <code>#[cfg(test)]</code>。但是因爲單元測試與程式碼位於相同的檔案下，你需要使用 <code>#[cfg(test)]</code> 來指明它們不應該被包含在編譯結果。</p>
<p>回想一下本章節第一個段落中我們建立了一個新專案 <code>adder</code>，並用 Cargo 爲我們產生以下程式碼：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>此程式碼是自動產生的測試模組。<code>cfg</code> 屬性代表的是 <em>configuration</em> 並告訴 Rust 以下項目只有在給予特定配置選項時才會被考慮。在此例中配置選項是 <code>test</code>，這是 Rust 提供用來編譯與執行測試的選項。使用 <code>cfg</code> 屬性的話，Cargo 只有在我們透過 <code>cargo test</code> 執行測試時才會編譯我們的測試程式碼。這包含此模組能可能需要的輔助函式，以及用 <code>#[test]</code> 詮釋的測試函式。</p>
<h4><a class="header" href="#測試私有函式" id="測試私有函式">測試私有函式</a></h4>
<p>在測試領域的社群中對於是否應該直接測試私有函式一直存在著爭議，而且有些其他語言會讓測試私有函式變得很困難，甚至不可能。不管你認爲哪個論點比較理想，Rust 的隱私權規則還是能讓你肏是私有函式。考慮以下範例 11-12 擁有私有函式 <code>internal_adder</code> 的程式碼。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 11-12：測試私有函式</span></p>
<p>注意到函式 <code>internal_adder</code> 沒有標記爲 <code>pub</code>，但是因爲測試也只是 Rust 的程式碼，且 <code>tests</code> 也只是另一個模組，你可以將 <code>internal_adder</code> 引入測試的作用域並呼叫它。如果你不認爲私有函式不應該測試，Rust 也沒有什麼好阻止你的地方。</p>
<h3><a class="header" href="#整合測試" id="整合測試">整合測試</a></h3>
<p>在 Rust 中，整合測試對你的函式庫來說是完全外部的程式。它們使用你的函式庫的方式與其他程式碼一樣，所以它們只能呼叫屬於函式庫中公開 API 的函式。它們的目的是要測試你的函式庫屬個部分一起運作時有沒有正確無誤。單獨運作無誤的程式碼單元可能會在整合時出現問題，所以整合測試的程式碼的涵蓋率也很重要。要建立整合測試，你需要先有個 <em>tests</em> 目錄。</p>
<h4><a class="header" href="#tests-目錄" id="tests-目錄"><em>tests</em> 目錄</a></h4>
<p>我們在專案目錄最上層在 <em>src</em> 旁建立一個 <em>tests</em> 目錄。Cargo 知道要從此目錄來尋找整合測試。我們接著就可以在此目錄建立多少個測試都沒問題，Cargo會編譯每個檔案成獨立的 crate。</p>
<p>讓我們來建立一個整合測試，將範例 11-12 的程式碼保留在 <em>src/lib.rs</em> 檔案中，然後建立一個 <em>tests</em> 目錄、一個叫做 <em>tests/integration_test.rs</em> 的檔案並輸入範例 11-13 的程式碼。</p>
<p><span class="filename">檔案名稱：tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">範例 11-13：<code>adder</code> crate 中函式的整合測試</span></p>
<p>我們在程式最上方加了 <code>use adder</code>，這在單元測試是不需要的。這裡要用到的原因是因爲 <code>tests</code> 目錄的每個檔案都是獨立的 crate，所以我們需要將函式庫引入每個測試 crate 的作用域中。</p>
<p>我們不用對 <em>tests/integration_test.rs</em> 的任何程式碼詮釋 <code>#[cfg(test)]</code>。Cargo 會特別對待 <code>tests</code> 目錄並只在我們執行 <code>cargo test</code> 時，編譯此目錄的檔案。現在請執行 <code>cargo test</code>：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.73s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>輸出結果中有三個段落，包含單元測試、整合測試與技術文件測試。第一個段落的單元測試與我們看過的相同：每行會是每個單元測試（在此例是我們在範例 11-12 寫得 <code>internal</code>）最後附上單元測試的總結。</p>
<p>整合測試段落從 <code>Running target/debug/deps/integration_test-ce99bcc2479f4607</code> 開始（最後的雜湊值（hash）可能會與你的輸出不同），接著每行會是每個整合測試的測試函式，最後在 <code>Doc-tests adder</code> 段落開始前的那一行則是整合測試的總結結果。</p>
<p>當我們加入更多單元測試時，單元測試段落就會顯示更多結果。同樣地當我們將更多測試函式加入整合測試檔案內的話，該整合測試段落就會顯示更多結果。每個整合測試檔案會有自己的段落，如果如果我們在 <em>tests</em> 目錄加入更多檔案的話，就會出現更多整合測試段落。</p>
<p>我們一樣能用測試函式的名稱來作爲 <code>cargo test</code> 的引數，來執行特定整合測試。要執行特定整合測試檔案內的所有測試，可以用 <code>--test</code> 作爲 <code>cargo test</code> 的引數並加上檔案名稱：</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>此命令會只執行 <em>tests/integration_test.rs</em> 檔案內的測試。</p>
<h4><a class="header" href="#整合測試的子模組" id="整合測試的子模組">整合測試的子模組</a></h4>
<p>隨著你加入的整合測試越多，你可能會想要在 <em>tests</em> 目錄下產生更多檔案來協助組織它們。舉例來說，你以用測試函式測試的功能來組織它們。如同稍早提到的，<em>tests</em>  目錄下的每個檔案都會編譯成自己獨立的 crate。</p>
<p>將每個整合測試檔案視爲獨立的 crate 有助於建立不同的作用域，這就像是使用者使用你的 crate 的可能環境。然而這也代表 <em>tests</em> 目錄的檔案不會和 <em>src</em> 的檔案行爲一樣，也就是你在第七章學到如何拆開程式碼成模組與檔案的部分。</p>
<p>當你希望擁有一些能協助數個整合測試檔案的輔助函式，並遵循第七章的<a href="ch07-05-separating-modules-into-different-files.html">「將模組拆成不同檔案」</a><!-- ignore -->段落來提取它們到一個通用模組時，你就會發現 <em>tests</em> 目錄下的檔案行爲是不同的。舉例來說，我們建立了 <em>tests/common.rs</em> 並寫了一個函式 <code>setup</code>，然後我們希望 <code>setup</code> 能被不同測試檔案的數個測試函式呼叫：</p>
<p><span class="filename">檔案名稱：tests/common.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn setup() {
    // setup code specific to your library's tests would go here
}
<span class="boring">}
</span></code></pre></pre>
<p>當我們再次執行程式時，我們會看到測試輸出多了一個 <em>common.rs</em> 檔案的段落，就算該檔案沒有包含任何測試函式，而且我們也還沒有在任何地方呼叫 <code>setup</code> 函式：</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>讓 <code>common</code> 出現在測試結果並顯示 <code>running 0 tests</code> 並不是我們想做的事。我們只是想要分享一些程式碼給其他整合測試檔案而已。</p>
<p>要防止 <code>common</code> 出現在測試輸出，我們不該建立 <em>tests/common.rs</em>，而是要建立 <em>tests/common/mod.rs</em>。這是另一個 Rust 知道的常用命名手段。這樣命名檔案的話會告訴 Rust 不要將 <code>common</code> 模組視爲整合測試檔案。當我們將 <code>setup</code> 函式程式碼移到 <em>tests/common/mod.rs</em> 並刪除 <em>tests/common.rs</em> 檔案時，原本的段落就不會再出現在測試輸出。<em>tests</em> 目錄下子目錄的檔案不會被編譯成獨立 crate 或在測試輸出顯示段落。</p>
<p>在我們建立 <em>tests/common/mod.rs</em> 之後，我們可以將它以模組的形式用在任何整合測試檔案中。以下是在 <em>tests/integration_test.rs</em> 的 <code>it_adds_two</code> 測試中呼叫函式 <code>setup</code> 的範例：</p>
<p><span class="filename">檔案名稱：tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>注意到 <code>mod common;</code> 的宣告與我們在範例 7-21 說明的模組宣告方式一樣。然而後在測試函式中，我們就可以呼叫函式 <code>common::setup()</code>。</p>
<h4><a class="header" href="#二進制執行檔-crate-的整合測試" id="二進制執行檔-crate-的整合測試">二進制執行檔 Crate 的整合測試</a></h4>
<p>如果我們的專案是只包含 <em>src/main.rs</em> 檔案的二進制執行檔 crate 而沒有 <em>src/lib.rs</em> 檔案的話，我們無法在 <em>tests</em> 目錄下建立整合測試，也無法將 <em>src/main.rs</em> 檔案中定義的函式透過 <code>use</code> 陳述式引入作用域。只有函式庫 crate 能公開函式給其他 crate 使用，二進制 crate 只用於獨自執行。</p>
<p>這也是爲何 Rust 專案爲二進制執行檔提供直白的 <em>src/main.rs</em> 檔案並允許呼叫 <em>src/lib.rs</em> 檔案中的邏輯程式碼。使用這樣子的架構的話，整合測試<em>可以</em>透過 <code>use</code> 來測試函式庫 crate，並讓重點功能可以公開使用。如果重點功能可以運作的話，那 <em>src/main.rs</em> 檔案中剩下的程式碼部分也能夠如期執行，而這一小部分就不必特定做測試。</p>
<h2><a class="header" href="#總結-9" id="總結-9">總結</a></h2>
<p>Rust 的測試功能提供了判定程式碼怎樣才算正常運作的方法，以確保它能以你預期的方式運作，就算當你做了改變時也是如此。單元測試分別測試函式庫中每個不同的部分，且能測試私有實作細節。整合測試檢查函式庫數個部分一起執行時是否正確無誤，且它們使用函式庫公開 API 來測試程式碼的行爲與外部程式碼使用的方式一樣。雖然 Rust 型別系統與所有權規則能避免某些種類的程式錯誤，測試還是減少邏輯程式錯誤的重要辦法，讓你的程式碼能如預期行爲運作。</p>
<p>讓我們統整此章節以及之前的章節所學到的知識來寫一支專案吧！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch11-03-test-organization.md">e5ed971</a></li>
<li>updated: 2020-09-17</li>
</ul>
</blockquote>
<h1><a class="header" href="#an-io-project-building-a-command-line-program" id="an-io-project-building-a-command-line-program">An I/O Project: Building a Command Line Program</a></h1>
<p>This chapter is a recap of the many skills you’ve learned so far and an
exploration of a few more standard library features. We’ll build a command line
tool that interacts with file and command line input/output to practice some of
the Rust concepts you now have under your belt.</p>
<p>Rust’s speed, safety, single binary output, and cross-platform support make it
an ideal language for creating command line tools, so for our project, we’ll
make our own version of the classic command line tool <code>grep</code> (<strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). In the simplest use case,
<code>grep</code> searches a specified file for a specified string. To do so, <code>grep</code> takes
as its arguments a filename and a string. Then it reads the file, finds lines
in that file that contain the string argument, and prints those lines.</p>
<p>Along the way, we’ll show how to make our command line tool use features of the
terminal that many command line tools use. We’ll read the value of an
environment variable to allow the user to configure the behavior of our tool.
We’ll also print error messages to the standard error console stream (<code>stderr</code>)
instead of standard output (<code>stdout</code>), so, for example, the user can redirect
successful output to a file while still seeing error messages onscreen.</p>
<p>One Rust community member, Andrew Gallant, has already created a fully
featured, very fast version of <code>grep</code>, called <code>ripgrep</code>. By comparison, our
version of <code>grep</code> will be fairly simple, but this chapter will give you some of
the background knowledge you need to understand a real-world project such as
<code>ripgrep</code>.</p>
<p>Our <code>grep</code> project will combine a number of concepts you’ve learned so far:</p>
<ul>
<li>Organizing code (using what you learned about modules in <a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Chapter 7</a><!--
  ignore -->)</li>
<li>Using vectors and strings (collections, <a href="ch08-00-common-collections.html">Chapter 8</a><!-- ignore -->)</li>
<li>Handling errors (<a href="ch09-00-error-handling.html">Chapter 9</a><!-- ignore -->)</li>
<li>Using traits and lifetimes where appropriate (<a href="ch10-00-generics.html">Chapter 10</a><!-- ignore
  -->)</li>
<li>Writing tests (<a href="ch11-00-testing.html">Chapter 11</a><!-- ignore -->)</li>
</ul>
<p>We’ll also briefly introduce closures, iterators, and trait objects, which
Chapters <a href="ch13-00-functional-features.html">13</a><!-- ignore --> and <a href="ch17-00-oop.html">17</a><!-- ignore --> will cover in
detail.</p>
<h2><a class="header" href="#accepting-command-line-arguments" id="accepting-command-line-arguments">Accepting Command Line Arguments</a></h2>
<p>Let’s create a new project with, as always, <code>cargo new</code>. We’ll call our project
<code>minigrep</code> to distinguish it from the <code>grep</code> tool that you might already have
on your system.</p>
<pre><code class="language-console">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>The first task is to make <code>minigrep</code> accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with <code>cargo run</code>, a string to search for, and a path to a file to
search in, like so:</p>
<pre><code class="language-console">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Right now, the program generated by <code>cargo new</code> cannot process arguments we
give it. Some existing libraries on <a href="https://crates.io/">crates.io</a> can help
with writing a program that accepts command line arguments, but because you’re
just learning this concept, let’s implement this capability ourselves.</p>
<h3><a class="header" href="#reading-the-argument-values" id="reading-the-argument-values">Reading the Argument Values</a></h3>
<p>To enable <code>minigrep</code> to read the values of command line arguments we pass to
it, we’ll need a function provided in Rust’s standard library, which is
<code>std::env::args</code>. This function returns an iterator of the command line
arguments that were given to <code>minigrep</code>. We’ll cover iterators fully in
<a href="ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->. For now, you only need to know two details
about iterators: iterators produce a series of values, and we can call the
<code>collect</code> method on an iterator to turn it into a collection, such as a vector,
containing all the elements the iterator produces.</p>
<p>Use the code in Listing 12-1 to allow your <code>minigrep</code> program to read any
command line arguments passed to it and then collect the values into a vector.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">範例 12-1: Collecting the command line arguments into
a vector and printing them</span></p>
<p>First, we bring the <code>std::env</code> module into scope with a <code>use</code> statement so we
can use its <code>args</code> function. Notice that the <code>std::env::args</code> function is
nested in two levels of modules. As we discussed in <a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">Chapter
7</a><!-- ignore -->, in cases where the desired function is
nested in more than one module, it’s conventional to bring the parent module
into scope rather than the function. By doing so, we can easily use other
functions from <code>std::env</code>. It’s also less ambiguous than adding <code>use std::env::args</code> and then calling the function with just <code>args</code>, because <code>args</code>
might easily be mistaken for a function that’s defined in the current module.</p>
<blockquote>
<h3><a class="header" href="#the-args-function-and-invalid-unicode" id="the-args-function-and-invalid-unicode">The <code>args</code> Function and Invalid Unicode</a></h3>
<p>Note that <code>std::env::args</code> will panic if any argument contains invalid
Unicode. If your program needs to accept arguments containing invalid
Unicode, use <code>std::env::args_os</code> instead. That function returns an iterator
that produces <code>OsString</code> values instead of <code>String</code> values. We’ve chosen to
use <code>std::env::args</code> here for simplicity, because <code>OsString</code> values differ
per platform and are more complex to work with than <code>String</code> values.</p>
</blockquote>
<p>On the first line of <code>main</code>, we call <code>env::args</code>, and we immediately use
<code>collect</code> to turn the iterator into a vector containing all the values produced
by the iterator. We can use the <code>collect</code> function to create many kinds of
collections, so we explicitly annotate the type of <code>args</code> to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, <code>collect</code> is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.</p>
<p>Finally, we print the vector using the debug formatter, <code>:?</code>. Let’s try running
the code first with no arguments and then with two arguments:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[&quot;target/debug/minigrep&quot;]
</code></pre>
<pre><code class="language-console">$ cargo run needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Notice that the first value in the vector is <code>&quot;target/debug/minigrep&quot;</code>, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case you want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.</p>
<h3><a class="header" href="#saving-the-argument-values-in-variables" id="saving-the-argument-values-in-variables">Saving the Argument Values in Variables</a></h3>
<p>Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">範例 12-2: Creating variables to hold the query
argument and filename argument</span></p>
<p>As we saw when we printed the vector, the program’s name takes up the first
value in the vector at <code>args[0]</code>, so we’re starting at index <code>1</code>. The first
argument <code>minigrep</code> takes is the string we’re searching for, so we put a
reference to the first argument in the variable <code>query</code>. The second argument
will be the filename, so we put a reference to the second argument in the
variable <code>filename</code>.</p>
<p>We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments <code>test</code>
and <code>sample.txt</code>:</p>
<pre><code class="language-console">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file-reading
capabilities instead.</p>
<h2><a class="header" href="#reading-a-file" id="reading-a-file">Reading a File</a></h2>
<p>Now we’ll add functionality to read the file that is specified in the
<code>filename</code> command line argument. First, we need a sample file to test it with:
the best kind of file to use to make sure <code>minigrep</code> is working is one with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
<em>poem.txt</em> at the root level of your project, and enter the poem “I’m Nobody!
Who are you?”</p>
<p><span class="filename">檔案名稱：poem.txt</span></p>
<pre><code class="language-text">I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us - don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">範例 12-3: A poem by Emily Dickinson makes a good test
case</span></p>
<p>With the text in place, edit <em>src/main.rs</em> and add code to read the file, as
shown in Listing 12-4.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;
use std::fs;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let filename = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span>    println!(&quot;In file {}&quot;, filename);

    let contents = fs::read_to_string(filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">範例 12-4: Reading the contents of the file specified
by the second argument</span></p>
<p>First, we add another <code>use</code> statement to bring in a relevant part of the
standard library: we need <code>std::fs</code> to handle files.</p>
<p>In <code>main</code>, we’ve added a new statement: <code>fs::read_to_string</code> takes the
<code>filename</code>, opens that file, and returns a <code>Result&lt;String&gt;</code> of the file’s
contents.</p>
<p>After that statement, we’ve again added a temporary <code>println!</code> statement that
prints the value of <code>contents</code> after the file is read, so we can check that the
program is working so far.</p>
<p>Let’s run this code with any string as the first command line argument (because
we haven’t implemented the searching part yet) and the <em>poem.txt</em> file as the
second argument:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us - don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Great! The code read and then printed the contents of the file. But the code
has a few flaws. The <code>main</code> function has multiple responsibilities: generally,
functions are clearer and easier to maintain if each function is responsible
for only one idea. The other problem is that we’re not handling errors as well
as we could. The program is still small, so these flaws aren’t a big problem,
but as the program grows, it will be harder to fix them cleanly. It’s good
practice to begin refactoring early on when developing a program, because it’s
much easier to refactor smaller amounts of code. We’ll do that next.</p>
<h2><a class="header" href="#refactoring-to-improve-modularity-and-error-handling" id="refactoring-to-improve-modularity-and-error-handling">Refactoring to Improve Modularity and Error Handling</a></h2>
<p>To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors.</p>
<p>First, our <code>main</code> function now performs two tasks: it parses arguments and
reads files. For such a small function, this isn’t a major problem. However, if
we continue to grow our program inside <code>main</code>, the number of separate tasks the
<code>main</code> function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It’s best to separate functionality so each
function is responsible for one task.</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>filename</code>
are configuration variables to our program, variables like <code>contents</code> are used
to perform the program’s logic. The longer <code>main</code> becomes, the more variables
we’ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It’s best to group the
configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when
reading the file fails, but the error message just prints <code>Something went wrong reading the file</code>. Reading a file can fail in a number of ways: for example,
the file could be missing, or we might not have permission to open it. Right
now, regardless of the situation, we’d print the <code>Something went wrong reading the file</code> error message, which wouldn’t give the user any information!</p>
<p>Fourth, we use <code>expect</code> repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they’ll get an <code>index out of bounds</code> error from Rust that doesn’t clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
we’re printing messages that will be meaningful to our end users.</p>
<p>Let’s address these four problems by refactoring our project.</p>
<h3><a class="header" href="#separation-of-concerns-for-binary-projects" id="separation-of-concerns-for-binary-projects">Separation of Concerns for Binary Projects</a></h3>
<p>The organizational problem of allocating responsibility for multiple tasks to
the <code>main</code> function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when <code>main</code> starts getting large. The
process has the following steps:</p>
<ul>
<li>Split your program into a <em>main.rs</em> and a <em>lib.rs</em> and move your program’s
logic to <em>lib.rs</em>.</li>
<li>As long as your command line parsing logic is small, it can remain in
<em>main.rs</em>.</li>
<li>When the command line parsing logic starts getting complicated, extract it
from <em>main.rs</em> and move it to <em>lib.rs</em>.</li>
</ul>
<p>The responsibilities that remain in the <code>main</code> function after this process
should be limited to the following:</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>Handling the error if <code>run</code> returns an error</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the
program, and <em>lib.rs</em> handles all the logic of the task at hand. Because you
can’t test the <code>main</code> function directly, this structure lets you test all of
your program’s logic by moving it into functions in <em>lib.rs</em>. The only code
that remains in <em>main.rs</em> will be small enough to verify its correctness by
reading it. Let’s rework our program by following this process.</p>
<h4><a class="header" href="#extracting-the-argument-parser" id="extracting-the-argument-parser">Extracting the Argument Parser</a></h4>
<p>We’ll extract the functionality for parsing arguments into a function that
<code>main</code> will call to prepare for moving the command line parsing logic to
<em>src/lib.rs</em>. Listing 12-5 shows the new start of <code>main</code> that calls a new
function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em> for the moment.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span><span class="boring">    println!(&quot;In file {}&quot;, filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">範例 12-5: Extracting a <code>parse_config</code> function from
<code>main</code></span></p>
<p>We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable <code>query</code> and the
argument value at index 2 to the variable <code>filename</code> within the <code>main</code>
function, we pass the whole vector to the <code>parse_config</code> function. The
<code>parse_config</code> function then holds the logic that determines which argument
goes in which variable and passes the values back to <code>main</code>. We still create
the <code>query</code> and <code>filename</code> variables in <code>main</code>, but <code>main</code> no longer has the
responsibility of determining how the command line arguments and variables
correspond.</p>
<p>This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help identify the cause of problems when they occur.</p>
<h4><a class="header" href="#grouping-configuration-values" id="grouping-configuration-values">Grouping Configuration Values</a></h4>
<p>We can take another small step to improve the <code>parse_config</code> function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.</p>
<p>Another indicator that shows there’s room for improvement is the <code>config</code> part
of <code>parse_config</code>, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.</p>
<blockquote>
<p>Note: Using primitive values when a complex type would be more appropriate is
an anti-pattern known as <em>primitive obsession</em>.</p>
</blockquote>
<p>Listing 12-6 shows the improvements to the <code>parse_config</code> function.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">範例 12-6: Refactoring <code>parse_config</code> to return an
instance of a <code>Config</code> struct</span></p>
<p>We’ve added a struct named <code>Config</code> defined to have fields named <code>query</code> and
<code>filename</code>. The signature of <code>parse_config</code> now indicates that it returns a
<code>Config</code> value. In the body of <code>parse_config</code>, where we used to return string
slices that reference <code>String</code> values in <code>args</code>, we now define <code>Config</code> to
contain owned <code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of
the argument values and is only letting the <code>parse_config</code> function borrow
them, which means we’d violate Rust’s borrowing rules if <code>Config</code> tried to take
ownership of the values in <code>args</code>.</p>
<p>We could manage the <code>String</code> data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the <code>clone</code> method on
the values. This will make a full copy of the data for the <code>Config</code> instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don’t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.</p>
<blockquote>
<h3><a class="header" href="#the-trade-offs-of-using-clone" id="the-trade-offs-of-using-clone">The Trade-Offs of Using <code>clone</code></a></h3>
<p>There’s a tendency among many Rustaceans to avoid using <code>clone</code> to fix
ownership problems because of its runtime cost. In
<a href="ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->, you’ll learn how to use more efficient
methods in this type of situation. But for now, it’s okay to copy a few
strings to continue making progress because you’ll make these copies only
once and your filename and query string are very small. It’s better to have
a working program that’s a bit inefficient than to try to hyperoptimize code
on your first pass. As you become more experienced with Rust, it’ll be
easier to start with the most efficient solution, but for now, it’s
perfectly acceptable to call <code>clone</code>.</p>
</blockquote>
<p>We’ve updated <code>main</code> so it places the instance of <code>Config</code> returned by
<code>parse_config</code> into a variable named <code>config</code>, and we updated the code that
previously used the separate <code>query</code> and <code>filename</code> variables so it now uses
the fields on the <code>Config</code> struct instead.</p>
<p>Now our code more clearly conveys that <code>query</code> and <code>filename</code> are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the <code>config</code> instance in the fields
named for their purpose.</p>
<h4><a class="header" href="#creating-a-constructor-for-config" id="creating-a-constructor-for-config">Creating a Constructor for <code>Config</code></a></h4>
<p>So far, we’ve extracted the logic responsible for parsing the command line
arguments from <code>main</code> and placed it in the <code>parse_config</code> function. Doing so
helped us to see that the <code>query</code> and <code>filename</code> values were related and that
relationship should be conveyed in our code. We then added a <code>Config</code> struct to
name the related purpose of <code>query</code> and <code>filename</code> and to be able to return the
values’ names as struct field names from the <code>parse_config</code> function.</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code>
instance, we can change <code>parse_config</code> from a plain function to a function
named <code>new</code> that is associated with the <code>Config</code> struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as <code>String</code>, by calling <code>String::new</code>. Similarly, by
changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we’ll
be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7
shows the changes we need to make.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span>
    // --snip--
}

// --snip--

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">範例 12-7: Changing <code>parse_config</code> into
<code>Config::new</code></span></p>
<p>We’ve updated <code>main</code> where we were calling <code>parse_config</code> to instead call
<code>Config::new</code>. We’ve changed the name of <code>parse_config</code> to <code>new</code> and moved it
within an <code>impl</code> block, which associates the <code>new</code> function with <code>Config</code>. Try
compiling this code again to make sure it works.</p>
<h3><a class="header" href="#fixing-the-error-handling" id="fixing-the-error-handling">Fixing the Error Handling</a></h3>
<p>Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the <code>args</code> vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1 but the index is 1', src/main.rs:27:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>The line <code>index out of bounds: the len is 1 but the index is 1</code> is an error
message intended for programmers. It won’t help our end users understand what
happened and what they should do instead. Let’s fix that now.</p>
<h4><a class="header" href="#improving-the-error-message" id="improving-the-error-message">Improving the Error Message</a></h4>
<p>In Listing 12-8, we add a check in the <code>new</code> function that will verify that the
slice is long enough before accessing index 1 and 2. If the slice isn’t long
enough, the program panics and displays a better error message than the <code>index out of bounds</code> message.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span>    // --snip--
    fn new(args: &amp;[String]) -&gt; Config {
        if args.len() &lt; 3 {
            panic!(&quot;not enough arguments&quot;);
        }
        // --snip--
<span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Config { query, filename }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-8: Adding a check for the number of
arguments</span></p>
<p>This code is similar to <a href="ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">the <code>Guess::new</code> function we wrote in Listing
9-10</a><!-- ignore -->, where we called <code>panic!</code> when the
<code>value</code> argument was out of the range of valid values. Instead of checking for
a range of values here, we’re checking that the length of <code>args</code> is at least 3
and the rest of the function can operate under the assumption that this
condition has been met. If <code>args</code> has fewer than three items, this condition
will be true, and we call the <code>panic!</code> macro to end the program immediately.</p>
<p>With these extra few lines of code in <code>new</code>, let’s run the program without any
arguments again to see what the error looks like now:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps using
the technique we used in Listing 9-10 isn’t the best to use here: a call to
<code>panic!</code> is more appropriate for a programming problem than a usage problem,
<a href="ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">as discussed in Chapter 9</a><!-- ignore -->. Instead, we
can use the other technique you learned about in Chapter 9—<a href="ch09-02-recoverable-errors-with-result.html">returning a
<code>Result</code></a><!-- ignore --> that indicates either success or an error.</p>
<h4><a class="header" href="#returning-a-result-from-new-instead-of-calling-panic" id="returning-a-result-from-new-instead-of-calling-panic">Returning a <code>Result</code> from <code>new</code> Instead of Calling <code>panic!</code></a></h4>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in
the successful case and will describe the problem in the error case. When
<code>Config::new</code> is communicating to <code>main</code>, we can use the <code>Result</code> type to
signal there was a problem. Then we can change <code>main</code> to convert an <code>Err</code>
variant into a more practical error for our users without the surrounding text
about <code>thread 'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>Listing 12-9 shows the changes we need to make to the return value of
<code>Config::new</code> and the body of the function needed to return a <code>Result</code>. Note
that this won’t compile until we update <code>main</code> as well, which we’ll do in the
next listing.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">範例 12-9: Returning a <code>Result</code> from
<code>Config::new</code></span></p>
<p>Our <code>new</code> function now returns a <code>Result</code> with a <code>Config</code> instance in the
success case and a <code>&amp;'static str</code> in the error case. Recall from <a href="ch10-03-lifetime-syntax.html#the-static-lifetime">“The Static
Lifetime”</a><!-- ignore --> section in Chapter 10 that
<code>&amp;'static str</code> is the type of string literals, which is our error message type
for now.</p>
<p>We’ve made two changes in the body of the <code>new</code> function: instead of calling
<code>panic!</code> when the user doesn’t pass enough arguments, we now return an <code>Err</code>
value, and we’ve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes
make the function conform to its new type signature.</p>
<p>Returning an <code>Err</code> value from <code>Config::new</code> allows the <code>main</code> function to
handle the <code>Result</code> value returned from the <code>new</code> function and exit the process
more cleanly in the error case.</p>
<h4><a class="header" href="#calling-confignew-and-handling-errors" id="calling-confignew-and-handling-errors">Calling <code>Config::new</code> and Handling Errors</a></h4>
<p>To handle the error case and print a user-friendly message, we need to update
<code>main</code> to handle the <code>Result</code> being returned by <code>Config::new</code>, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code from <code>panic!</code> and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span>use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(config.filename)
</span><span class="boring">        .expect(&quot;Something went wrong reading the file&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-10: Exiting with an error code if creating a
new <code>Config</code> fails</span></p>
<p>In this listing, we’ve used a method we haven’t covered before:
<code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library.
Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error
handling. If the <code>Result</code> is an <code>Ok</code> value, this method’s behavior is similar
to <code>unwrap</code>: it returns the inner value <code>Ok</code> is wrapping. However, if the value
is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is an
anonymous function we define and pass as an argument to <code>unwrap_or_else</code>. We’ll
cover closures in more detail in <a href="ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->. For now,
you just need to know that <code>unwrap_or_else</code> will pass the inner value of the
<code>Err</code>, which in this case is the static string <code>not enough arguments</code> that we
added in Listing 12-9, to our closure in the argument <code>err</code> that appears
between the vertical pipes. The code in the closure can then use the <code>err</code>
value when it runs.</p>
<p>We’ve added a new <code>use</code> line to bring <code>process</code> from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the <code>err</code> value and then call <code>process::exit</code>. The
<code>process::exit</code> function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
<code>panic!</code>-based handling we used in Listing 12-8, but we no longer get all the
extra output. Let’s try it:</p>
<pre><code class="language-console">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<h3><a class="header" href="#extracting-logic-from-main" id="extracting-logic-from-main">Extracting Logic from <code>main</code></a></h3>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in <a href="ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">“Separation of Concerns for Binary
Projects”</a><!-- ignore -->, we’ll
extract a function named <code>run</code> that will hold all the logic currently in the
<code>main</code> function that isn’t involved with setting up configuration or handling
errors. When we’re done, <code>main</code> will be concise and easy to verify by
inspection, and we’ll be able to write tests for all the other logic.</p>
<p>Listing 12-11 shows the extracted <code>run</code> function. For now, we’re just making
the small, incremental improvement of extracting the function. We’re still
defining the function in <em>src/main.rs</em>.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-11: Extracting a <code>run</code> function containing the
rest of the program logic</span></p>
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code>, starting
from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an
argument.</p>
<h4><a class="header" href="#returning-errors-from-the-run-function" id="returning-errors-from-the-run-function">Returning Errors from the <code>run</code> Function</a></h4>
<p>With the remaining program logic separated into the <code>run</code> function, we can
improve the error handling, as we did with <code>Config::new</code> in Listing 12-9.
Instead of allowing the program to panic by calling <code>expect</code>, the <code>run</code>
function will return a <code>Result&lt;T, E&gt;</code> when something goes wrong. This will let
us further consolidate into <code>main</code> the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of <code>run</code>.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span>use std::error::Error;

// --snip--

<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span><span class="boring">    run(config);
</span><span class="boring">}
</span><span class="boring">
</span>fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
<span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-12: Changing the <code>run</code> function to return
<code>Result</code></span></p>
<p>We’ve made three significant changes here. First, we changed the return type of
the <code>run</code> function to <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. This function previously
returned the unit type, <code>()</code>, and we keep that as the value returned in the
<code>Ok</code> case.</p>
<p>For the error type, we used the <em>trait object</em> <code>Box&lt;dyn Error&gt;</code> (and we’ve
brought <code>std::error::Error</code> into scope with a <code>use</code> statement at the top).
We’ll cover trait objects in <a href="ch17-00-oop.html">Chapter 17</a><!-- ignore -->. For now, just
know that <code>Box&lt;dyn Error&gt;</code> means the function will return a type that
implements the <code>Error</code> trait, but we don’t have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The <code>dyn</code> keyword is short
for “dynamic.”</p>
<p>Second, we’ve removed the call to <code>expect</code> in favor of the <code>?</code> operator, as we
talked about in <a href="ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">Chapter 9</a><!-- ignore -->. Rather than
<code>panic!</code> on an error, <code>?</code> will return the error value from the current function
for the caller to handle.</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case. We’ve
declared the <code>run</code> function’s success type as <code>()</code> in the signature, which
means we need to wrap the unit type value in the <code>Ok</code> value. This <code>Ok(())</code>
syntax might look a bit strange at first, but using <code>()</code> like this is the
idiomatic way to indicate that we’re calling <code>run</code> for its side effects only;
it doesn’t return a value we need.</p>
<p>When you run this code, it will compile but will display a warning:</p>
<pre><code class="language-console">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
warning: unused `std::result::Result` that must be used
  --&gt; src/main.rs:19:5
   |
19 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

    Finished dev [unoptimized + debuginfo] target(s) in 0.71s
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I’m nobody! Who are you?
Are you nobody, too?
Then there’s a pair of us - don’t tell!
They’d banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

</code></pre>
<p>Rust tells us that our code ignored the <code>Result</code> value and the <code>Result</code> value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Let’s rectify that problem now.</p>
<h4><a class="header" href="#handling-errors-returned-from-run-in-main" id="handling-errors-returned-from-run-in-main">Handling Errors Returned from <code>run</code> in <code>main</code></a></h4>
<p>We’ll check for errors and handle them using a technique similar to one we used
with <code>Config::new</code> in Listing 12-10, but with a slight difference:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::process;
</span><span class="boring">
</span>fn main() {
    // --snip--

<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span>    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
<span class="boring">
</span><span class="boring">fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We use <code>if let</code> rather than <code>unwrap_or_else</code> to check whether <code>run</code> returns an
<code>Err</code> value and call <code>process::exit(1)</code> if it does. The <code>run</code> function doesn’t
return a value that we want to <code>unwrap</code> in the same way that <code>Config::new</code>
returns the <code>Config</code> instance. Because <code>run</code> returns <code>()</code> in the success case,
we only care about detecting an error, so we don’t need <code>unwrap_or_else</code> to
return the unwrapped value because it would only be <code>()</code>.</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in
both cases: we print the error and exit.</p>
<h3><a class="header" href="#splitting-code-into-a-library-crate" id="splitting-code-into-a-library-crate">Splitting Code into a Library Crate</a></h3>
<p>Our <code>minigrep</code> project is looking good so far! Now we’ll split the
<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file so we can test
it and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>Let’s move all the code that isn’t the <code>main</code> function from <em>src/main.rs</em> to
<em>src/lib.rs</em>:</p>
<ul>
<li>The <code>run</code> function definition</li>
<li>The relevant <code>use</code> statements</li>
<li>The definition of <code>Config</code></li>
<li>The <code>Config::new</code> function definition</li>
</ul>
<p>The contents of <em>src/lib.rs</em> should have the signatures shown in Listing 12-13
(we’ve omitted the bodies of the functions for brevity). Note that this won’t
compile until we modify <em>src/main.rs</em> in Listing 12-14.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span>    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
<span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    println!(&quot;With text:\n{}&quot;, contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span>}
</code></pre>
<p><span class="caption">範例 12-13: Moving <code>Config</code> and <code>run</code> into
<em>src/lib.rs</em></span></p>
<p>We’ve made liberal use of the <code>pub</code> keyword: on <code>Config</code>, on its fields and its
<code>new</code> method, and on the <code>run</code> function. We now have a library crate that has a
public API that we can test!</p>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em>, as shown in Listing 12-14.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let config = Config::new(&amp;args).unwrap_or_else(|err| {
</span><span class="boring">        println!(&quot;Problem parsing arguments: {}&quot;, err);
</span><span class="boring">        process::exit(1);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, config.query);
</span><span class="boring">    println!(&quot;In file {}&quot;, config.filename);
</span><span class="boring">
</span>    if let Err(e) = minigrep::run(config) {
        // --snip--
<span class="boring">        println!(&quot;Application error: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span>    }
}
</code></pre>
<p><span class="caption">範例 12-14: Using the <code>minigrep</code> library crate in
<em>src/main.rs</em></span></p>
<p>We add a <code>use minigrep::Config</code> line to bring the <code>Config</code> type from the
library crate into the binary crate’s scope, and we prefix the <code>run</code> function
with our crate name. Now all the functionality should be connected and should
work. Run the program with <code>cargo run</code> and make sure everything works
correctly.</p>
<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!</p>
<h2><a class="header" href="#developing-the-librarys-functionality-with-test-driven-development" id="developing-the-librarys-functionality-with-test-driven-development">Developing the Library’s Functionality with Test-Driven Development</a></h2>
<p>Now that we’ve extracted the logic into <em>src/lib.rs</em> and left the argument
collecting and error handling in <em>src/main.rs</em>, it’s much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line. Feel free to write some tests for the functionality in
the <code>Config::new</code> and <code>run</code> functions on your own.</p>
<p>In this section, we’ll add the searching logic to the <code>minigrep</code> program by
using the Test-driven development (TDD) process. This software development
technique follows these steps:</p>
<ol>
<li>Write a test that fails and run it to make sure it fails for the reason you
expect.</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>Refactor the code you just added or changed and make sure the tests
continue to pass.</li>
<li>Repeat from step 1!</li>
</ol>
<p>This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.</p>
<p>We’ll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We’ll add this functionality in a function called
<code>search</code>.</p>
<h3><a class="header" href="#writing-a-failing-test" id="writing-a-failing-test">Writing a Failing Test</a></h3>
<p>Because we don’t need them anymore, let’s remove the <code>println!</code> statements from
<em>src/lib.rs</em> and <em>src/main.rs</em> that we used to check the program’s behavior.
Then, in <em>src/lib.rs</em>, we’ll add a <code>tests</code> module with a test function, as we
did in <a href="ch11-01-writing-tests.html#the-anatomy-of-a-test-function">Chapter 11</a><!-- ignore -->. The test function specifies
the behavior we want the <code>search</code> function to have: it will take a query and
the text to search for the query in, and it will return only the lines from the
text that contain the query. Listing 12-15 shows this test, which won’t compile
yet.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">範例 12-15: Creating a failing test for the <code>search</code>
function we wish we had</span></p>
<p>This test searches for the string <code>&quot;duct&quot;</code>. The text we’re searching is three
lines, only one of which contains <code>&quot;duct&quot;</code>. We assert that the value returned
from the <code>search</code> function contains only the line we expect.</p>
<p>We aren’t able to run this test and watch it fail because the test doesn’t even
compile: the <code>search</code> function doesn’t exist yet! So now we’ll add just enough
code to get the test to compile and run by adding a definition of the <code>search</code>
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn’t match a vector
containing the line <code>&quot;safe, fast, productive.&quot;</code></p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 12-16: Defining just enough of the <code>search</code>
function so our test will compile</span></p>
<p>Notice that we need an explicit lifetime <code>'a</code> defined in the signature of
<code>search</code> and used with the <code>contents</code> argument and the return value. Recall in
<a href="ch10-03-lifetime-syntax.html">Chapter 10</a><!-- ignore --> that the lifetime parameters
specify which argument lifetime is connected to the lifetime of the return
value. In this case, we indicate that the returned vector should contain string
slices that reference slices of the argument <code>contents</code> (rather than the
argument <code>query</code>).</p>
<p>In other words, we tell Rust that the data returned by the <code>search</code> function
will live as long as the data passed into the <code>search</code> function in the
<code>contents</code> argument. This is important! The data referenced <em>by</em> a slice needs
to be valid for the reference to be valid; if the compiler assumes we’re making
string slices of <code>query</code> rather than <code>contents</code>, it will do its safety checking
incorrectly.</p>
<p>If we forget the lifetime annotations and try to compile this function, we’ll
get this error:</p>
<pre><code class="language-console">$ cargo build
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
error[E0106]: missing lifetime specifier
  --&gt; src/lib.rs:28:51
   |
28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
   |                                                   ^ expected lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `minigrep`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust can’t possibly know which of the two arguments we need, so we need to tell
it. Because <code>contents</code> is the argument that contains all of our text and we
want to return the parts of that text that match, we know <code>contents</code> is the
argument that should be connected to the return value using the lifetime syntax.</p>
<p>Other programming languages don’t require you to connect arguments to return
values in the signature. Although this might seem strange, it will get easier
over time. You might want to compare this example with the <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Validating
References with Lifetimes”</a><!-- ignore
--> section in Chapter 10.</p>
<p>Now let’s run the test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 0.97s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `[&quot;safe, fast, productive.&quot;]`,
 right: `[]`', src/lib.rs:44:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Great, the test fails, exactly as we expected. Let’s get the test to pass!</p>
<h3><a class="header" href="#writing-code-to-pass-the-test" id="writing-code-to-pass-the-test">Writing Code to Pass the Test</a></h3>
<p>Currently, our test is failing because we always return an empty vector. To fix
that and implement <code>search</code>, our program needs to follow these steps:</p>
<ul>
<li>Iterate through each line of the contents.</li>
<li>Check whether the line contains our query string.</li>
<li>If it does, add it to the list of values we’re returning.</li>
<li>If it doesn’t, do nothing.</li>
<li>Return the list of results that match.</li>
</ul>
<p>Let’s work through each step, starting with iterating through lines.</p>
<h4><a class="header" href="#iterating-through-lines-with-the-lines-method" id="iterating-through-lines-with-the-lines-method">Iterating Through Lines with the <code>lines</code> Method</a></h4>
<p>Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note this
won’t compile yet.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-17: Iterating through each line in <code>contents</code>
</span></p>
<p>The <code>lines</code> method returns an iterator. We’ll talk about iterators in depth in
<a href="ch13-02-iterators.html">Chapter 13</a><!-- ignore -->, but recall that you saw this way of using an
iterator in <a href="ch03-05-control-flow.html#looping-through-a-collection-with-for">Listing 3-5</a><!-- ignore -->, where we used a <code>for</code> loop
with an iterator to run some code on each item in a collection.</p>
<h4><a class="header" href="#searching-each-line-for-the-query" id="searching-each-line-for-the-query">Searching Each Line for the Query</a></h4>
<p>Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named <code>contains</code> that does this for
us! Add a call to the <code>contains</code> method in the <code>search</code> function, as shown in
Listing 12-18. Note this still won’t compile yet.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-18: Adding functionality to see whether the
line contains the string in <code>query</code></span></p>
<h4><a class="header" href="#storing-matching-lines" id="storing-matching-lines">Storing Matching Lines</a></h4>
<p>We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the <code>for</code> loop and call the <code>push</code> method
to store a <code>line</code> in the vector. After the <code>for</code> loop, we return the vector, as
shown in Listing 12-19.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 12-19: Storing the lines that match so we can
return them</span></p>
<p>Now the <code>search</code> function should return only the lines that contain <code>query</code>,
and our test should pass. Let’s run the test:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.22s
     Running target/debug/deps/minigrep-4672b652f7794785

running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>Our test passed, so we know it works!</p>
<p>At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in <a href="ch13-02-iterators.html">Chapter 13</a><!-- ignore -->, where we’ll
explore iterators in detail, and look at how to improve it.</p>
<h4><a class="header" href="#using-the-search-function-in-the-run-function" id="using-the-search-function-in-the-run-function">Using the <code>search</code> Function in the <code>run</code> Function</a></h4>
<p>Now that the <code>search</code> function is working and tested, we need to call <code>search</code>
from our <code>run</code> function. We need to pass the <code>config.query</code> value and the
<code>contents</code> that <code>run</code> reads from the file to the <code>search</code> function. Then <code>run</code>
will print each line returned from <code>search</code>:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We’re still using a <code>for</code> loop to return each line from <code>search</code> and print it.</p>
<p>Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, “frog”:</p>
<pre><code class="language-console">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38s
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Now let’s try a word that will match multiple lines, like “body”:</p>
<pre><code class="language-console">$ cargo run body poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as “monomorphization”:</p>
<pre><code class="language-console">$ cargo run monomorphization poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.</p>
<p>To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.</p>
<h2><a class="header" href="#working-with-environment-variables" id="working-with-environment-variables">Working with Environment Variables</a></h2>
<p>We’ll improve <code>minigrep</code> by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but instead we’ll use an
environment variable. Doing so allows our users to set the environment variable
once and have all their searches be case insensitive in that terminal session.</p>
<h3><a class="header" href="#writing-a-failing-test-for-the-case-insensitive-search-function" id="writing-a-failing-test-for-the-case-insensitive-search-function">Writing a Failing Test for the Case-Insensitive <code>search</code> Function</a></h3>
<p>We want to add a new <code>search_case_insensitive</code> function that we’ll call when
the environment variable is on. We’ll continue to follow the TDD process, so
the first step is again to write a failing test. We’ll add a new test for the
new <code>search_case_insensitive</code> function and rename our old test from
<code>one_result</code> to <code>case_sensitive</code> to clarify the differences between the two
tests, as shown in Listing 12-20.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 12-20: Adding a new failing test for the
case-insensitive function we’re about to add</span></p>
<p>Note that we’ve edited the old test’s <code>contents</code> too. We’ve added a new line
with the text <code>&quot;Duct tape.&quot;</code> using a capital D that shouldn’t match the query
<code>&quot;duct&quot;</code> when we’re searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don’t accidentally break the case-sensitive
search functionality that we’ve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.</p>
<p>The new test for the case-<em>insensitive</em> search uses <code>&quot;rUsT&quot;</code> as its query. In
the <code>search_case_insensitive</code> function we’re about to add, the query <code>&quot;rUsT&quot;</code>
should match the line containing <code>&quot;Rust:&quot;</code> with a capital R and match the line
<code>&quot;Trust me.&quot;</code> even though both have different casing from the query. This is
our failing test, and it will fail to compile because we haven’t yet defined
the <code>search_case_insensitive</code> function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the <code>search</code> function in Listing 12-16 to see the test compile and fail.</p>
<h3><a class="header" href="#implementing-the-search_case_insensitive-function" id="implementing-the-search_case_insensitive-function">Implementing the <code>search_case_insensitive</code> Function</a></h3>
<p>The <code>search_case_insensitive</code> function, shown in Listing 12-21, will be almost
the same as the <code>search</code> function. The only difference is that we’ll lowercase
the <code>query</code> and each <code>line</code> so whatever the case of the input arguments,
they’ll be the same case when we check whether the line contains the query.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    for line in search(&amp;config.query, &amp;contents) {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search_case_insensitive&lt;'a&gt;(
    query: &amp;str,
    contents: &amp;'a str,
) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 12-21: Defining the <code>search_case_insensitive</code>
function to lowercase the query and the line before comparing them</span></p>
<p>First, we lowercase the <code>query</code> string and store it in a shadowed variable with
the same name. Calling <code>to_lowercase</code> on the query is necessary so no matter
whether the user’s query is <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code>, or <code>&quot;rUsT&quot;</code>, we’ll
treat the query as if it were <code>&quot;rust&quot;</code> and be insensitive to the case. While
<code>to_lowercase</code> will handle basic Unicode, it won't be 100% accurate. If we were
writing a real application, we'd want to do a bit more work here, but this section
is about environment variables, not Unicode, so we'll leave it at that here.</p>
<p>Note that <code>query</code> is now a <code>String</code> rather than a string slice, because calling
<code>to_lowercase</code> creates new data rather than referencing existing data. Say the
query is <code>&quot;rUsT&quot;</code>, as an example: that string slice doesn’t contain a lowercase
<code>u</code> or <code>t</code> for us to use, so we have to allocate a new <code>String</code> containing
<code>&quot;rust&quot;</code>. When we pass <code>query</code> as an argument to the <code>contains</code> method now, we
need to add an ampersand because the signature of <code>contains</code> is defined to take
a string slice.</p>
<p>Next, we add a call to <code>to_lowercase</code> on each <code>line</code> before we check whether it
contains <code>query</code> to lowercase all characters. Now that we’ve converted <code>line</code>
and <code>query</code> to lowercase, we’ll find matches no matter what the case of the
query is.</p>
<p>Let’s see if this implementation passes the tests:</p>
<pre><code class="language-console">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished test [unoptimized + debuginfo] target(s) in 1.33s
     Running target/debug/deps/minigrep-4672b652f7794785

running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/minigrep-caf9dbee196c78b9

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests minigrep

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<p>Great! They passed. Now, let’s call the new <code>search_case_insensitive</code> function
from the <code>run</code> function. First, we’ll add a configuration option to the
<code>Config</code> struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors because we aren’t initializing
this field anywhere yet:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
<span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Note that we added the <code>case_sensitive</code> field that holds a Boolean. Next, we
need the <code>run</code> function to check the <code>case_sensitive</code> field’s value and use
that to decide whether to call the <code>search</code> function or the
<code>search_case_insensitive</code> function, as shown in Listing 12-22. Note this still
won’t compile yet.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">範例 12-22: Calling either <code>search</code> or
<code>search_case_insensitive</code> based on the value in <code>config.case_sensitive</code></span></p>
<p>Finally, we need to check for the environment variable. The functions for
working with environment variables are in the <code>env</code> module in the standard
library, so we want to bring that module into scope with a <code>use std::env;</code> line
at the top of <em>src/lib.rs</em>. Then we’ll use the <code>var</code> function from the <code>env</code>
module to check for an environment variable named <code>CASE_INSENSITIVE</code>, as shown
in Listing 12-23.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;
// --snip--

<span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 12-23: Checking for an environment variable named
<code>CASE_INSENSITIVE</code></span></p>
<p>Here, we create a new variable <code>case_sensitive</code>. To set its value, we call the
<code>env::var</code> function and pass it the name of the <code>CASE_INSENSITIVE</code> environment
variable. The <code>env::var</code> function returns a <code>Result</code> that will be the successful
<code>Ok</code> variant that contains the value of the environment variable if the
environment variable is set. It will return the <code>Err</code> variant if the
environment variable is not set.</p>
<p>We’re using the <code>is_err</code> method on the <code>Result</code> to check whether it’s an error
and therefore unset, which means it <em>should</em> do a case-sensitive search. If the
<code>CASE_INSENSITIVE</code> environment variable is set to anything, <code>is_err</code> will
return false and the program will perform a case-insensitive search. We don’t
care about the <em>value</em> of the environment variable, just whether it’s set or
unset, so we’re checking <code>is_err</code> rather than using <code>unwrap</code>, <code>expect</code>, or any
of the other methods we’ve seen on <code>Result</code>.</p>
<p>We pass the value in the <code>case_sensitive</code> variable to the <code>Config</code> instance so
the <code>run</code> function can read that value and decide whether to call <code>search</code> or
<code>search_case_insensitive</code>, as we implemented in Listing 12-22.</p>
<p>Let’s give it a try! First, we’ll run our program without the environment
variable set and with the query <code>to</code>, which should match any line that contains
the word “to” in all lowercase:</p>
<pre><code class="language-console">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Looks like that still works! Now, let’s run the program with <code>CASE_INSENSITIVE</code>
set to <code>1</code> but with the same query <code>to</code>.</p>
<p>If you're using PowerShell, you will need to set the environment
variable and run the program as separate commands:</p>
<pre><code class="language-console">PS&gt; $Env:CASE_INSENSITIVE=1; cargo run to poem.txt
</code></pre>
<p>This will make <code>CASE_INSENSITIVE</code> persist for the remainder of your shell
session. It can be unset with the <code>Remove-Item</code> cmdlet:</p>
<pre><code class="language-console">PS&gt; Remove-Item Env:CASE_INSENSITIVE
</code></pre>
<p>We should get lines that contain “to” that might have uppercase letters:</p>
<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
CASE_INSENSITIVE=1 cargo run to poem.txt
can't extract because of the environment variable
-->
<pre><code class="language-console">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excellent, we also got lines containing “To”! Our <code>minigrep</code> program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.</p>
<p>Some programs allow arguments <em>and</em> environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through either a command line argument or an environment
variable. Decide whether the command line argument or the environment variable
should take precedence if the program is run with one set to case sensitive and
one set to case insensitive.</p>
<p>The <code>std::env</code> module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.</p>
<h2><a class="header" href="#writing-error-messages-to-standard-error-instead-of-standard-output" id="writing-error-messages-to-standard-error-instead-of-standard-output">Writing Error Messages to Standard Error Instead of Standard Output</a></h2>
<p>At the moment, we’re writing all of our output to the terminal using the
<code>println!</code> macro. Most terminals provide two kinds of output: <em>standard
output</em> (<code>stdout</code>) for general information and <em>standard error</em> (<code>stderr</code>)
for error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.</p>
<p>The <code>println!</code> macro is only capable of printing to standard output, so we
have to use something else to print to standard error.</p>
<h3><a class="header" href="#checking-where-errors-are-written" id="checking-where-errors-are-written">Checking Where Errors Are Written</a></h3>
<p>First, let’s observe how the content printed by <code>minigrep</code> is currently being
written to standard output, including any error messages we want to write to
standard error instead. We’ll do that by redirecting the standard output stream
to a file while also intentionally causing an error. We won’t redirect the
standard error stream, so any content sent to standard error will continue to
display on the screen.</p>
<p>Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well-behaved:
we’re about to see that it saves the error message output to a file instead!</p>
<p>The way to demonstrate this behavior is by running the program with <code>&gt;</code> and the
filename, <em>output.txt</em>, that we want to redirect the standard output stream to.
We won’t pass any arguments, which should cause an error:</p>
<pre><code class="language-console">$ cargo run &gt; output.txt
</code></pre>
<p>The <code>&gt;</code> syntax tells the shell to write the contents of standard output to
<em>output.txt</em> instead of the screen. We didn’t see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what <em>output.txt</em> contains:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Yup, our error message is being printed to standard output. It’s much more
useful for error messages like this to be printed to standard error so only
data from a successful run ends up in the file. We’ll change that.</p>
<h3><a class="header" href="#printing-errors-to-standard-error" id="printing-errors-to-standard-error">Printing Errors to Standard Error</a></h3>
<p>We’ll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, <code>main</code>. The standard library provides
the <code>eprintln!</code> macro that prints to the standard error stream, so let’s change
the two places we were calling <code>println!</code> to print errors to use <code>eprintln!</code>
instead.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">範例 12-24: Writing error messages to standard error
instead of standard output using <code>eprintln!</code></span></p>
<p>After changing <code>println!</code> to <code>eprintln!</code>, let’s run the program again in the
same way, without any arguments and redirecting standard output with <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Now we see the error onscreen and <em>output.txt</em> contains nothing, which is the
behavior we expect of command line programs.</p>
<p>Let’s run the program again with arguments that don’t cause an error but still
redirect standard output to a file, like so:</p>
<pre><code class="language-console">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>We won’t see any output to the terminal, and <em>output.txt</em> will contain our
results:</p>
<p><span class="filename">檔案名稱：output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>This demonstrates that we’re now using standard output for successful output
and standard error for error output as appropriate.</p>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>This chapter recapped some of the major concepts you’ve learned so far and
covered how to perform common I/O operations in Rust. By using command line
arguments, files, environment variables, and the <code>eprintln!</code> macro for printing
errors, you’re now prepared to write command line applications. By using the
concepts in previous chapters, your code will be well organized, store data
effectively in the appropriate data structures, handle errors nicely, and be
well tested.</p>
<p>Next, we’ll explore some Rust features that were influenced by functional
languages: closures and iterators.</p>
<h1><a class="header" href="#函式語言功能疊代器與閉包" id="函式語言功能疊代器與閉包">函式語言功能：疊代器與閉包</a></h1>
<p>Rust 的設計靈感啟發自許多現有的語言與技術，其中一個影響十分顯住的就是<em>函式程式設計（functional programming）</em>。以函式風格的程式設計通常包含將函式視爲數值並作爲引數傳遞、將它們從其他函式回傳、將它們賦值給變數以便之後使用，以及更多。</p>
<p>在本章節中，我們不會討論哪些才是屬於函式程式設計或哪些不是，而是介紹一些 Rust 中類似於許多語言常視爲函式語言特色的功能。</p>
<p>更明確來說，我們會涵蓋：</p>
<ul>
<li><em>閉包（Closures）</em>：類似函式的結構並可以賦值給變數</li>
<li><em>疊代器（Iterators）</em>：遍歷一系列元素的方法</li>
<li>如何用這兩種功能來改善第十二章的 I/O 專案</li>
<li>這兩個功能的效能（先偷偷跟你說：它們比你想像的還要快！）</li>
</ul>
<p>其他 Rust 已經在其他章節提到的功能像是模式配對與枚舉也都有備函式風格所影響。掌握閉包與疊代器是寫出符合語言風格與高效 Rust 程式碼中重要的一環，所以我們將用一章來介紹它們。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch13-00-functional-features.md">e5ed971</a></li>
<li>updated: 2020-09-17</li>
</ul>
</blockquote>
<h2><a class="header" href="#函式語言功能疊代器與閉包-1" id="函式語言功能疊代器與閉包-1">函式語言功能：疊代器與閉包</a></h2>
<p>Rust 的閉包（closures）是個你能賦值給變數或作爲其他函式引數的匿名函式。你可以在某處建立閉包，然後在不同的地方呼叫閉包還執行它。而且不像函式，閉包可以從它們所定義的作用域中獲取數值。我們講會解釋這些閉包功能如何允許程式碼重用以及自訂行爲。</p>
<h3><a class="header" href="#透過閉包建立抽象行爲" id="透過閉包建立抽象行爲">透過閉包建立抽象行爲</a></h3>
<p>讓我們處理一個範例是當儲存閉包並在之後才執行是很實況的情況。在過程中，我們會討論到閉包語法、型別推導以及特徵。</p>
<p>讓我們考慮以下假設情境：我們在一家新創公司上班並正在推出一支會產生自訂重訓方案的應用程式。其後端就是用 Rust 寫的，且產生重訓方案的演算法有很多因素要考量，像是使用者的年齡、身高體重指數、健身喜好、最近鍛鍊的項目以及他們指定的重訓強度。此例中實際使用的演算法並不重要，重要的是此運算會花費數秒鐘。我們只想要在我們需要時呼叫此演算法並只會呼叫一次，讓使用者不會等待太久。</p>
<p>我們會模擬這個假設的演算法爲函式 <code>simulated_expensive_calculation</code>，如範例 13-1 所示，他會印出 <code>calculating slowly...</code>、等待兩秒鐘，然後回傳我們傳入的數值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-1：一支作爲假想需要運算 2 秒鐘的函式</span></p>
<p>接下來 <code>main</code> 函式會包含此健身應用程式中最重要的部分。此函式代表當使用者請求健身方案時應用程式會呼叫的程式碼。由於應用程式的前端與我們的閉包使用並沒有任何關聯，我們將會用寫死的數值來代表我們程式得輸入並印出輸出結果。</p>
<p>必要的輸入如以下所示：</p>
<ul>
<li>使用者想要的重訓強度，用來指明他們想要的訓練是低強度訓練或是高強度訓練</li>
<li>一個用來產生重訓方案變化的隨機數值</li>
</ul>
<p>輸出結果會是建議的重訓方案，範例 13-2 展示了我們使用的 <code>main</code> 函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensity
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {}
</span><span class="boring">
</span>fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}
</code></pre></pre>
<p><span class="caption">範例 13-2：一支有寫死的數值來模擬使用者輸入與隨機生成數字的 <code>main</code> 函式</span></p>
<p>爲了方便我們將變數 <code>simulated_user_specified_value</code> 寫死爲 10 且變數 <code>simulated_random_number</code> 寫死爲 7。在實際程式中，我們會從應用程式前端取得強度數字，並用 <code>rand</code> crate 來產生隨機數字，如同第二章猜謎遊戲所做的一樣。<code>main</code> 函式會用模擬的輸入數值呼叫 <code>generate_workout</code> 函式。</p>
<p>現在我們有了內容，讓我們看看演算法吧。範例 13-3 的函式 <code>generate_workout</code> 包含了應用程式的業務邏輯，也就是我們在此例最在意的地方。此例中接下來的程式碼都在此函式中進行：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-3：依據輸入印出重訓方案並呼叫函式 <code>simulated_expensive_calculation</code> 的業務邏輯</span></p>
<p>範例 13-3 的程式碼會多次呼叫計算緩慢的函式。第一個 <code>if</code> 區塊會呼叫 <code>simulated_expensive_calculation</code> 兩四，然後在 <code>else</code> 區塊內的 <code>if</code> 不會呼叫它，然後第二個 <code>else</code> 會呼叫它一次。</p>
<p><code>generate_workout</code> 函式預期的行爲是先檢查使用者想要低強度的重夐方案（也就是強度低於 25）或者高強度的方案（大於等於 25）。</p>
<p>低強度重訓方案會依據我們麼體的複雜演算法來建議一些伏地挺身和仰臥起坐。</p>
<p>如果使用者想要高強度重用，就會有額外的邏輯：如果應用程式產生的隨機數字是 3 的話，應用程式會建議休息並多喝水；如果不是的話，使用者會依據複雜演算法得到數分鐘的跑步訓練。</p>
<p>此程式碼能夠應付業務邏輯了，但是假設未來資料科學團隊決定要求我們需要更改我們呼叫 <code>simulated_expensive_calculation</code> 函式的方式。爲了簡化這些更新步驟，我們想要重構此程式碼好讓 <code>simulated_expensive_calculation</code> 只會呼叫一次。同時我們也想要去掉我們目前呼叫兩次的多餘程式碼，我們不希望再對此程序加上更多的函式呼叫。也就是說，我們不希望在沒有需要取得結果實呼叫程式碼，且我們希望它只會被呼叫一次。</p>
<h4><a class="header" href="#透過函式重構" id="透過函式重構">透過函式重構</a></h4>
<p>我們可以用許多方式重構此重訓程式。首先我們先將重複呼叫 <code>simulated_expensive_calculation</code> 的地方改成變數，如範例 13-4 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    intensity
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(&quot;Today, do {} pushups!&quot;, expensive_result);
        println!(&quot;Next, do {} situps!&quot;, expensive_result);
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(&quot;Today, run for {} minutes!&quot;, expensive_result);
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-4：提取 <code>simulated_expensive_calculation</code> 的呼叫到同個位置並用變數 <code>expensive_result</code> 儲存結果</span></p>
<p>此變更統一了所有 <code>simulated_expensive_calculation</code> 的呼叫並解決第一個 <code>if</code> 區塊重複呼叫函式兩次的問題。不幸的是，現在我們一定得呼叫此函式並在所有行情形下都得等待，這包含沒有使用到此結果的 <code>if</code> 區塊。</p>
<p>我們想在程式某處定義程式碼，並在我們確實需要它時<em>執行</em>程式碼就好。這就是閉包能使用的場合！</p>
<h4><a class="header" href="#透過閉包重構來儲存程式碼" id="透過閉包重構來儲存程式碼">透過閉包重構來儲存程式碼</a></h4>
<p>與其在 <code>if</code> 區塊之前就呼叫 <code>simulated_expensive_calculation</code> 函式，我們可以定義一個閉包並將<em>閉包</em>存入變數中，而不是儲存函式呼叫的結果，如範例 13-5 所示。我們可以將 <code>simulated_expensive_calculation</code> 的本體移入這個閉包中。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-5：定義閉包並存入 <code>expensive_closure</code> 變數中</span></p>
<p>閉包定義位於 <code>expensive_closure</code> 賦值時 <code>=</code> 後面的部分。要定義閉包，我們先從一對直線（<code>|</code>）開始，其內我們會指定閉包的參數，選擇此語法的原因是因爲這與 Smalltalk 和 Ruby 的閉包閉包定義類似。此閉包有一個參數 <code>num</code>，如果我們想要不止一個的話，我們可以用逗號來分隔，像是這樣 <code>|param1, param2|</code>。</p>
<p>在參數之後，我們加上大括號來作爲閉包的本體，不過如果閉包本體只是一個表達式的話就不必這樣寫。在閉包結束後，也就是大括號之後，我們要加上分號才能完成 <code>let</code> 陳述式的動作。在閉包本體最後一行的回傳數值就會是當閉包被呼叫時的回傳數值，因爲該行沒有以分號做結尾，就像函式本體一樣。</p>
<p>注意到此 <code>let</code> 陳述式代表 <code>expensive_closure</code> 包含了匿名函式的<em>定義</em>，而不是呼叫匿名函式的<em>回傳數值</em>。回想一下我們使用閉包是爲了讓我們能在某處定義程式碼、儲存這段程式碼然後在之後別的地方呼叫它。我們想呼叫的程式碼現在儲存在 <code>expensive_closure</code> 中。</p>
<p>有了閉包定義，我們就可以變更 <code>if</code> 區塊內的程式碼呼叫閉包來執行其程式碼並取得結果數值。我們呼叫閉包的方式與呼叫函式一樣：我們指定握有閉包定義的變數名稱，然後在括號內加上我們想使用的引數數值，如範例 13-6 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-6：呼叫我們定義的 <code>expensive_closure</code></span></p>
<p>現在耗時的計算只會在一處呼叫了，而且我們只會在需要結果時才會執行該程式碼。</p>
<p>然而我們又重新引入了範例 13-3 其中一個問題，我們仍然會在第一個 <code>if</code> 區塊呼叫閉包兩次，也就是會呼叫耗時的程式碼兩次，讓使用者需要多等一倍的時間。我們可以透過在 <code>if</code> 區塊內建立變數並取得呼叫閉包的結果來修正這個問題，但是閉包還能提供我們另一種解決辦法。我們稍後會介紹這個解決辦法。但在這之前讓我們先討論爲何閉包定義中不用型別詮釋，以及與閉包相關的特徵。</p>
<h3><a class="header" href="#閉包型別推導與詮釋" id="閉包型別推導與詮釋">閉包型別推導與詮釋</a></h3>
<p>閉包不必像 <code>fn</code> 函式那樣要求你要詮釋參數或回傳值的型別。函式需要型別詮釋是因爲它們是顯式公開給使用者的介面。嚴格定義此介面是很重要的，這能確保每個人同意函式使用或回傳的數值型別爲何。但是閉包並不是爲了對外公開使用，它們儲存在變數且沒有名稱能公開給我們函式庫的使用者。</p>
<p>閉包通常很短，而且只與小範圍內的程式碼有關，而非適用於任何場合。有了這樣限制的環境，編譯器能可靠地推導出參數與回傳值的型別，如同其如何推導出大部分的變數型別一樣。</p>
<p>要求開發者得爲這些小小的匿名函式詮釋型別的話會變得很惱人且非常多餘，因爲編譯器早就有足夠的資訊能推導出來了。</p>
<p>至於變數的話，雖然不是必要的，但如果我們希望能夠增加閱讀性與清楚程度，我們還是可以加上型別詮釋。要對我們在範例 13-5 定義的閉包詮釋型別的話，會如以下範例 13-7 所定義的所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-7：對閉包加上選擇性的參數與回傳值型別詮釋</span></p>
<p>加上型別詮釋後，閉包的語法看起來就更像函式的語法了。以下對一個參數加 1 的函式定義語法與有相同行爲的閉包的比較表。我們加了一些空格來對齊相對應的部分。這顯示了閉包語法和函式語法有多類似，只是改用直線以及有些語法是選擇性的。</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>第一行顯示的是函式定義，而第二行則顯示有完成型別詮釋的閉包定義。第三行移除了閉包定義的型別詮釋，然後第四行移除了大括號，因爲閉包本體只有一個表達式，所以這是選擇性的。這些都是有效的定義，並會在被呼叫時產生相同行爲。而 <code>add_one_v3</code> 和 <code>add_one_v4</code> 一定要被呼叫，這樣編譯器才能從它們的使用方式中推導出型別。</p>
<p>閉包定義會對每個參數與它們的回傳值推導出一個實際型別。舉例來說，範例 13-8 展示一支只會將收到的參數作爲回傳值的閉包定義。此閉包並沒有什麼意義，純粹作爲範例解釋。注意到我們沒有在定義中加上任何型別詮釋。如果我們嘗試呼叫閉包兩次，一次使用 <code>String</code> 作爲引數，而另一次使用 <code>u32</code> 的話，我們就會得到錯誤。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));
    let n = example_closure(5);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-8：嘗試呼叫被推導出兩個不同型別的閉包</span></p>
<p>編譯器會給我們以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `std::string::String`, found integer
  |                             help: try using a conversion method: `5.to_string()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>當我們第一次使用 <code>String</code> 數值呼叫 <code>example_closure</code> 時，編譯器會推導 <code>x</code> 與閉包回傳值的型別爲 <code>String</code>。這樣 <code>example_closure</code> 閉包內的型別就會鎖定，然後我們如果對同樣的閉包嘗試使用不同的型別的話，我們就會得到型別錯誤。</p>
<h3><a class="header" href="#透過泛型參數與-fn-特徵儲存閉包" id="透過泛型參數與-fn-特徵儲存閉包">透過泛型參數與 <code>Fn</code> 特徵儲存閉包</a></h3>
<p>讓我們回到我們的重訓生成應用程式。在範例 13-6 中，我們的程式碼仍然會呼叫耗時的閉包不止一次。其中一個解決此問題的選項是將耗時閉包的結果存入變數中，並在我們需要結果的地方使用該變數，而不是再呼叫閉包一次。不過此方法可能會增加很多重複的程式碼。</p>
<p>幸運的是我們還有另一個解決辦法。我們可以建立一個結構體來儲存閉包以及呼叫閉包的結果數值。此結構體只會在我們需要結果數值時執行閉包，然後它會獲取結果數值，所以我們的程式碼就不必負責儲存要重複使用的結果。你可能會聽過這種模式叫做<em>記憶化（memoization）<em>或</em>惰性求值（lazy evaluation）</em>。</p>
<p>要定義一個結構體儲存一個閉包，我們需要指定閉包的型別，因爲結構體定義需要知道它每個欄位的型別。每個閉包實例都有自己獨特的匿名型別，也就是說就算有兩個閉包的簽名一模一樣，它們的型別還是會被視爲不同的。要定義有使用閉包的結構體、枚舉或函式參數的話，我們可以使用在第十章所提到的泛型與特徵界限。</p>
<p>標準函式庫有提供 <code>Fn</code> 特徵，所有閉包都有實作至少以下一種特徵：<code>Fn</code>、<code>FnMut</code> 或 <code>FnOnce</code>。我們會在<a href="ch13-01-closures.html#%E9%80%8F%E9%81%8E%E9%96%89%E5%8C%85%E7%8D%B2%E5%8F%96%E7%92%B0%E5%A2%83">「透過閉包獲取環境」</a><!-- ignore -->段落中討論這些特徵的不同。在此例中，我們可以使用 <code>Fn</code> 特徵。</p>
<p>我們在 <code>Fn</code> 特徵界限加上了型別來表示閉包參數與回傳值必須擁有的型別。在此例中，我們的閉包參數型別爲 <code>u32</code> 且回傳 <code>u32</code>，所以我們指定的特徵界限爲 <code>Fn(u32) -&gt; u32</code>。</p>
<p>範例 13-9 顯示了擁有一個閉包與一個 Option 結果數值的 <code>Cacher</code> 結構體定義。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-9：定義結構體 <code>Cacher</code> 而 <code>calculation</code> 會存有閉包且 <code>value</code> 存放  Option 結果</span></p>
<p><code>Cacher</code> 結構體有個欄位 <code>calculation</code> 其泛型型別爲 <code>T</code>。<code>T</code> 的特徵界限指定這是一個使用 <code>Fn</code> 特徵的閉包。任何我們想存入的 <code>calculation</code> 欄位的閉包都必須只有一個 <code>u32</code> 參數（在 <code>Fn</code> 後方的括號內指定）以及回傳一個 <code>u32</code>（在 <code>-&gt;</code> 之後指定）。</p>
<blockquote>
<p>注意：函式也會實作這三個 <code>Fn</code> 特徵。如果我們想做的事情不需要獲取環境數值，我們可以使用實現 <code>Fn</code> 特徵的函式而非閉包。</p>
</blockquote>
<p><code>value</code> 欄位型別爲 <code>Option&lt;u32&gt;</code>。在我們執行閉包前，<code>value</code> 會是 <code>None</code>。當有程式碼使用 <code>Cacher</code> 要求取得閉包<em>結果</em>時，<code>Cacher</code> 就會在那時候執行閉包並以 <code>Some</code> 變體儲存結果到 <code>value</code> 欄位。然後如果有程式碼再次要求閉包結果實，我們就不必再執行閉包一次，可以靠 <code>Cacher</code> 回傳 <code>Some</code> 變體內的結果。</p>
<p>我們討論這個有關 <code>value</code> 欄位的邏輯定義就如範例 13-10 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-10：<code>Cacher</code> 的快取（Caching）邏輯</span></p>
<p>我們想要 <code>Cacher</code> 來管理結構體的欄位數值，而不是讓呼叫者有機會直接改變這些欄位的數值，所以這些欄位是私有的。</p>
<p><code>Cacher::new</code> 函式接收一個泛型參數 <code>T</code>，其特徵界限與我們在 <code>Cacher</code> 結構體定義的是相同的。接著 <code>Cacher::new</code> 回傳一個 <code>Cacher</code> 實例，其 <code>calculation</code> 欄位擁有指定的閉包而 <code>value</code> 欄位則是 <code>None</code>，因爲我們還沒有執行閉包。</p>
<p>當呼叫者需要閉包計算的結果時，不是直接呼叫閉包，而是呼叫 <code>value</code> 方法。此方法會檢查我們的 <code>self.value</code> 是否已經有個結果數值在 <code>Some</code> 內。如果有的話，它會回傳 <code>Some</code> 內的數值而不用再次執行閉包。</p>
<p>如果 <code>self.value</code> 是 <code>None</code>，程式碼會呼叫存在 <code>self.calculation</code> 的閉包、儲存結果到 <code>self.value</code> 以便未來使用，並回傳數值。</p>
<p>範例 13-11 展示我們如何在範例 13-6 的 <code>generate_workout</code> 函式中使用此 <code>Cacher</code> 結構體。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">        Cacher {
</span><span class="boring">            calculation,
</span><span class="boring">            value: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.value {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calculation)(arg);
</span><span class="boring">                self.value = Some(v);
</span><span class="boring">                v
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(&quot;Today, do {} pushups!&quot;, expensive_result.value(intensity));
        println!(&quot;Next, do {} situps!&quot;, expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-11：在函式 <code>generate_workout</code> 使用 <code>Cacher</code> 來抽象化快取邏輯</span></p>
<p>不同於將閉包儲存給變數，我們建立一個新的 <code>Cacher</code> 實例來儲存閉包。然後在每個我們需要結果的地方，我們呼叫 <code>Cacher</code> 實例的 <code>value</code> 方法。我們要呼叫 <code>value</code> 方法幾次都行，或者不叫也行，無論如何耗時計算最多就只會被執行一次。</p>
<p>請嘗試從範例 13-2 的 <code>main</code> 函式執行此程式。變更 <code>simulated_user_specified_value</code> 與 <code>simulated_random_number</code> 的數值來驗證看看在所有情況下與數個 <code>if</code> 和 <code>else</code> 區塊中，<code>calculating slowly...</code> 只會出現一次且只有在需要時才會出現。<code>Cacher</code> 負責確保我們不會呼叫超過耗時計算所需的邏輯，讓 <code>generate_workout</code> 可以專注在業務邏輯。</p>
<h3><a class="header" href="#cacher-實作的限制" id="cacher-實作的限制"><code>Cacher</code> 實作的限制</a></h3>
<p>快取數值是個廣泛實用的行爲，我們可能會希望在程式碼中的其他不同閉包也使用到。然而目前<code>Cacher</code> 的實作有兩個問題可能會在不同場合重複使用變得有點困難。</p>
<p>第一個問題是 <code>Cacher</code> 實例假設它永遠會從方法 <code>value</code> 的參數 <code>arg</code> 中取得相同數值，所以說以下 <code>Cacher</code> 的測試就會失敗：</p>
<pre><code class="language-rust ignore panics"><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Fn(u32) -&gt; u32,
</span><span class="boring">{
</span><span class="boring">    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">        Cacher {
</span><span class="boring">            calculation,
</span><span class="boring">            value: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.value {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calculation)(arg);
</span><span class="boring">                self.value = Some(v);
</span><span class="boring">                v
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn call_with_different_values() {
        let mut c = Cacher::new(|a| a);

        let v1 = c.value(1);
        let v2 = c.value(2);

        assert_eq!(v2, 2);
    }
<span class="boring">}
</span></code></pre>
<p>此測試透過一個回傳傳入值的閉包建立一個新的 <code>Cacher</code> 實例。我們透過一個 <code>arg</code> 數值 1 與另一個 <code>arg</code> 數值 2 來呼叫此 <code>Cacher</code> 實例的 <code>value</code> 方法兩次，且我們預期 <code>arg</code> 爲 2 的 <code>value</code> 會回傳 2。</p>
<p>使用範例 13-9 和範例 13-10 的 <code>Cacher</code> 實作執行此測試的話，測試會在 <code>assert_eq!</code> 失敗並附上此訊息：</p>
<pre><code class="language-console">$ cargo test
   Compiling cacher v0.1.0 (file:///projects/cacher)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/cacher-4116485fb32b3fff

running 1 test
test tests::call_with_different_values ... FAILED

failures:

---- tests::call_with_different_values stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/lib.rs:43:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::call_with_different_values

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>問題在於我們第一次會使用 1 呼叫 <code>c.value</code>，<code>Cacher</code> 實例會儲存 <code>Some(1)</code> 給 <code>self.value</code>。因此無論我們再傳入任何值給 <code>value</code> 方法，它永遠只會回傳 1。</p>
<p>我們可以嘗試將 <code>Cacher</code> 改成儲存雜湊映射（hash map）而非單一數值。雜湊映射的鍵會是傳入的 <code>arg</code> 數值，而雜湊映射的值則是用該鍵呼叫閉包的結果。所以不同於查看 <code>self.value</code> 是 <code>Some</code> 還是 <code>None</code> 值， <code>value</code> 函式將會查看 <code>arg</code> 有沒有在雜湊映射內，而如果有的話就會傳對應數值。如果沒有的話，<code>Cacher</code> 會呼叫閉包並儲存 <code>arg</code> 數值與對應的結果數值到雜湊映射中。</p>
<p>第二個問題是目前的 <code>Cacher</code> 實作只會接受參數型別爲 <code>u32</code> 並回傳 <code>u32</code> 的閉包。舉例來說，我們可能會想要快取給予字串並回傳 <code>usize</code> 的閉包結果數值。要修正此問題，你可以嘗試加上更多泛型參數來增加 <code>Cacher</code> 功能的彈性。</p>
<h3><a class="header" href="#透過閉包獲取環境" id="透過閉包獲取環境">透過閉包獲取環境</a></h3>
<p>在重訓生成範例中，我們只將閉包作爲行內匿名函式。但是閉包還有個函式所沒有的能力：它們可以獲取它們的環境並取得在它們所定義的作用域內的變數。</p>
<p>範例 13-12 有一個儲存在變數 <code>equal_to_x</code> 的閉包，其使用變數 <code>x</code> 來取得閉包周圍的環境。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">範例 13-12：引用周圍作用域中變數的閉包範例</span></p>
<p><code>x</code> 在此雖然不是 <code>equal_to_x</code> 的參數，<code>equal_to_x</code> 閉包卻允許使用變數 <code>x</code>，因爲它與 <code>equal_to_x</code> 都定義在同個作用域。</p>
<p>我們用函式就做不到，如果我們嘗試執行以下範例，我們的程式碼會無法編譯：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<p>我們得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0434]: can't capture dynamic environment in a fn item
 --&gt; src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0434`.
error: could not compile `equal-to-x`.

To learn more, run the command again with --verbose.
</code></pre>
<p>編譯器甚至會提醒我們這只有閉包才能做到！</p>
<p>當閉包從它的環境獲取數值時，它會在閉包本體中使用記憶體來儲存這個數值。這種儲存記憶體的方式會產生額外開銷。在更常見的場合中，也就是不需要獲取程式碼的環境時，我們並不希望產生這種開銷。因爲函式並不允許獲取它們的環境，定義與使用函式就不會產生這種開銷。</p>
<p>閉包可以用三種方式獲取它們的環境，這剛好能對應到函式取得參數的三種方式：取得所有權、可變借用與不可變借用。這就被定義成以下三種 <code>Fn</code> 特徵：</p>
<ul>
<li><code>FnOnce</code> 會消耗周圍作用域中，也就是閉包的<em>環境</em>，所獲取變數。要消耗掉所獲取的變數，閉包必須取得這些變數的所有權並在定義時將它們移入閉包中。特徵名稱中的 <code>Once</code> 指的是因爲閉包無法取得相同變數的所有權一次以上，所以它只能被呼叫一次。</li>
<li><code>FnMut</code> 可以改變環境，因爲它取得的事可變的借用數值。</li>
<li><code>Fn</code> 則取得環境中不可變的借用數值。</li>
</ul>
<p>當你建立閉包時，Rust 會依據閉包如何使用環境的數值來推導該使用何種特徵。所有的閉包都會實作 <code>FnOnce</code> 因爲它們都可以至少被呼叫一次。不會移動獲取變數的閉包還會實作 <code>FnMut</code>，最後不需要向獲取變數取得可變引用的閉包會再實作 <code>Fn</code>。在範例 13-12 中，<code>equal_to_x</code> 閉包會取得 <code>x</code> 的不可變借用（所以 <code>equal_to_x</code> 擁有 <code>Fn</code> 特徵），因爲閉包本體只會讀取 <code>x</code> 數值。</p>
<p>如果你希望強制閉包會取得周圍環境數值的所有權，你可以在參數列表前使用 <code>move</code> 關鍵字。此技巧在要將閉包傳給新的執行緒以便將資料移動到新執行緒時會很實用。</p>
<p>當我們在第十六章討論並行的時候，我們會遇到更多 <code>move</code> 閉包的範例。現在的話可以先看看範例 13-12 怎麼使用 <code>move</code> 關鍵字到閉包定義中 ，並使用 vector 而非整數，因爲整數可以被拷貝而不是移動。注意此程式還不能編譯過。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>我們會獲得以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling equal-to-x v0.1.0 (file:///projects/equal-to-x)
error[E0382]: borrow of moved value: `x`
 --&gt; src/main.rs:6:40
  |
2 |     let x = vec![1, 2, 3];
  |         - move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 | 
4 |     let equal_to_x = move |z| z == x;
  |                      --------      - variable moved due to use in closure
  |                      |
  |                      value moved into closure here
5 | 
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `equal-to-x`.

To learn more, run the command again with --verbose.
</code></pre>
<p>當閉包定義時，數值 <code>x</code> 會移入閉包中，因爲我們加上了 <code>move</code> 關鍵字。閉包因此取得 <code>x</code> 的所有權，然後 <code>main</code> 就會不允許 <code>x</code> 在 <code>println!</code> 陳述式中使用。移除此例的 <code>println!</code> 就能修正問題。</p>
<p>大多數要指定 <code>Fn</code> 特徵界限時，你可以先從 <code>Fn</code> 開始，然後編譯器會依據閉包本體的使用情況來告訴你該使用 <code>FnMut</code> 或 <code>FnOnce</code>。</p>
<p>接下來爲了講解閉包獲取環境的行爲很適合用於函式參數的情形，讓我們移至下個主題：疊代器。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch13-01-closures.md">e5ed971</a></li>
<li>updated: 2020-09-17</li>
</ul>
</blockquote>
<h2><a class="header" href="#使用疊代器來處理一系列的項目" id="使用疊代器來處理一系列的項目">使用疊代器來處理一系列的項目</a></h2>
<p>疊代器（Iterator）模式讓你可以對 一個項目序列依序進行某些任務。一個疊代器負責遍歷序每個項目以及序列何時結束的邏輯。當你使用疊代器，你不需要自己實作這些邏輯。</p>
<p>在 Rust 中疊代器是*惰性（lazy）*的，代表除非你呼叫方法來使用疊代器，不然它們不會有任何效果。舉例來說，範例 13-13 的程式碼會透過 <code>Vec&lt;T&gt;</code> 定義的方法 <code>iter</code> 從 vector <code>v1</code> 建立一個疊代器來遍歷它的項目。此程式碼本身沒有啥實用之處。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-13：建立一個疊代器</span></p>
<p>一旦我們建立了疊代器，我們可以有很多使用它的方式。在第三章的範例 3-5 中，我們在 <code>for</code> 迴圈中使用疊代器來對每個項目執行一些程式碼，雖然我們當時沒有詳細解釋 <code>iter</code> 是在做什麼。</p>
<p>範例 13-14 區隔了疊代器的建立與使用疊代器 <code>for</code> 迴圈。疊代器儲存在變數 <code>v1_iter</code>，且在此時沒有任何遍歷的動作發生。當使用 <code>v1_iter</code> 疊代器的 <code>for</code> 迴圈被呼叫時，疊代器中的每個元素才會在迴圈中每次疊代中使用，以此印出每個數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!(&quot;Got: {}&quot;, val);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-14：在 <code>for</code> 迴圈使用疊代器</span></p>
<p>在標準函式庫沒有提供疊代器的語言中，你可能會用別種方式寫這個相同的函式，像是先從一個變數 0 作爲索引開始、使用該變數索引 vector 來獲取數值，然後在迴圈中增加變數的值直到它抵達 vector 的總長。</p>
<p>疊代器會爲你處理這些所有邏輯，減少重複且你可能會搞砸的程式碼。疊代器還能讓你靈活地將相同的邏輯用於不同的序列，而不只是像 vector 這種你能進行索引的資料結構。讓我們研究看看疊代器怎麼辦到的。</p>
<h3><a class="header" href="#iterator-特徵與-next-方法" id="iterator-特徵與-next-方法"><code>Iterator</code> 特徵與 <code>next</code> 方法</a></h3>
<p>所有的疊代器都會實作定義在標準函式庫的 <code>Iterator</code> 特徵。特徵的定義如以下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // 以下省略預設實作
}
<span class="boring">}
</span></code></pre></pre>
<p>注意到此定義使用了一些新的語法：<code>type Item</code> 與 <code>Self::Item</code>，這是此特徵定義的<em>關聯型別（associated type）</em>。我們會在第十九章進一步探討關聯型別。現在你只需要知道此程式碼表示要實作 <code>Iterator</code> 特徵的話，你還需要定義 <code>Item</code> 型別，而此 <code>Item</code> 型別會用在方法 <code>next</code> 的回傳型別中。換句話說，<code>Item</code> 型別會是從疊代器回傳的型別。</p>
<p><code>Iterator</code> 型別只要求實作者定義一個方法：<code>next</code> 方法會用 <code>Some</code> 依序回傳疊代器中的每個項目，並在疊代器結束時回傳 <code>None</code>。</p>
<p>我們可以直接在疊代器呼叫 <code>next</code> 方法。範例 13-15 展示從 vector 建立的疊代器重複呼叫 <code>next</code> 每次會得到什麼數值。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-15：對疊代器呼叫 <code>next</code> 方法</span></p>
<p>注意到 <code>v1_iter</code> 需要是可變的：在疊代器上呼叫 <code>next</code> 方法會改變疊代器內部用來紀錄序列位置的狀態。換句話說，此程式碼<em>消耗</em>或者說使用了疊代器。每次 <code>next</code> 的呼叫會從疊代器消耗一個項目。而我們不必在 <code>for</code> 迴圈指定 <code>v1_iter</code> 爲可變是因爲迴圈會取得 <code>v1_iter</code> 的所有權並在內部將其改爲可變。</p>
<p>另外還要注意的是我們從 <code>next</code> 呼叫取得的是 vector 中數值的不可變引用。<code>iter</code> 方法會從疊代器中產生不可變引用。如果我們想要一個取得 <code>v1</code> 所有權的疊代器，我們可以呼叫 <code>into_iter</code> 而非 <code>iter</code>。同樣地，如果我們想要遍歷可變引用，我們可以呼叫 <code>iter_mut</code> 而非 <code>iter</code>。</p>
<h3><a class="header" href="#消耗疊代器的方法" id="消耗疊代器的方法">消耗疊代器的方法</a></h3>
<p>標準函式庫提供的 <code>Iterator</code> 特徵有一些不同的預設實作方法，你可以查閱標準函式庫的 <code>Iterator</code> 特徵 API 技術文件來找到這些方法。其中有些方法就是在它們的定義呼叫 <code>next</code> 方法，這就是爲何當你實作 <code>Iterator</code> 特徵時需要提供 <code>next</code> 方法的實作。</p>
<p>會呼叫 <code>next</code> 的方法被稱之爲<em>消耗配接器（consuming adaptors）</em>，因爲呼叫它們會使用掉疊代器。其中一個例子就是方法 <code>sum</code>，這會取得疊代器的所有權並重複呼叫 <code>next</code> 來遍歷所有項目，因而消耗掉疊代器。隨著遍歷的過程中，他會將每個項目加到總計中，並在疊代完成時回傳總計數值。範例 13-16 展示了一個使用 <code>sum</code> 方法的測試：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-16：呼叫 <code>sum</code> 方法來取得疊代器中所有項目的總計數值</span></p>
<p>我們在呼叫 <code>sum</code> 之後就不允許使用 <code>v1_iter</code> 因爲 <code>sum</code> 取得了疊代器的所有權。</p>
<h3><a class="header" href="#產生其他疊代器的方法" id="產生其他疊代器的方法">產生其他疊代器的方法</a></h3>
<p>而其他定義在 <code>Iterator</code> 特徵的方法則叫做<em>疊代配接器（iterator adaptors）</em>，它們能讓你變更疊代器成其他種類的疊代器。你可以串接數個疊代配接器的呼叫來組織一系列複雜的動作並仍能保持閱讀性。不過因爲所有的疊代器都是惰性的，你需要呼叫一個消耗配接器方法來取得疊代配接器呼叫的結果。</p>
<p>範例 13-17 呼叫了疊代器的疊代配接器方法 <code>map</code>，這可以取得一個閉包來對每個項目進行處理以產生一個新的疊代器。閉包會將 vector 中的每個項目加 1 來產生新的疊代器。不過此程式碼會產生一個警告：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-17：呼叫疊代配接器 <code>map</code> 來建立新的疊代器</span></p>
<p>我們獲得的警告如以下所示：</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `std::iter::Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed

    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>範例 13-17 的程式碼不會做任何事情，我們指定的閉包沒有被呼叫到半次。警告提醒了我們原因：疊代配接器是惰性的，我們必須在此消耗疊代器才行。</p>
<p>要修正並消耗此疊代器，我們將使用 <code>collect</code> 方法，這是我們在範例 12-1 搭配 <code>env::args</code> 使用的方法。此方法會消耗疊代器並收集結果數值至一個資料型別集合。</p>
<p>在範例 13-18 中，我們將遍歷 <code>map</code> 呼叫所產生的疊代器結果數值收集到一個 vector 中。此 vector 最後會包含原本 vector 每個項目都加 1 的數值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 13-18：呼叫方法 <code>map</code> 來建立新的疊代器並呼叫 <code>collect</code> 方法來消耗新的疊代器來產生 vector</span></p>
<p>因爲 <code>map</code> 接受一個閉包，我們可以對每個項目指定任何我們想做的動作。這是一個展示如何使用閉包來自訂行爲，同時又能重複使用 <code>Iterator</code> 特徵提供的遍歷行爲的絕佳例子。</p>
<h3><a class="header" href="#使用閉包獲取它們的環境" id="使用閉包獲取它們的環境">使用閉包獲取它們的環境</a></h3>
<p>現在我們介紹了疊代器，我們可以展示一個透過使用 <code>filter</code> 疊代配接器與閉包獲取它們環境的常見範例。疊代器中的 <code>filter</code> 方法會接受一個使用疊代器的每個項目並回傳布林值的閉包。如果閉包回傳 <code>true</code>，該數值就會被包含在 <code>filter</code> 產生的疊代器中；如果閉包回傳 <code>false</code>，該數值就保不會被包含在結果疊代器中。</p>
<p>在範例 13-19 中我們使用 <code>filter</code> 與一個從它的環境獲取變數 <code>shoe_size</code> 的閉包來遍歷一個有 <code>Shoe</code> 結構體實例的集合。它會回傳只有符合指定大小的鞋子：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from(&quot;sneaker&quot;),
            },
            Shoe {
                size: 13,
                style: String::from(&quot;sandal&quot;),
            },
            Shoe {
                size: 10,
                style: String::from(&quot;boot&quot;),
            },
        ];

        let in_my_size = shoes_in_my_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from(&quot;sneaker&quot;)
                },
                Shoe {
                    size: 10,
                    style: String::from(&quot;boot&quot;)
                },
            ]
        );
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">範例 13-19：使用 <code>filter</code> 方法與一個獲取 <code>shoe_size</code> 的閉包</span></p>
<p>函式 <code>shoes_in_my_size</code> 會取得鞋子 vector 的所有權以及一個鞋子大小作爲參數。它會回傳只有符合指定大小的鞋子 vector。</p>
<p>在 <code>shoes_in_my_size</code> 的本體中，我們呼叫 <code>into_iter</code> 來建立一個會取得 vector 所有權的疊代器。然後我們呼叫 <code>filter</code> 來將該疊代器轉換成只包含閉包回傳爲 <code>true</code> 的元素的新疊代器。</p>
<p>閉包會從環境獲取 <code>shoe_size</code> 參數並比較每個鞋子數值的大小，讓只有符合大小的鞋子保留下來。最後呼叫 <code>collect</code> 來收集疊代器回傳的數值進一個函式會回傳的 vector。</p>
<p>此測試顯示了當我們呼叫 <code>shoes_in_my_size</code> 時，我們會得到我們指定相同大小的鞋子。</p>
<h3><a class="header" href="#透過-iterator-特徵建立我們自己的疊代器" id="透過-iterator-特徵建立我們自己的疊代器">透過 <code>Iterator</code> 特徵建立我們自己的疊代器</a></h3>
<p>我們已經顯示了你可以對 vector 呼叫 <code>iter</code>、<code>into_iter</code> 或 <code>iter_mut</code> 來建立疊代器。你也可以從標準函式庫的其他集合型別產生疊代器，像是雜湊映射等等。你也可以透過對你自己的型別實作 <code>Iterator</code> 特徵來建立任何你所希望的疊代器。如同之前提到的，你唯一需要提供的方法定義就是 <code>next</code> 方法。一旦你完成，你就可以使用 <code>Iterator</code> 特徵提供的所有預設實作方法！</p>
<p>作爲展示，讓我們建立一個只會從 1 數到 5 的疊代器。首先，我們要建立個擁有一些數值的結構體。然後我們對此結構體實作 <code>Iterator</code> 特徵將它變成一個疊代器，並在實作中使用其值。</p>
<p>範例 13-20 有個結構體 <code>Counter</code> 的定義以及能夠產生 <code>Counter</code> 實例的關聯函式 <code>new</code>：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">範例 13-20：定義結構體 <code>Counter</code> 與關聯函式 <code>new</code>，這能建立一個初始值 <code>count</code> 爲 0 的 <code>Counter</code> 結構體</span></p>
<p><code>Counter</code> 結構體只有一個欄位 <code>count</code>，此欄位擁有一個 <code>u32</code> 數值來追蹤我們遍歷 1 到 5 的當前位置。<code>count</code> 欄位是私有的，因爲我們希望 <code>Counter</code> 的實作會管理此數值。函式 <code>new</code> 強制建立新實例的行爲永遠會從 <code>count</code> 欄位爲 0 時開始。</p>
<p>接下來我們對我們的 <code>Counter</code> 型別實作 <code>Iterator</code> 特徵，定義 <code>next</code> 方法本體來指定疊代器的使用行爲，如範例 13-21 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-21：在我們的 <code>Counter</code> 結構體實作 <code>Iterator</code> 特徵</span></p>
<p>我們將疊代器的關聯型別 <code>Item</code> 設爲 <code>u32</code>，代表疊代器將會回傳 <code>u32</code> 數值。一樣先別擔心關聯型別，我們會在第十九章討論到。</p>
<p>我們希望我們的疊代器對目前的狀態加 1，所以我們將 <code>count</code> 初始化爲 0，這樣它就會先回傳 1。如果 <code>count</code> 的值小於 5，<code>next</code> 就會增加 <code>count</code> 的值並用 <code>Some</code> 回傳目前數值。一旦 <code>count</code> 等於 5，我們的疊代器就會停止增加 <code>count</code> 並永遠回傳傳 <code>None</code>。</p>
<h4><a class="header" href="#使用-counter-疊代器的-next-方法" id="使用-counter-疊代器的-next-方法">使用 <code>Counter</code> 疊代器的 <code>next</code> 方法</a></h4>
<p>一旦我們實作了 <code>Iterator</code> 特徵，我們就有一個疊代器了！範例 13-22 的測試展示我們可以對我們的 <code>Counter</code> 結構體直接呼叫 <code>next</code> 方法來使用疊代器的功能，就像我們在範例 13-15 對 vector 建立的疊代器使用的方式一樣。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn calling_next_directly() {
        let mut counter = Counter::new();

        assert_eq!(counter.next(), Some(1));
        assert_eq!(counter.next(), Some(2));
        assert_eq!(counter.next(), Some(3));
        assert_eq!(counter.next(), Some(4));
        assert_eq!(counter.next(), Some(5));
        assert_eq!(counter.next(), None);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-22：測試 <code>next</code> 方法實作的功能</span></p>
<p>此測試建立了一個新的 <code>Counter</code> 實例給變數 <code>counter</code> 並重複呼叫 <code>next</code>，驗證我們實作的疊代器是否行爲如我們預期的一樣：回傳數值 1 到 5。</p>
<h4><a class="header" href="#使用其他-iterator-特徵方法" id="使用其他-iterator-特徵方法">使用其他 <code>Iterator</code> 特徵方法</a></h4>
<p>我們透過定義 <code>next</code> 方法來實作 <code>Iterator</code> 特徵，所以我們現在可使用在標準函式庫提供的 <code>Iterator</code> 特徵中所任何有預設實作的方法了，因爲它們都使用到了 <code>next</code> 的方法功能。</p>
<p>舉例來說，如果我們因爲某些原因想要取得一個 <code>Counter</code> 實例的數值與另一個 <code>Counter</code> 實例去掉第一個值的數值來做配對、對每個配對相乘、保留結果可以被 3 整除的值，最後將所有結果數值相加，我們可以這樣寫，如範例 13-23 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn calling_next_directly() {
</span><span class="boring">        let mut counter = Counter::new();
</span><span class="boring">
</span><span class="boring">        assert_eq!(counter.next(), Some(1));
</span><span class="boring">        assert_eq!(counter.next(), Some(2));
</span><span class="boring">        assert_eq!(counter.next(), Some(3));
</span><span class="boring">        assert_eq!(counter.next(), Some(4));
</span><span class="boring">        assert_eq!(counter.next(), Some(5));
</span><span class="boring">        assert_eq!(counter.next(), None);
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn using_other_iterator_trait_methods() {
        let sum: u32 = Counter::new()
            .zip(Counter::new().skip(1))
            .map(|(a, b)| a * b)
            .filter(|x| x % 3 == 0)
            .sum();
        assert_eq!(18, sum);
    }
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-23：對我們的 <code>Counter</code> 疊代器使用特是特樣的 <code>Iterator</code> 特徵方法</span></p>
<p>注意到 <code>zip</code> 只會產生四個配對，理論上的 <code>(5, None)</code> 配對是不會產生出來的，因爲 <code>zip</code> 會在它的其中一個輸入疊代器回傳 <code>None</code> 時就回傳 <code>None</code>。</p>
<p>這些所有呼叫都是可行的，因爲我們已經定義了 <code>next</code> 運作的行爲，而標準函式庫會提供其他呼叫 <code>next</code> 方法的預設實作。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch13-02-iterators.md">e5ed971</a></li>
<li>updated: 2020-09-18</li>
</ul>
</blockquote>
<h2><a class="header" href="#improving-our-io-project" id="improving-our-io-project">Improving Our I/O Project</a></h2>
<p>With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Let’s look at how iterators can improve our implementation of the
<code>Config::new</code> function and the <code>search</code> function.</p>
<h3><a class="header" href="#removing-a-clone-using-an-iterator" id="removing-a-clone-using-an-iterator">Removing a <code>clone</code> Using an Iterator</a></h3>
<p>In Listing 12-6, we added code that took a slice of <code>String</code> values and created
an instance of the <code>Config</code> struct by indexing into the slice and cloning the
values, allowing the <code>Config</code> struct to own those values. In Listing 13-24,
we’ve reproduced the implementation of the <code>Config::new</code> function as it was in
Listing 12-23:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">範例 13-24: Reproduction of the <code>Config::new</code> function
from Listing 12-23</span></p>
<p>At the time, we said not to worry about the inefficient <code>clone</code> calls because
we would remove them in the future. Well, that time is now!</p>
<p>We needed <code>clone</code> here because we have a slice with <code>String</code> elements in the
parameter <code>args</code>, but the <code>new</code> function doesn’t own <code>args</code>. To return
ownership of a <code>Config</code> instance, we had to clone the values from the <code>query</code>
and <code>filename</code> fields of <code>Config</code> so the <code>Config</code> instance can own its values.</p>
<p>With our new knowledge about iterators, we can change the <code>new</code> function to
take ownership of an iterator as its argument instead of borrowing a slice.
We’ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
<code>Config::new</code> function is doing because the iterator will access the values.</p>
<p>Once <code>Config::new</code> takes ownership of the iterator and stops using indexing
operations that borrow, we can move the <code>String</code> values from the iterator into
<code>Config</code> rather than calling <code>clone</code> and making a new allocation.</p>
<h4><a class="header" href="#using-the-returned-iterator-directly" id="using-the-returned-iterator-directly">Using the Returned Iterator Directly</a></h4>
<p>Open your I/O project’s <em>src/main.rs</em> file, which should look like this:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p>We’ll change the start of the <code>main</code> function that we had in Listing 12-24 to
the code in Listing 13-25. This won’t compile until we update <code>Config::new</code> as
well.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::process;
</span><span class="boring">
</span><span class="boring">use minigrep::Config;
</span><span class="boring">
</span>fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
<span class="boring">
</span><span class="boring">    if let Err(e) = minigrep::run(config) {
</span><span class="boring">        eprintln!(&quot;Application error: {}&quot;, e);
</span><span class="boring">
</span><span class="boring">        process::exit(1);
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">範例 13-25: Passing the return value of <code>env::args</code> to
<code>Config::new</code></span></p>
<p>The <code>env::args</code> function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to <code>Config::new</code>, now
we’re passing ownership of the iterator returned from <code>env::args</code> to
<code>Config::new</code> directly.</p>
<p>Next, we need to update the definition of <code>Config::new</code>. In your I/O project’s
<em>src/lib.rs</em> file, let’s change the signature of <code>Config::new</code> to look like
Listing 13-26. This still won’t compile because we need to update the function
body.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
<span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            filename,
</span><span class="boring">            case_sensitive,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-26: Updating the signature of <code>Config::new</code> to
expect an iterator</span></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the
type of the iterator it returns is <code>std::env::Args</code>. We’ve updated the
signature of the <code>Config::new</code> function so the parameter <code>args</code> has the type
<code>std::env::Args</code> instead of <code>&amp;[String]</code>. Because we’re taking ownership of
<code>args</code> and we’ll be mutating <code>args</code> by iterating over it, we can add the <code>mut</code>
keyword into the specification of the <code>args</code> parameter to make it mutable.</p>
<h4><a class="header" href="#using-iterator-trait-methods-instead-of-indexing" id="using-iterator-trait-methods-instead-of-indexing">Using <code>Iterator</code> Trait Methods Instead of Indexing</a></h4>
<p>Next, we’ll fix the body of <code>Config::new</code>. The standard library documentation
also mentions that <code>std::env::Args</code> implements the <code>Iterator</code> trait, so we know
we can call the <code>next</code> method on it! Listing 13-27 updates the code from
Listing 12-23 to use the <code>next</code> method:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config {
            query,
            filename,
            case_sensitive,
        })
    }
}
<span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.contains(query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 13-27: Changing the body of <code>Config::new</code> to use
iterator methods</span></p>
<p>Remember that the first value in the return value of <code>env::args</code> is the name of
the program. We want to ignore that and get to the next value, so first we call
<code>next</code> and do nothing with the return value. Second, we call <code>next</code> to get the
value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns a
<code>Some</code>, we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means
not enough arguments were given and we return early with an <code>Err</code> value. We do
the same thing for the <code>filename</code> value.</p>
<h3><a class="header" href="#making-code-clearer-with-iterator-adaptors" id="making-code-clearer-with-iterator-adaptors">Making Code Clearer with Iterator Adaptors</a></h3>
<p>We can also take advantage of iterators in the <code>search</code> function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        if args.len() &lt; 3 {
</span><span class="boring">            return Err(&quot;not enough arguments&quot;);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let query = args[1].clone();
</span><span class="boring">        let filename = args[2].clone();
</span><span class="boring">
</span><span class="boring">        Ok(Config { query, filename })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn one_result() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-28: The implementation of the <code>search</code>
function from Listing 12-19</span></p>
<p>We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate <code>results</code> vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldn’t have to manage
concurrent access to the <code>results</code> vector. Listing 13-29 shows this change:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::env;
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    pub query: String,
</span><span class="boring">    pub filename: String,
</span><span class="boring">    pub case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Config {
</span><span class="boring">    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
</span><span class="boring">        args.next();
</span><span class="boring">
</span><span class="boring">        let query = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a query string&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let filename = match args.next() {
</span><span class="boring">            Some(arg) =&gt; arg,
</span><span class="boring">            None =&gt; return Err(&quot;Didn't get a file name&quot;),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();
</span><span class="boring">
</span><span class="boring">        Ok(Config {
</span><span class="boring">            query,
</span><span class="boring">            filename,
</span><span class="boring">            case_sensitive,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let contents = fs::read_to_string(config.filename)?;
</span><span class="boring">
</span><span class="boring">    let results = if config.case_sensitive {
</span><span class="boring">        search(&amp;config.query, &amp;contents)
</span><span class="boring">    } else {
</span><span class="boring">        search_case_insensitive(&amp;config.query, &amp;contents)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    for line in results {
</span><span class="boring">        println!(&quot;{}&quot;, line);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents
        .lines()
        .filter(|line| line.contains(query))
        .collect()
}
<span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(
</span><span class="boring">    query: &amp;str,
</span><span class="boring">    contents: &amp;'a str,
</span><span class="boring">) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let query = query.to_lowercase();
</span><span class="boring">    let mut results = Vec::new();
</span><span class="boring">
</span><span class="boring">    for line in contents.lines() {
</span><span class="boring">        if line.to_lowercase().contains(&amp;query) {
</span><span class="boring">            results.push(line);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    results
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_sensitive() {
</span><span class="boring">        let query = &quot;duct&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Duct tape.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(vec![&quot;safe, fast, productive.&quot;], search(query, contents));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn case_insensitive() {
</span><span class="boring">        let query = &quot;rUsT&quot;;
</span><span class="boring">        let contents = &quot;\
</span><span class="boring">Rust:
</span><span class="boring">safe, fast, productive.
</span><span class="boring">Pick three.
</span><span class="boring">Trust me.&quot;;
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
</span><span class="boring">            search_case_insensitive(query, contents)
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 13-29: Using iterator adaptor methods in the
implementation of the <code>search</code> function</span></p>
<p>Recall that the purpose of the <code>search</code> function is to return all lines in
<code>contents</code> that contain the <code>query</code>. Similar to the <code>filter</code> example in Listing
13-19, this code uses the <code>filter</code> adaptor to keep only the lines that
<code>line.contains(query)</code> returns <code>true</code> for. We then collect the matching lines
into another vector with <code>collect</code>. Much simpler! Feel free to make the same
change to use iterator methods in the <code>search_case_insensitive</code> function as
well.</p>
<p>The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. It’s a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so it’s easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.</p>
<p>But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Let’s talk about
performance.</p>
<h2><a class="header" href="#comparing-performance-loops-vs-iterators" id="comparing-performance-loops-vs-iterators">Comparing Performance: Loops vs. Iterators</a></h2>
<p>To determine whether to use loops or iterators, you need to know which version
of our <code>search</code> functions is faster: the version with an explicit <code>for</code> loop or
the version with iterators.</p>
<p>We ran a benchmark by loading the entire contents of <em>The Adventures of
Sherlock Holmes</em> by Sir Arthur Conan Doyle into a <code>String</code> and looking for the
word <em>the</em> in the contents. Here are the results of the benchmark on the
version of <code>search</code> using the <code>for</code> loop and the version using iterators:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>The iterator version was slightly faster! We won’t explain the benchmark code
here, because the point is not to prove that the two versions are equivalent
but to get a general sense of how these two implementations compare
performance-wise.</p>
<p>For a more comprehensive benchmark, you should check using various texts of
various sizes as the <code>contents</code>, different words and words of different lengths
as the <code>query</code>, and all kinds of other variations. The point is this:
iterators, although a high-level abstraction, get compiled down to roughly the
same code as if you’d written the lower-level code yourself. Iterators are one
of Rust’s <em>zero-cost abstractions</em>, by which we mean using the abstraction
imposes no additional runtime overhead. This is analogous to how Bjarne
Stroustrup, the original designer and implementor of C++, defines
<em>zero-overhead</em> in “Foundations of C++” (2012):</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you
don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
code any better.</p>
</blockquote>
<p>As another example, the following code is taken from an audio decoder. The
decoding algorithm uses the linear prediction mathematical operation to
estimate future values based on a linear function of the previous samples. This
code uses an iterator chain to do some math on three variables in scope: a
<code>buffer</code> slice of data, an array of 12 <code>coefficients</code>, and an amount by which
to shift data in <code>qlp_shift</code>. We’ve declared the variables within this example
but not given them any values; although this code doesn’t have much meaning
outside of its context, it’s still a concise, real-world example of how Rust
translates high-level ideas to low-level code.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>To calculate the value of <code>prediction</code>, this code iterates through each of the
12 values in <code>coefficients</code> and uses the <code>zip</code> method to pair the coefficient
values with the previous 12 values in <code>buffer</code>. Then, for each pair, we
multiply the values together, sum all the results, and shift the bits in the
sum <code>qlp_shift</code> bits to the right.</p>
<p>Calculations in applications like audio decoders often prioritize performance
most highly. Here, we’re creating an iterator, using two adaptors, and then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly you’d write by hand.
There’s no loop at all corresponding to the iteration over the values in
<code>coefficients</code>: Rust knows that there are 12 iterations, so it “unrolls” the
loop. <em>Unrolling</em> is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.</p>
<p>All of the coefficients get stored in registers, which means accessing the
values is very fast. There are no bounds checks on the array access at runtime.
All these optimizations that Rust is able to apply make the resulting code
extremely efficient. Now that you know this, you can use iterators and closures
without fear! They make code seem like it’s higher level but don’t impose a
runtime performance penalty for doing so.</p>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust’s capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rust’s goal to strive to provide zero-cost abstractions.</p>
<p>Now that we’ve improved the expressiveness of our I/O project, let’s look at
some more features of <code>cargo</code> that will help us share the project with the
world.</p>
<h1><a class="header" href="#更多關於-cargo-與-cratesio-的內容" id="更多關於-cargo-與-cratesio-的內容">更多關於 Cargo 與 Crates.io 的內容</a></h1>
<p>目前我們只使用了 Cargo 最基本的功能來建構、執行與測試我們的程式碼，但它還能做更多事。在本章節中我們將討論這些其他的進階功能，你將瞭解如何做到以下動作：</p>
<ul>
<li>透過發佈設定檔來自訂你的建構</li>
<li>發佈函式庫到 <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>透過工作空間組織大型專案</li>
<li>從 <a href="https://crates.io/">crates.io</a><!-- ignore --> 安裝二進制執行檔</li>
<li>使用自訂命令擴展 Cargo 的功能</li>
</ul>
<p>Cargo 能做的事還不止本章會介紹到的，所以想要知道它所有功能的話，歡迎查閱<a href="https://doc.rust-lang.org/cargo/">它的技術文件</a>。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch14-00-more-about-cargo.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過發佈設定檔自訂建構" id="透過發佈設定檔自訂建構">透過發佈設定檔自訂建構</a></h2>
<p>在 Rust 中*發佈設定檔（release profiles）*是個預先定義好並可用不同設置選項來自訂設定檔的，能讓程式設計師掌控更多選項來編譯程式碼。每個設定檔的設置彼此互相獨立。</p>
<p>Cargo 有兩個主要的設定檔：<code>dev</code> 設定檔會在當你對 Cargo 執行 <code>cargo build</code> 時所使用；<code>release</code> 設定檔會在當你對 Cargo 執行 <code>cargo build --release</code> 時所使用。<code>dev</code> 設定檔預設定義爲適用於開發時使用，而<code>release</code> 設定檔預設定義爲適用於發佈時使用。</p>
<p>你可能會覺得這些設定檔名稱很眼熟，因爲它們就已經顯示在輸出結果過：</p>
<!-- manual-regeneration
anywhere, run:
cargo build
cargo build --release
and ensure output below is accurate
-->
<pre><code class="language-console">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
$ cargo build --release
    Finished release [optimized] target(s) in 0.0s
</code></pre>
<p>此建構輸出顯示的 <code>dev</code> 與 <code>release</code> 代表編譯器會使用不同的設定檔。</p>
<p>當專案的 <em>Cargo.toml</em> 中沒有任何 <code>[profile.*]</code> 段落的話，Cargo 就會使用每個設定檔的預設設置。透過對你想要自訂的任何設定檔加上 <code>[profile.*]</code> 段落，你可以覆寫任何預設設定的子集。舉例來說，以下是 <code>dev</code> 與 <code>release</code> 設定檔中 <code>opt-level</code> 設定的預設數值：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p><code>opt-level</code> 設定控制了 Rust 對程式碼進行優化的程度，範圍從 0 到 3。提高優化程度會增加編譯時間，所以如果你在開發過程中得時常編譯程式碼的話，你會比較想要編譯快一點，就算結果程式碼會執行的比較慢。這就是 <code>dev</code> 的 <code>opt-level</code> 預設爲 0 的原因。當你準備好要發佈你的程式碼時，則最好花多點時間來編譯。你只需要在發佈模式編譯一次，但你的編譯程式則會被執行很多次，所以發佈模式選擇花費多點編譯時間來讓程式跑得比較快。這就是 <code>release</code> 的 <code>opt-level</code> 預設爲 3 的原因。</p>
<p>你可以在 <em>Cargo.toml</em> 加上不同的數值來覆蓋任何預設設定。舉例來說，如果我們希望在開發設定檔使用優化等級 1 的話，我們可以在專案的 <em>Cargo.toml</em> 檔案中加上這兩行：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>這樣就會覆蓋預設設定 <code>0</code>。現在當我們執行 <code>cargo build</code>，Cargo 就會使用 <code>dev</code> 設定檔的預設值以及我們自訂的 <code>opt-level</code>。因爲我們將 <code>opt-level</code> 設爲 <code>1</code>，Cargo 會比原本的預設進行更多優化，但沒有發佈建構那麼多。</p>
<p>對於完整的設置選項與每個設定檔的預設列表，請查閱 <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">Cargo 的技術文件</a>。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch14-01-release-profiles.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#發佈-crate-到-cratesio" id="發佈-crate-到-cratesio">發佈 Crate 到 Crates.io</a></h2>
<p>我們已經使用過 <a href="https://crates.io/">crates.io</a><!-- ignore --> 的套件來作爲我們專案的依賴函式庫，但是你也可以發佈你自己的套件來將你的程式碼提供給其他人使用。<a href="https://crates.io/">crates.io</a><!-- ignore --> 會發行套件的原始程式碼，所以它主要用來託管開源程式碼。</p>
<p>Rust 與 Cargo 有許多功能可以幫助其他人更容易找到並使用你發佈的套件。我們會介紹其中一些功能並解釋如何發佈套件。</p>
<h3><a class="header" href="#寫上有幫助的技術文件註解" id="寫上有幫助的技術文件註解">寫上有幫助的技術文件註解</a></h3>
<p>準確地加上套件的技術文件有助於其他使用者知道如何及何時使用它們，所以投資時間在寫技術文件上是值得的。在第三章我們提過如何使用兩條斜線 <code>//</code> 來加上 Rust 程式碼註解。Rust 還有個特別的註解用來作爲技術文件，俗稱爲<em>技術文件註解（documentation comment）</em>，這能用來產生 HTML 技術文件。這些 HTML 顯示公開 API 項目中技術文件註解的內容，讓對此函式庫有興趣的開發者知道如何<em>使用</em>你的 crate，而不需知道 crate 是如何<em>實作</em>的。</p>
<p>技術文件註解使用三條斜線 <code>///</code> 而不是兩條，並支援 Markdown 符號來格式化文字。技術文件註解位於它們對應項目的上方。範例 14-1 顯示了 <code>my_crate</code> crate 中 <code>add_one</code> 的技術文件註解：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">範例 14-1：函式的技術文件註解</span></p>
<p>我們在這裡加上了解釋函式 <code>add_one</code> 行爲的描述、加上一個標題爲 <code>Examples</code> 的段落並附上展示如何使用 <code>add_one</code> 函式的程式碼。我們可以透過執行 <code>cargo doc</code> 來從技術文件註解產生 HTML 技術文件。此命令會執行隨著 Rust 一起發佈的工具 <code>rustdoc</code>，並在 <em>target/doc</em> 目錄下產生 HTML 技術文件。</p>
<p>爲了方便起見，你可以執行 <code>cargo doc --open</code> 來建構當前 crate 的 HTML 技術文件（以及 crate 所有依賴的技術文件）並在網頁瀏覽器中開啟結果。導向到函式 <code>add_one</code> 而你就能看到技術文件註解是如何呈現的，如圖示 14-1 所示：</p>
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
<p><span class="caption">圖示 14-1：函式 <code>add_one</code> 的 HTML 技術文件</span></p>
<h4><a class="header" href="#常見技術文件段落" id="常見技術文件段落">常見技術文件段落</a></h4>
<p>我們在範例 14-1 使用 <code># Examples</code> Markdown 標題來在 HTML 中建立一個標題爲「Examples」的段落。以下是 crate 技術文件中常見的段落標題：</p>
<ul>
<li><strong>Panics</strong>：該函式可能會導致恐慌的可能場合。函式的呼叫者不希望他們的程式恐慌的話，就要確保他們沒有在這些情況下呼叫該函式。</li>
<li><strong>Errors</strong>：如果函式回傳 <code>Result</code>，解釋發生錯誤的可能種類以及在何種條件下可能會回傳這些錯誤有助於呼叫者，讓他們可以用不同方式來寫出處理不同種錯誤的程式碼。</li>
<li><strong>Safety</strong>: 如果呼叫的函式是 <code>unsafe</code> 的話（我們會在第十九章討論不安全的議題），就必須要有個段亂解釋爲何該函式是不安全的，並提及函式預期呼叫者要確保哪些不變條件（invariants）。</li>
</ul>
<p>大多數的技術文件註解不全都需要這些段落，但這些是呼叫程式碼的人可能有興趣瞭解的內容，你可以作爲提醒你的檢查列表。</p>
<h4><a class="header" href="#將技術文件註解作爲測試" id="將技術文件註解作爲測試">將技術文件註解作爲測試</a></h4>
<p>在技術文件註解加上範例程式碼區塊有助於解釋如何使用你的函式庫，而且這麼做還有個額外好處：執行 <code>cargo test</code> 也會將你的技術文件視爲測試來執行！在技術文件加上範例的確是最佳示範，但是如果程式碼在技術文件寫完之後變更的話，該範例可能就會無法執行了。如果我們對範例 14-1 中有附上技術文件的函式 <code>add_one</code> 執行 <code>cargo test</code> 的話，我們會看見測試結果有以下這樣的段落：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>現在如果我們變更函式或範例使其內的 <code>assert_eq!</code> 會恐慌並再次執行 <code>cargo test</code> 的話，我們會看到技術文件測試能互獲取錯誤，告訴我們範例與程式碼已經不同不了！</p>
<h4><a class="header" href="#包含項目結構的註解" id="包含項目結構的註解">包含項目結構的註解</a></h4>
<p>還有另一種技術文件註解的風格爲 <code>//!</code>，這是對其包含該註解的項目所加上的技術文件，而不是對註解後的項目所加上的技術文件。我通常將此技術文件註解用於 crate 源頭檔（通常爲 <em>src/lib.rs</em>）或模組來對整個 crate 或模組加上技術文件。</p>
<p>舉例來說，如果我們希望能加上技術文件來描述包含 <code>add_one</code> 函式的 <code>my_crate</code> 目的，我們可以用  <code>//!</code> 在 <em>src/lib.rs</em> 檔案開頭加上技術文件註解，如範例 14-2 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
<span class="boring">///
</span><span class="boring">/// # Examples
</span><span class="boring">///
</span><span class="boring">/// ```
</span><span class="boring">/// let arg = 5;
</span><span class="boring">/// let answer = my_crate::add_one(arg);
</span><span class="boring">///
</span><span class="boring">/// assert_eq!(6, answer);
</span><span class="boring">/// ```
</span><span class="boring">pub fn add_one(x: i32) -&gt; i32 {
</span><span class="boring">    x + 1
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 14-2：描述整個 <code>my_crate</code> crate 的技術文件</span></p>
<p>注意到 <code>//!</code> 最後一行之後並沒有緊貼任何程式碼，因爲我們是用 <code>//!</code> 而非 <code>///</code> 來下註解，我們是對包含此註解的整個項目加上技術文件，而不是此註解之後的項目。在此例中，包含此註解的項目爲 <em>src/lib.rs</em> 檔案，也就是 crate 的源頭。這些註解會描述整個 crate。</p>
<p>當我們執行 <code>cargo doc --open</code>，這些註解會顯示在 <code>my_crate</code> 技術文件的首頁，位於 crate 公開項目列表的上方，如圖示 14-2 所示：</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
<p><span class="caption">圖示 14-2：<code>my_crate</code> 的技術文件，包含描述整個 crate 的註解</span></p>
<p>項目中的技術文件註解可以用來分別描述 crate 和模組。用它們來將解釋容器整體的目的有助於你的使用者瞭解該 crate 的程式碼組織架構。</p>
<h3><a class="header" href="#透過-pub-use-匯出合適的公開-api" id="透過-pub-use-匯出合適的公開-api">透過 <code>pub use</code> 匯出合適的公開 API</a></h3>
<p>在第七章中，我們介紹了如何使用 <code>mod</code> 關鍵字來組織我們的程式碼成模組、如何使用 <code>pub</code> 關鍵字來公開項目，以及如何使用 <code>use</code> 關鍵字在將項目引入作用域。然而在開發 crate 時的架構雖然對你來說是合理的，但對你的使用者來說可能就不是那麼合適了。你可能會希望用有數個層級的分層架構來組織你的程式碼，但是要是有人想使用你定義在分層架構裡的型別時，它們可能就很難發現這些型別的存在。而且輸入 <code>use my_crate::some_module::another_module::UsefulType;</code> 是非常惱人的，我們會希望輸入 <code>use my_crate::UsefulType;</code> 就好。</p>
<p>公開 API 的架構是發佈 crate 時要考量到的一大重點。使用 crate 的人可能並沒有你那麼熟悉其中的架構，而且如果你的 crate 模組分層越深的話，他們可能就難以找到他們想使用的部分。</p>
<p>好消息是如果你的架構<em>不便於</em>其他函式庫所使用的話，你不必重新組織你的內部架構：你可以透過使用 <code>pub use</code>選擇重新匯出（re-export）項目來建立一個不同於內部私有架構的公開架構。重新匯出會先取得某處的公開項目，再從其他地方使其公開，讓它像是被定義在其他地方一樣。</p>
<p>舉例來說，我們建立了一個函式庫叫做 <code>art</code> 來模擬美術概念。在函式庫中有兩個模組：<code>kinds</code> 模組包含兩個枚舉 <code>PrimaryColor</code> 和 <code>SecondaryColor</code>；而 <code>utils</code> 模組包含一個函式 <code>mix</code>，如範例 14-3 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        SecondaryColor::Orange
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 14-3：函式庫 <code>art</code> 有兩個模組項目 <code>kinds</code> 和 <code>utils</code></span></p>
<p>圖示 14-3 顯示了此 crate 透過 <code>cargo doc</code> 產生的技術文件首頁：</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
<p><span class="caption">圖示 14-3：<code>art</code> 的技術文件首頁陳列了 <code>kinds</code> 和 <code>utils</code> 模組</span></p>
<p>注意到 <code>PrimaryColor</code> 與 <code>SecondaryColor</code> 型別沒有列在首頁，而函式 <code>mix</code> 也沒有。我們必須點擊 <code>kinds</code> 與 <code>utils</code> 才能看到它們。</p>
<p>其他依賴此函式庫的 crate 需要使用 <code>use</code> 陳述式來將 <code>art</code> 的項目引入作用域中，並指定當前模組定義的架構。範例 14-4 顯示了從 <code>art</code> crate 使用 <code>PrimaryColor</code> 和 <code>mix</code> 項目的 crate 範例：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">範例 14-4：一個使用 <code>art</code> 並匯出內部架構項目的 crate</span></p>
<p>範例 14-4 中使用 <code>art</code> crate 的程式碼作者必須搞清楚 <code>PrimaryColor</code> 位於 <code>kinds</code> 模組中而 <code>mix</code> 位於 <code>utils</code> 模組中。<code>art</code> crate 的模組架構對開發 <code>art</code> crate 的開發者才比較有意義，對使用 <code>art</code> crate 的開發者來說就沒那麼重要。內部架構是爲了組織 crate 的不同部分至 <code>kinds</code> 模組與 <code>utils</code> 模組，這對想要知道如何使用 <code>art</code> crate 的人來說沒有提供什麼有用的資訊。<code>art</code> crate 模組架構還容易造成混淆，因爲開發者得自己搞清楚要從何處找起。而且這樣的架構也很不方便，因爲開發者必須在 <code>use</code> 陳述式中指定每個模組名稱。</p>
<p>要從公開 API 移除內部架構，我們可以修改範例 14-3 中 <code>art</code> crate 的程式碼，並加上 <code>pub use</code> 陳述式來在頂層重新匯出項目，如範例 14-5 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
<span class="boring">    /// The primary colors according to the RYB color model.
</span><span class="boring">    pub enum PrimaryColor {
</span><span class="boring">        Red,
</span><span class="boring">        Yellow,
</span><span class="boring">        Blue,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// The secondary colors according to the RYB color model.
</span><span class="boring">    pub enum SecondaryColor {
</span><span class="boring">        Orange,
</span><span class="boring">        Green,
</span><span class="boring">        Purple,
</span><span class="boring">    }
</span>}

pub mod utils {
    // --snip--
<span class="boring">    use crate::kinds::*;
</span><span class="boring">
</span><span class="boring">    /// Combines two primary colors in equal amounts to create
</span><span class="boring">    /// a secondary color.
</span><span class="boring">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
</span><span class="boring">        SecondaryColor::Orange
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">範例 14-5：加上 <code>pub use</code> 陳述式來重新匯出項目</span></p>
<p><code>cargo doc</code> 對此 crate 產生的 API 技術文件現在就會顯示與連結重新匯出的項目到首頁中，如圖示 14-4 所示。讓<code>PrimaryColor</code> 與 <code>SecondaryColor</code> 型別以及函式 <code>mix</code> 更容易被找到。</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
<p><span class="caption">圖示 14-：<code>art</code> 的技術文件首頁會連結重新匯出的結果</span></p>
<p><code>art</code> crate 使用者仍可以看到並使用範例 14-3 的內部架構，如範例 14-4 所展示的方式，或者它們可以使用像範例 14-5 這樣更方便的架構，如範例 14-6 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::mix;
use art::PrimaryColor;

fn main() {
    // --snip--
<span class="boring">    let red = PrimaryColor::Red;
</span><span class="boring">    let yellow = PrimaryColor::Yellow;
</span><span class="boring">    mix(red, yellow);
</span>}
</code></pre>
<p><span class="caption">範例 14-6：使用從 <code>art</code> crate 重新匯出項目的程式</span></p>
<p>如果你有許多巢狀模組（nested modules）的話，在頂層透過 <code>pub use</code> 重新匯出型別可以大大提升使用 crate 的體驗。</p>
<p>提供實用的公開 API 架構更像是一門藝術而不只是科學，而你可以一步步來尋找最適合使用者的 API 架構。使用 <code>pub use</code> 可以給你更多組織 crate 內部架構的彈性，並將內部架構與你要呈現給使用者的介面互相解偶（decouple）。你可以觀察一些你安裝過的程式碼，看看它嗎的內部架構是不是不同於它們的公開 API。</p>
<h3><a class="header" href="#設定-cratesio-帳號" id="設定-cratesio-帳號">設定 Crates.io 帳號</a></h3>
<p>在你可以發佈任何 crate 之前，你需要建立一個 <a href="https://crates.io/">crates.io</a><!-- ignore --> 的帳號並取得一個 API token。請前往 <a href="https://crates.io/">crates.io</a><!-- ignore --> 的首頁並透過 GitHub 帳號來登入（GitHub 目前是必要的，但未來可能會支援其他建立帳號的方式）一旦你登入好了之後，到你的帳號設定 <a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> 並索取你的 API key，然後用這個 API key 來執行  <code>cargo login</code> 命令，如以下所示：</p>
<pre><code class="language-console">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>此命令會傳遞你的 API token 給 Cargo 並儲存在本地的 <em>~/.cargo/credentials</em>。注意此 token 是個<em>祕密（secret）</em>，千萬不要分享給其他人。如果你因爲任何原因分享給任何人的話，你最好撤銷掉並回到 <a href="https://crates.io/">crates.io</a><!-- ignore --> 產生新的 token。</p>
<h3><a class="header" href="#新增詮釋資料到新的-crate" id="新增詮釋資料到新的-crate">新增詮釋資料到新的 Crate</a></h3>
<p>現在你已經有個帳號，然後讓我們假設你有個 crate 想要發佈。在發佈之前，你需要對你的 crate 加上一些詮釋資料（metadata），也就是在 crate 的 <em>Cargo.toml</em> 檔案中 <code>[package]</code> 的段落內加上更多資料。</p>
<p>你的 crate 必須要有個獨特的名稱。雖然你在本地端開發 crate 時，你的 crate 可以是任何你想要的名稱。但是 <a href="https://crates.io/">crates.io</a><!-- ignore --> 上的 crate 名稱採先搶先贏制。一旦有 crate 名稱被取走了，其他人就不能再使用該名稱來發佈 crate。在嘗試發佈 crate 前，最好先在 <a href="https://crates.io/">crates.io</a><!-- ignore --> 上搜尋你想使用的名稱。如果該名稱已被其他 crate 使用，你就需要想另一個名稱，並在 <em>Cargo.toml</em> 檔案中 <code>[package]</code> 段落的 <code>name</code> 欄位使用新的名稱來發佈，如以下所示：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>當你選好獨特名稱後，此時執行 <code>cargo publish</code> 來發佈 crate 的話，你會得到以下警告與錯誤：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: api errors (status 200 OK): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata
</code></pre>
<p>原因是因爲你還缺少一些關鍵資訊：描述與授權條款是必須的，所以人們才能知道你的 crate 在做什麼以及在何種情況下允許使用。要修正此錯誤，你就需要將這些資訊加到 <em>Cargo.toml</em> 檔案中。</p>
<p>加上一兩句描述，它就會顯示在你的 crate 的搜尋結果中。置於 <code>license</code> 欄位，你需要給予 <em>license identifier value</em>。<a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data
Exchange (SPDX)</a> 有列出你可以使用的標識符數值。舉例來說，要指定你的 crate 使用 MIT 授權條款的話，就加上 <code>MIT</code> 標識符：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>如果你想使用沒有出現在 SPDX 的授權條款，你需要將該授權條款的文字儲存在一個檔案中、將該檔案加入你的專案中並使用 <code>license-file</code> 來指定該檔案名稱，而不使用 <code>license</code>。</p>
<p>你的專案適合使用什麼樣的授權條款超出了本書的範疇。不過 Rust 社群中許多人都會用 <code>MIT OR Apache-2.0</code> 雙授權條款作爲它們專案的授權方式，這和 Rust 的授權條款一樣。這也剛好展示你也可以用 <code>OR</code> 指定數個授權條款，讓你的專案擁有數個不同的授權方式。</p>
<p>有了當你用 <code>cargo new</code> 建立 crate 時就會產生的獨特名稱、版本與作者資訊，以及你的手動加入的描述與授權條款，已經準備好發佈的 <em>Cargo.toml</em> 檔案會如以下所示：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo 技術文件</a>還介紹了其他你可以指定的詮釋資料，讓你的 crate 更容易被其他人發掘並使用。</p>
<h3><a class="header" href="#發佈至-cratesio" id="發佈至-cratesio">發佈至 Crates.io</a></h3>
<p>現在你已經建立了帳號、儲存了 API token、選擇了 crate 的獨特名稱並指定了所需的詮釋資料，你現在已經準備好發佈了！發佈 crate 會上傳一個指定版本到 <a href="https://crates.io/">crates.io</a><!-- ignore --> 供其他人使用。</p>
<p>發佈 crate 時請格外小心，因爲發佈是會<em>永遠</em>存在的。該版本無法被覆寫，而且程式碼無法被刪除。<a href="https://crates.io/">crates.io</a><!-- ignore --> 其中一個主要目標就是要作爲儲存程式碼的永久伺服器，讓所有依賴 <a href="https://crates.io/">crates.io</a><!-- ignore --> 的 crate 的專案可以持續正常運作。允許刪除版本會讓此目標幾乎無法達成。不過你能發佈的 crate 版本不會有數量限制。</p>
<p>再次執行 <code>cargo publish</code> 命令，這次就應該會成功了：</p>
<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->
<pre><code class="language-console">$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>恭喜！你現在將你的程式碼分享給 Rust 社群了，任何人現在都可以輕鬆將你的 crate 加到他們的專案中作爲依賴了。</p>
<h3><a class="header" href="#publishing-a-new-version-of-an-existing-crate" id="publishing-a-new-version-of-an-existing-crate">Publishing a New Version of an Existing Crate</a></h3>
<p>When you’ve made changes to your crate and are ready to release a new version,
you change the <code>version</code> value specified in your <em>Cargo.toml</em> file and
republish. Use the <a href="http://semver.org/">Semantic Versioning rules</a> to decide what an
appropriate next version number is based on the kinds of changes you’ve made.
Then run <code>cargo publish</code> to upload the new version.</p>
<h3><a class="header" href="#透過-cargo-yank-移除-cratesio-的版本" id="透過-cargo-yank-移除-cratesio-的版本">透過 <code>cargo yank</code> 移除 Crates.io 的版本</a></h3>
<p>雖然你無法刪除 crate 之前的版本，你還是可以防止任何未來的專案加入它們作爲依賴。這在 crate 版本因某些原因而被破壞時會很有用。在這樣的情況下，Cargo 支援<em>撤回（yanking）</em> crate 版本。</p>
<p>撤回一個版本能防止新專案用該版本作爲依賴，同時允許現存依賴它的專案能夠繼續下載並依賴該版本。實際上，撤回代表所有專案的 <em>Cargo.lock</em> 都不會被破壞，且任何未來產生的 <em>Cargo.lock</em> 檔案不會使用被撤回的版本。</p>
<p>要撤回一個 crate 的版本，執行 <code>cargo yank</code> 並指定你想撤回的版本：</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1
</code></pre>
<p>而對命令加上 <code>--undo</code> 的話，你還可以在復原撤回的動作，允許其他專案可以再次依賴該版本：</p>
<pre><code class="language-console">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>撤回<em>並不會</em>刪除任何程式碼。舉例來說，撤回此功能並不會刪除任何不小心上傳的祕密訊息。如果真的出現這種情形，你必須立即重設那些資訊。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch14-02-publishing-to-crates-io.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#cargo-工作空間" id="cargo-工作空間">Cargo 工作空間</a></h2>
<p>在第十二章中，我們建立的套件包含一個二進制執行檔 crate 與一個函式庫 crate。隨著專案開發，你可能會發現函式庫 crate 變得越來越大，而你可能會想要將套件拆成數個函式庫 crate。針對這種情形，Cargo 提供了一個功能叫做*工作空間（workspaces）*能來幫助管理並開發數個相關的套件。</p>
<h3><a class="header" href="#建立工作空間" id="建立工作空間">建立工作空間</a></h3>
<p><em>工作空間</em>是一系列的共享相同 <em>Cargo.lock</em> 與輸出目錄的套件。讓我們建立個使用工作空間的專案，我們會使用簡單的程式碼，好讓我們能專注在工作空間的架構上。組織工作空間的架構有很多種方式，我們會顯示其中一種常見的方式。我們的工作空間將會包含一個二進制執行檔與兩個函式庫。執行檔會提供主要功能，並依賴其他兩個函式庫。其中一個函式庫會提供函式 <code>add_one</code>，而另一個函式庫會提供函式 <code>add_two</code>。這三個 crate 會包含在相同的工作空間中，我們先從建立工作空間的目錄開始：</p>
<pre><code class="language-console">$ mkdir add
$ cd add
</code></pre>
<p>接著在 <em>add</em> 目錄中，我們建立會設置整個工作空間的 <em>Cargo.toml</em> 檔案。此檔案不會有 <code>[package]</code> 段落或是我們在其他 <em>Cargo.toml</em> 檔案看過的詮釋資料。反之，他會使用一個 <code>[workspace]</code> 段落作爲起始，讓我們可以透過指定二進制 crate 的套件路徑來將它加到工作空間的成員中。在此例中，我們的路徑是 <em>adder</em>：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>接下來我們會在 <em>add</em> 目錄下執行 <code>cargo new</code> 來建立 <code>adder</code> 二進制 crate：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-01-adder-crate/add
rm -rf adder
cargo new adder
copy output below
-->
<pre><code class="language-console">$ cargo new adder
     Created binary (application) `adder` package
</code></pre>
<p>在這個階段，我們已經可以執行 <code>cargo build</code> 來建構工作空間。目錄 <em>add</em> 底下的檔案應該會看起來像這樣：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>工作空間在頂層有一個 <em>target</em> 目錄用來儲存編譯結果。<code>adder</code> 套件不會有自己的 <em>target</em> 目錄。就算我們在 <em>adder</em> 目錄底下執行 <code>cargo build</code>，編譯結果仍然會在 <em>add/target</em> 底下而非 <em>add/adder/target</em>。Cargo 之所以這樣組織工作空間的 <em>target</em> 目錄是因爲工作空間的 crate 是會彼此互相依賴的。 如果每個 crate 都有自己的 <em>target</em> 目錄，每個 crate 就得重新編譯工作空間中的其他每個 crate 才能將編譯結果放入它們自己的 <em>target</em> 目錄。共享 <em>target</em> 目錄的話，crate 可以避免不必要的重新建構。</p>
<h3><a class="header" href="#在工作空間中建立第二個套件" id="在工作空間中建立第二個套件">在工作空間中建立第二個套件</a></h3>
<p>接下來讓我們在工作空間中建立另一個套件成員 <code>add-one</code>。請修改頂層 <em>Cargo.toml</em> 來指定 <em>add-one</em> 的路徑到 <code>members</code> 列表中：</p>
<p><span class="filename">檔案名稱：Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<p>然後產生新的函式庫 crate <code>add-one</code>：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-02-add-one/add
rm -rf add-one
cargo new add-one --lib
copy output below
-->
<pre><code class="language-console">$ cargo new add-one --lib
     Created library `add-one` package
</code></pre>
<p><em>add</em> 目錄現在應該要擁有這些目錄與檔案：</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>在 <em>add-one/src/lib.rs</em> 檔案中，讓我們加上一個函式 <code>add_one</code>：</p>
<p><span class="filename">檔案名稱：add-one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>現在在我們在工作空間中有另一個套件了，我們可以讓我們 <code>adder</code> 套件的執行檔依賴擁有函式庫的 <code>add-one</code> 套件。首先，我們需要將 <code>add-one</code> 的路徑依賴加到 <em>adder/Cargo.toml</em>。</p>
<p><span class="filename">檔案名稱：adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<p>Cargo 不會假設工作空間下的 crate 會彼此依賴，我們我們要指定 crate 彼此之間依賴的關係。</p>
<p>接著讓我們在 <code>adder</code> 內使用 <code>add-one</code> crate 的 <code>add_one</code> 函式。開啟 <em>adder/src/main.rs</em> 檔案並在最上方加上 <code>use</code> 來將 <code>add-one</code> 函式庫引入作用域。然後變更 <code>main</code> 函式來呼叫 <code>add_one</code> 函式，如範例14-7 所示。</p>
<p><span class="filename">檔案名稱：adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(
        &quot;Hello, world! {} plus one is {}!&quot;,
        num,
        add_one::add_one(num)
    );
}
</code></pre>
<p><span class="caption">範例 14-7：在 <code>adder</code> crate 中使 <code>add-one</code> 函式庫 crate</span></p>
<p>讓我們在頂層的 <em>add</em> 目錄執行 <code>cargo build</code> 來建構工作空間吧！</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68s
</code></pre>
<p>要執行 <em>add</em> 目錄的二進制 crate，我們可以透過 <code>-p</code> 加上套件名稱使用 <code>cargo run</code> 來執行我們想要在工作空間中指定的套件：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-07/add
cargo run -p adder
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0s
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>這就會執行 <em>adder/src/main.rs</em> 的程式碼，其依賴於 <code>add-one</code> crate。</p>
<h4><a class="header" href="#在工作空間中依賴外部套件" id="在工作空間中依賴外部套件">在工作空間中依賴外部套件</a></h4>
<p>注意到工作空間只有在頂層有一個 <em>Cargo.lock</em> 檔案，而不是在每個 crate 目錄都有一個 <em>Cargo.lock</em>。這確保所有的 crate 都對所有的依賴使用相同的版本。如果我們加了 <code>rand</code> 套件到 <em>adder/Cargo.toml</em> 與 <em>add-one/Cargo.toml</em> 檔案中，Cargo 會將兩者的版本解析爲同一個 <code>rand</code> 版本並記錄到同個 <em>Cargo.lock</em> 中。確保工作空間所有 crate 都會使用相同依賴代表工作空間中的 crate 永遠都彼此相容。讓我們將 <code>rand</code> crate 加到 <em>add-one/Cargo.toml</em> 檔案的 <code>[dependencies]</code> 段落中，使 <code>add-one</code> crate 可以使用 <code>rand</code> crate：</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
-->
<p><span class="filename">檔案名稱：add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>我們現在就可以將 <code>use rand;</code> 加到 <em>add-one/src/lib.rs</em> 檔案中，接著在 <em>add</em> 目錄下執行 <code>cargo build</code> 來建構整個工作空間就會引入並編譯 <code>rand</code> crate：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-03-workspace-with-external-dependency/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
   --snip--
   Compiling rand v0.5.6
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18s
</code></pre>
<p>頂層的 <em>Cargo.lock</em> 現在就包含 <code>add-one</code> 有 <code>rand</code> 作爲依賴的資訊。不過就算我們能在工作空間的某處使用 <code>rand</code>，並不代表我們可以在工作空間的其他 crate 中使用它，除非它們的 <em>Cargo.toml</em> 也加上了 <code>rand</code>。舉例來說，如果我們將 <code>use rand;</code> 加到 <em>adder/src/main.rs</em> 檔案中想讓 <code>adder</code> 套件也使用的話，我們就會得到錯誤：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/output-only-03-use-rand/add
cargo build
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo build
  --snip--
   Compiling adder v0.1.0 (file:///projects/add/adder)
error[E0432]: unresolved import `rand`
 --&gt; adder/src/main.rs:2:5
  |
2 | use rand;
  |     ^^^^ no `rand` external crate
</code></pre>
<p>要修正此問題，只要修改 <code>adder</code> 套件的 <em>Cargo.toml</em> 檔案，指示它也加入 <code>rand</code> 作爲依賴就好了。這樣建構 <code>adder</code> 套件就會將在 <em>Cargo.lock</em> 中將 <code>rand</code> 加入 <code>adder</code> 的依賴，但是沒有額外的 <code>rand</code> 會被下載。Cargo 會確保工作空間中每個套件的每個 crate 都會使用相同的 <code>rand</code> 套件版本。在工作空間中使用相同版本的 <code>rand</code> 可以節省空間，因爲我們就不會重複下載並能確保工作空間中的 crate 彼此可以互相兼容。</p>
<h4><a class="header" href="#在工作空間中新增測試" id="在工作空間中新增測試">在工作空間中新增測試</a></h4>
<p>讓我們再進一步加入一個測試函式 <code>add_one::add_one</code> 到 <code>add_one</code> crate 之中：</p>
<p><span class="filename">檔案名稱：add-one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>現在在頂層的 <em>add</em> 目錄執行 <code>cargo test</code>：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.27s
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-49979ff40686fa8e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>輸出的第一個段落顯示了 <code>add-one</code> crate 中的 <code>it_works</code> 測試通過。下一個段落顯示 <code>adder</code> crate 沒有任何測試，然後最後一個段落顯示 <code>add-one</code> 中沒有任何技術文件測試。在像工作空間這樣的架構下執行 <code>cargo test</code> 就會執行工作空間內的所有 crate 測試。</p>
<p>我們也可以在頂層目錄使用 <code>-p</code> 並指定我們想測試的 crate 名稱來測試工作空間中特定的 crate：</p>
<!-- manual-regeneration
cd listings/ch14-more-about-cargo/no-listing-04-workspace-with-tests/add
cargo test -p add-one
copy output below; the output updating script doesn't handle subdirectories in paths properly
-->
<pre><code class="language-console">$ cargo test -p add-one
    Finished test [unoptimized + debuginfo] target(s) in 0.00s
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>此輸出顯示 <code>cargo test</code> 只執行了 <code>add-one</code> crate 的測試並沒有執行 <code>adder</code> crate 的測試。</p>
<p>如果你想要發佈工作空間的 crate 到 <a href="https://crates.io/">crates.io</a>，工作空間中的每個 crate 必須分別獨自發佈。<code>cargo publish</code> 命令並沒有 <code>--all</code> 或是 <code>-p</code> 之類的選項，所以你必須移動到每個 crate 的目錄並執行 <code>cargo publish</code>，這樣工作空間中的每個 crate 才會發佈出去。</p>
<p>之後想嘗試練習的話，你可以在工作空間中在加上 <code>add-two</code> crate，方式和 <code>add-one</code> crate 類似！</p>
<p>隨著你的專案成長，你可以考慮使用工作空間：拆成各個小部分比一整塊大程式還更容易閱讀。再者，如果需要經常同時修改的話，將 crate 放在同個工作空間中更易於彼此的協作。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch14-03-cargo-workspaces.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過-cargo-install-從-cratesio-安裝二進制執行檔" id="透過-cargo-install-從-cratesio-安裝二進制執行檔">透過 <code>cargo install</code> 從 Crates.io 安裝二進制執行檔</a></h2>
<p><code>cargo install</code> 命令讓你能本地安裝並使用二進制執行檔 crates。這並不是打算要取代系統套件，這是爲了方便讓 Rust 開發者可以安裝 <a href="https://crates.io/">crates.io</a><!-- ignore --> 上分享的工具。注意你只能安裝有二進制目標的套件。*二進制目標（binary target）*是在 crate 有 <em>src/main.rs</em> 檔案或其他指定的二進制檔案時，所建立的可執行程式。而相反地，函式庫目標就無法單獨執行，因爲它提供給其他程式使用的函式庫。通常 crate 都會提供 <em>README</em> 檔案說明此 crate 是函式庫還是二進制目標，或者兩者都是。</p>
<p>所有透過 <code>cargo install</code> 安裝的二進制檔案都儲存在安裝根目錄的 <em>bin</em> 資料夾中。如果你是用 <em>rustup.rs</em>  安裝 Rust 且沒有任何自訂設置的話，此目錄會是 <em>$HOME/.cargo/bin</em>。請確定該目錄有在你的 <code>$PATH</code> 中，這樣才能夠執行 <code>cargo install</code> 安裝的程式。</p>
<p>舉例來說，範例 12 我們提到有個 Rust 版本的 <code>grep</code> 工具叫做 <code>ripgrep</code> 能用來搜尋檔案。如果我們想要安裝 <code>ripgrep</code> 的話，我們可以執行以下命令：</p>
<!-- manual-regeneration
cargo install something you don't have, copy relevant output below
-->
<pre><code class="language-console">$ cargo install ripgrep
    Updating crates.io index
  Downloaded ripgrep v11.0.2
  Downloaded 1 crate (243.3 KB) in 0.88s
  Installing ripgrep v11.0.2
--snip--
   Compiling ripgrep v11.0.2
    Finished release [optimized] target(s) in 3m 10s
  Installing ~/.cargo/bin/rg
   Installed package `ripgrep v11.0.2` (executable `rg`)
</code></pre>
<p>輸出的最後兩行顯示了二進制檔案的安裝位置與名稱，在 <code>ripgrep</code> 此例中就是 <code>rg</code>。如稍早提到的，只要你的 <code>$PATH</code> 有包含安裝目錄，你就可以執行 <code>rg --help</code> 並開始使用更快更鏽的搜尋檔案工具！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch14-04-installing-binaries.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過自訂命命來擴展-cargo-的功能" id="透過自訂命命來擴展-cargo-的功能">透過自訂命命來擴展 Cargo 的功能</a></h2>
<p>Cargo 的設計能讓你在不用修改 Cargo 的情況下擴展新的子命令。如果你 <code>$PATH</code> 中有任何叫做 <code>cargo-something</code> 的二進制檔案，你就可以用像是執行 Cargo 子命令的方式 <code>cargo something</code> 來執行它。像這樣的自訂命令在你執行 <code>cargo --list</code> 時也會顯示出來。能夠透過 <code>cargo install</code> 來安裝擴展插件並有如內建 Cargo 工具般來執行使用是 Cargo 設計上的一大方便優勢！</p>
<h2><a class="header" href="#總結-10" id="總結-10">總結</a></h2>
<p>透過 Cargo 與 <a href="https://crates.io/">crates.io</a><!-- ignore --> 分享程式碼是讓 Rust 生態系統能適用於許多不同任務的重要部分之一。Rust 的標準函式庫既小又穩定，但是 crate 可以很容易地分享、使用，並在語言本身不同的時間線來進行改善。千萬別吝嗇於分享你認爲實用的程式碼到 <a href="https://crates.io/">crates.io</a><!-- ignore -->，其他人可能也會覺得它很有幫助！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch14-05-extending-cargo.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h1><a class="header" href="#智慧指標" id="智慧指標">智慧指標</a></h1>
<p>*指標（pointer）*是一個將變數儲存記憶體位址的通用概念。此引位址引用，或者說是「指向」一些其他資料。Rust 中最常見的指標種類就是第四章介紹的引用（reference）。引用以 <code>&amp;</code> 符號作爲指示並借用它們指向的數值。它們除了引用資料以外，沒有其他的特殊能力。此外，它們也沒有任何額外開銷，所以這是我們最常使用到的指標種類。</p>
<p>另一方面，*智慧指標（Smart pointers）<em>是個不止會有像是指標的行爲，還會包含擁有的詮釋資料與能力。智慧指標的概念並不是 Rust 獨有的，智慧指標起源於 C++ 且也都存在於其他語言。在 Rust 中，定義在標準函式庫中的不同智慧指標不止能引用，還更多的功能。其中一個我們會在本章䩞探索到的就是</em>引用計數（reference counting）*智慧指標型別。此指標允許一個資料可以有多個擁有者，並追蹤擁有者的數量，當沒有任何擁有者時，就清除資料。</p>
<p>在 Rust 中，我們有所有權與借用的概念，所以引用與智慧指標之間還有有一項差別。引用是只有借用資料的指標，但智慧指標在很多時候都<em>擁有</em>它們指向的資料。</p>
<p>我們已經在本書中遇過一些智慧指標了，像是第八章的 <code>String</code> 和 <code>Vec&lt;T&gt;</code>，雖然當時我們沒有稱呼它們爲智慧指標。這些型別都算是智慧指標，因爲它們都擁有一些記憶體並允許你操控它們。它們也有詮釋資料（像是容量）以及額外的能力或保障（像是 <code>String</code> 確保其資料永遠是有效的 UTF-8）。</p>
<p>智慧指標通常都使用結果體實作。要區分智慧指標與一般結構體的差別爲智慧指標會實作 <code>Deref</code> 與 <code>Drop</code> 特徵。<code>Deref</code> 特徵允許智慧指標結構體的實例表現的像是引用一樣，讓你可以寫出能用在引用與智慧指標的程式碼。<code>Drop</code> 特徵允許你自訂當智慧指標實例離開作用域時要執行的程式碼。在本章節我們會討論這兩個特徵並解釋爲何它們對智慧指標很重要。</p>
<p>有鑑於智慧指標在 Rust 是個常用的通用設計模式，本章不會涵蓋每一個現有的智慧指標。許多函式庫也都會提供它們自己的智慧指標，你甚至能寫個你自己的。我們會提及標準函式庫中最常用到的智慧指標：</p>
<ul>
<li><code>Box&lt;T&gt;</code> 將數值分配到堆積上</li>
<li><code>Rc&lt;T&gt;</code>, 引用計數型別來允許資料能有數個擁有者</li>
<li><code>Ref&lt;T&gt;</code> 與 <code>RefMut&lt;T&gt;</code> 透過 <code>RefCell&lt;T&gt;</code> 來取得，這是在執行時而非編譯時強制執行借用規則的型別</li>
</ul>
<p>除此之外，我們還會涵蓋到*內部可變性（interior mutability）<em>模式，這讓不可變引用的型別能提供改變內部數值的 API。我們還會討論</em>引用循環（reference cycles）*爲何會導致記憶體泄漏以及如何預防它們。</p>
<p>讓我們開始吧！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch15-00-smart-pointers.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#使用-boxt-指向堆積上的資料" id="使用-boxt-指向堆積上的資料">使用 <code>Box&lt;T&gt;</code> 指向堆積上的資料</a></h2>
<p>最直白的智慧指標是 <em>box</em> 其型別爲 <code>Box&lt;T&gt;</code>。Box 允許你儲存資料到堆積上，而不是堆疊。留在堆疊上的會是指向堆積資料的指標。你可以回顧第四章瞭解堆疊與堆積的差別。</p>
<p>Box 沒有額外的效能開銷，就只是將它們的資料儲存在堆積上而非堆疊而已。不過相對地它們也沒有多少額外功能。你大概會在這些場合用到它們：</p>
<ul>
<li>當你有個型別無法在編譯時期確定大小，而你又想在需要知道確切大小的情況下使用該型別的數值</li>
<li>當你有個龐大的資料，而你想要轉移所有權並確保資料不會被拷貝。</li>
<li>當你想要擁有某個值，但你只在意該型別有實作特定的特徵，而不再是何種特定型別</li>
</ul>
<p>我們會在<a href="ch15-01-box.html#enabling-recursive-types-with-boxes">「透過 Box 建立遞迴型別」</a><!-- ignore -->段落解說第一種情形。而在第二種情形，轉移龐大的資料的所有權可能會很花費時間，因爲在堆疊上的話會拷貝所有資料。要改善此情形，我們可以用 box 將龐大的資料儲存在堆積上。這樣就只有少量的指標資料在堆疊上被拷貝，而其引用的資料仍然保留在堆積上的同個位置。第三種情況被<em>特徵物件（trait object）</em>，第十七章會花整個<a href="ch17-02-trait-objects.html">「允許不同型別數值的特徵物件」</a><!-- ignore -->段落來討論此議題。所以你在此學到的到第十七章會再次用上！</p>
<h3><a class="header" href="#使用-boxt-儲存資料到堆積上" id="使用-boxt-儲存資料到堆積上">使用 <code>Box&lt;T&gt;</code> 儲存資料到堆積上</a></h3>
<p>在我們討論 <code>Box&lt;T&gt;</code> 的使用場合前，我們會先介紹語法以及如何對 <code>Box&lt;T&gt;</code> 內儲存的數值進行互動。</p>
<p>範例 15-1 顯示如何使用 box 在堆積上儲存一個 <code>i32</code> 數值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">範例 15-1：使用 box 在堆積上儲存一個 <code>i32</code> 數值</span></p>
<p>我們定義了變數 <code>b</code> 其數值爲 <code>Box</code> 分配在堆積上指向的數值 <code>5</code>。程式在此例會印出 <code>b = 5</code>，在此例中我們可以用在堆疊上相同的方式取得 box 的資料。就像任何有所有權的數值一樣，當 box 離開作用域時會釋放記憶體，在此例就是當 <code>b</code> 抵達 <code>main</code> 結尾的時候。釋放記憶體作用於 box（儲存在堆疊上）以及其所指向的資料（儲存在堆積上）。</p>
<p>將單一數值放在堆積上的確沒什麼用處，所以你不會對這種類型經常使用 box。在大多數情況下將像 <code>i32</code> 這種單一數值預設儲存在堆疊的確比較適合。</p>
<h3><a class="header" href="#透過-box-建立遞迴型別" id="透過-box-建立遞迴型別">透過 Box 建立遞迴型別</a></h3>
<p>在編譯時期，Rust 需要知道一個型別佔用的空間有多少。其中一種無法在編譯期間知道大小的型別就是<em>遞迴型別（recursive type）</em>，其值的一部分可以是相同型別的另一個值。由於這種巢狀數值理論上可以無限循環下去，Rust無法知道一個遞迴型別的數值需要多大的空間。然而 box 則有已知大小，所以將 box 填入遞迴型別定義中，你就可以有遞迴型別了。</p>
<p>讓我們來探索 <em>cons list</em>，這是個在函式程式語言中常見的資料型別，很適合作爲遞迴型別的範例。我們要定義的 cons list 型別除了遞迴的部分以外都很直白，因此這個例子的概念在往後你遇到更複雜的遞迴型別時會很實用。</p>
<h4><a class="header" href="#更多關於-cons-list-的資訊" id="更多關於-cons-list-的資訊">更多關於 Cons List 的資訊</a></h4>
<p><em>cons list</em> 是個起源於 Lisp 程式設計語言與其方言的資料結構。在 Lisp 中，<code>cons</code> 函式（「construct function」的縮寫）會從兩個引數建構一個新的配對，而這通常是一個數值與另一個配對，而這些配對就包含了列表中的配對。</p>
<p>cons 函式的概念在往後成了常見的函式語言術語：「將 <em>x</em> cons 到 <em>y</em>」通常代表的是建立一個新的容器實例，將元素 <em>x</em> 置於此容器的開頭，而後方則是連接到容器 <em>y</em>。</p>
<p>每個 cons list 的項目都包含兩個元素：目前項目的數值與下一個項目。列表中的最後一個項目只會包含一個數值叫做 <code>Nil</code>，並不會再連接下一個項目。cons list 透過遞迴呼叫 <code>cons</code> 函式來產生。表示遞迴終止條件的名稱爲 <code>Nil</code>。注意這和第六章提到的「null」或「nil」的概念不全然相同，這些代表的是無效或空缺的數值。</p>
<p>雖然函式程式設計語言很常使用 cons lists，但在 Rust 中 cons lists 卻不是常見的資料結構。大多數當你在 Rust 需要項目列表時，<code>Vec&lt;T&gt;</code> 會是比較好的選擇。而其他時候夠複雜的遞迴資料型別<em>確實</em>在各種特殊情形會很實用，不過先從 cons list 開始的話，我們可以專注探討 box 如何讓我們定義遞迴資料型別。</p>
<p>範例 15-2 包含了 cons list 的枚舉定義。注意到此程式碼還不能編譯過，因爲 <code>List</code> 型別並沒有以已知大小，我們接下來會繼續說明。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">範例 15-2：第一次嘗試定義一個枚舉來代表有 <code>i32</code> 數值的 cons list 資料結構</span></p>
<blockquote>
<p>注意：我們定義的 cons list 只有 <code>i32</code> 數值是爲了範例考量。我們當然可以使用第十章討論過的泛型來定義它，讓 cons list 定義的型別可以儲存任何型別數值。</p>
</blockquote>
<p>使用 <code>List</code> 型別來儲存 <code>1, 2, 3</code> 列表的話會如範例 15-3 的程式碼所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, List),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span>use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">範例 15-3：使用 <code>List</code> 枚舉儲存列表 <code>1, 2, 3</code></span></p>
<p>第一個 <code>Cons</code> 值會得到 <code>1</code> 與另一個 <code>List</code> 數值。此 <code>List</code> 數值是另一個 <code>Cons</code> 數值且持有 <code>2</code> 與另一個 <code>List</code> 數值。此 <code>List</code> 數值是另一個 <code>Cons</code> 數值且擁有 <code>3</code> 與一個 <code>List</code> 數值，其就是最後的 <code>Nil</code>，這是傳遞列表結尾訊號的非遞迴變體。</p>
<p>如果我們嘗試編譯範例 15-3 的程式碼，我們會得到範例 15-4 的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ---- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable

error[E0391]: cycle detected when processing `List`
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^
  |
  = note: ...which again requires processing `List`, completing the cycle
  = note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, def_id: None }, value: List } }`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0072, E0391.
For more information about an error, try `rustc --explain E0072`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<p><span class="caption">範例 15-4：嘗試定義遞迴枚舉所得到的錯誤</span></p>
<p>錯誤顯示此型別的「大小爲無限」，原因是因爲我們定義的 <code>List</code> 有個變體是遞迴：它直接存有另一個相同類型的數值。所以 Rust 無法判別出它需要多少空間才能儲存一個 <code>List</code> 的數值。讓我進一步研究爲何我們會得到這樣的錯誤，首先來看 Rust 如何決定要分配多少空間來儲存非遞迴型別。</p>
<h4><a class="header" href="#計算非遞迴型別的大小" id="計算非遞迴型別的大小">計算非遞迴型別的大小</a></h4>
<p>回想一下第六章中，當我們在討論枚舉定義時，我們在範例 6-2 定義的 <code>Message</code> 枚舉：</p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>要決定一個 <code>Message</code> 數值需要分配多少空間，Rust 會遍歷每個變體來看哪個變體需要最大的空間。Rust 會看到 <code>Message::Quit</code> 不佔任何空間、<code>Message::Move</code> 需要能夠儲存兩個 <code>i32</code> 的空間，以此類推。因爲只有一個變體會被使用，一個 <code>Message</code> 數值所需的最大空間就是其最大變體的大小。</p>
<p>將此對應到當 Rust 嘗試檢查像是範例 15-2 的 <code>List</code> 枚舉來決定遞迴型別需要多少空間時，究竟會發生什麼事。編譯器先從查看 <code>Cons</code> 的變體開始，其存有一個 <code>i32</code> 型別與一個 <code>List</code> 型別。因此 <code>Cons</code> 需要的空間大小爲 <code>i32</code> 的大小加上 <code>List</code> 的大小。爲了要瞭解 <code>List</code> 型別需要的多少記憶體，編譯器在進一步看它的變體，也是從 <code>Cons</code> 變體開始。<code>Cons</code> 變體存有一個型別 <code>i32</code> 與一個型別 <code>List</code>，而這樣的過程就無限處理下去，如圖示 15-1 所示。</p>
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">圖示 15-1：無限個 <code>List</code> 包含著無限個 <code>Cons</code> 變體</span></p>
<h4><a class="header" href="#使用-boxt-取得已知大小的遞迴型別" id="使用-boxt-取得已知大小的遞迴型別">使用 <code>Box&lt;T&gt;</code> 取得已知大小的遞迴型別</a></h4>
<p>Rust 無法判別出遞迴定義型別要分配多少空間，所以編譯器給了範例 15-4 的錯誤，但是此錯誤有提供實用的建議：</p>
<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `List` representable
</code></pre>
<p>在此建議中，「indirection」代表與其直接儲存數值，我們可以變更資料結構，間接儲存指向數值的指標。</p>
<p>因爲 <code>Box&lt;T&gt;</code> 是個指標，Rust 永遠知道 <code>Box&lt;T&gt;</code> 需要多少空間：指標的大小不會隨著指向的資料數量而改變。這代表我們可以將 <code>Box&lt;T&gt;</code> 存入 <code>Cons</code> 變體而非直接儲存另一個 <code>List</code> 數值。<code>Box&lt;T&gt;</code> 會指向另一個存在於堆積上的 <code>List</code> 數值而不是存在 <code>Cons</code> 變體中。概念上我們仍然有建立一個<em>持有</em>其他列表的列表，但此實作更像是將項目接著另一個項目排列，而非包含另一個在內。</p>
<p>我們可以改變範例 15-2 的 <code>List</code> 枚舉定義以及範例 15-3 <code>List</code> 的使用方式，將其寫入範例 15-5，這次就能夠編譯過了：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">範例 15-5：使用 <code>Box&lt;T&gt;</code> 定義的 <code>List</code> 就有已知大小</span></p>
<p><code>Cons</code> 變體需要的大小爲 <code>i32</code> 加上儲存 box 指標的空間。<code>Nil</code> 變體沒有儲存任何數值，所以它需要的空間比 <code>Cons</code> 變體少。現在我們知道任何
We now know that any <code>List</code> 數值會佔的空間都是一個 <code>i32</code> 加上 box 指標的大小。透過使用 box，我們打破了無限遞迴，所以編譯器可以知道儲存一個 <code>List</code> 數值鎖需要的大小。圖示 15-2 顯示了 <code>Cons</code> 變體看起來的樣子。</p>
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
<p><span class="caption">圖示 15-2：不再是無限大小的 <code>List</code>，因爲其 <code>Cons</code> 存的是 <code>Box</code></span></p>
<p>Boxes 只提供了間接儲存與堆積分配，它們沒有其他任何特殊功能，比如我們等下就會看到的其他智慧指標型別。它們也沒有任何因這些特殊功能產生的額外效能開銷，所以它們很適合用於像是 cons list 這種我們只需要間接儲存的場合。我們在第十七章還會再介紹到更多 box 的使用情境。</p>
<p><code>Box&lt;T&gt;</code> 型別是智慧指標是因爲它有實作 <code>Deref</code> 特徵，讓 <code>Box&lt;T&gt;</code> 的數值可以被視爲引用所使用。當 <code>Box&lt;T&gt;</code> 數值離開作用域時，該 box 指向的堆積資料也會被清除，因爲其有 <code>Drop</code> 特徵實作。讓我們來探討這兩種特徵的細節吧。這兩種特徵對於本章將會討論的其他智慧指標型別所提供的功能，將會更加重要。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch15-01-box.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過-deref-特徵將智慧指標視為一般引用" id="透過-deref-特徵將智慧指標視為一般引用">透過 <code>Deref</code> 特徵將智慧指標視為一般引用</a></h2>
<p>實作 <code>Deref</code> 特徵讓你可以自訂<em>解引用運算子（dereference operator）</em> <code>*</code> 的行爲（而不是相乘或全域運算子）。透過這種方式實作 <code>Deref</code> 的智慧指標可以被視爲正常引用來對待，這樣操作引用的程式碼也能用在智慧指標中。</p>
<p>讓我們先看解引用運算子如何在正常引用中使用。然後我們會嘗試定義一個行爲類似 <code>Box&lt;T&gt;</code> 的自定型別，並看看爲何解引用運算子無法像引用那樣用在我們新定義的型別。我們將會探討如何實作 <code>Deref</code> 特徵使智慧指標能像類似引用的方式運作。接著我們會看看 Rust 的*強制解引用（deref coercion）*功能並瞭解它如何處理引用與智慧指標。</p>
<blockquote>
<p>注意：我們即將定義的 <code>MyBox&lt;T&gt;</code> 型別與真正的 <code>Box&lt;T&gt;</code> 有一項很大的差別，就是我們的版本不會將其資料儲存在堆積上。我們在此例會專注在 <code>Deref</code> 上，所以資料實際上儲存在何處，並沒有比指標相關行爲來得重要。</p>
</blockquote>
<h3><a class="header" href="#使用解引用運算子追蹤指標的數值" id="使用解引用運算子追蹤指標的數值">使用解引用運算子追蹤指標的數值</a></h3>
<p>一般引用一種指標，其中一種理解指標的方式是看成一個會指向存於某處數值的箭頭。在範例 15-6 中我們建立了數值 <code>i32</code> 的引用，接著使用解引用運算子來追蹤引用的資料：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">範例 15-6：使用解引用運算子來追蹤數值 <code>i32</code> 的引用</span></p>
<p>變數 <code>x</code> 存有 <code>i32</code> 數值 <code>5</code>。我們將 <code>y</code> 設置爲 <code>x</code> 的引用。我們可以判定 <code>x</code> 等於 <code>5</code>。不過要是我們想要判定 <code>y</code> 數值的話，我們需要使用 <code>*y</code> 來追蹤引用指向的數值（也就是<em>解引用</em>）。一旦我們解引用 <code>y</code>，我們就能取得 <code>y</code> 指向的整數數值並拿來與 <code>5</code> 做比較。</p>
<p>如果我們嘗試寫說 <code>assert_eq!(5, y);</code> 的話，我們會得到此編譯錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`
  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>比較一個數字與一個數字的引用是不允許的，因爲它們是不同的型別。我們必須使用解引用運算子來追蹤其指向的數值。</p>
<h3><a class="header" href="#像引用般使用-boxt" id="像引用般使用-boxt">像引用般使用 <code>Box&lt;T&gt;</code></a></h3>
<p>我們將範例 15-6 的引用改用 <code>Box&lt;T&gt;</code> 重寫。解引用運算子的使用方式如範例 15-7 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">範例 15-7：對 <code>Box&lt;i32&gt;</code> 使用解引用運算子</span></p>
<p>範例 15-7 與範例 15-6 唯一的差別在於這裡我們設置 <code>y</code> 爲一個指向 <code>x</code> 的拷貝數值的 box 實例，而不是指向 <code>x</code> 數值的引用。在最後的判定中，我們可以對 box 的指標使用解引用運算子，跟我們對當 <code>y</code> 還是引用時所做的動作一樣。接下來，我們要來探討 <code>Box&lt;T&gt;</code> 有何特別之處，讓我們可以對自己定義的 box 型別也可以使用解引用運算子。</p>
<h3><a class="header" href="#定義我們自己的智慧指標" id="定義我們自己的智慧指標">定義我們自己的智慧指標</a></h3>
<p>讓我們定義一個與標準函式庫所提供的 <code>Box&lt;T&gt;</code> 型別類似的智慧指標，並看看智慧指標預設行爲與引用有何不同。然後我們就會來看能夠使用解引用運算子的方式。</p>
<p><code>Box&lt;T&gt;</code> 本質上就是定義成只有一個元素的元組結構體，所以範例 15-8 用相同的方式來定義 <code>MyBox&lt;T&gt;</code>。我們也定義了 <code>new</code> 函式來對應於 <code>Box&lt;T&gt;</code> 的 <code>new</code> 函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 15-8：定義 <code>MyBox&lt;T&gt;</code> 型別</span></p>
<p>我們定義了一個結構體叫做 <code>MyBox</code> 並宣告一個泛型參數 <code>T</code>，因爲我們希望我們的型別能存有任何型別的數值。<code>MyBox</code> 是個只有一個元素型別爲 <code>T</code> 的元組結構體。<code>MyBox::new</code> 函式接受一個參數型別爲 <code>T</code> 並回傳存有該數值的 <code>MyBox</code> 實例。</p>
<p>讓我們將範例 15-7 的 <code>main</code> 函式加到範例 15-8 並改成使用我們定義的 <code>MyBox&lt;T&gt;</code> 型別而不是原本的 <code>Box&lt;T&gt;</code>。範例 15-9 的程式碼無法編譯，因爲 Rust 不知道如何解引用<code>MyBox</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">範例 15-9：嘗試像使用 <code>Box&lt;T&gt;</code> 和引用一樣的方式來使用 <code>MyBox&lt;T&gt;</code></span></p>
<p>以下是編譯結果出現的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling deref-example v0.1.0 (file:///projects/deref-example)
error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0614`.
error: could not compile `deref-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>我們的 <code>MyBox&lt;T&gt;</code> 型別無法解引用因爲我們還沒有對我們的型別實作該能力。要透過 <code>*</code> 運算子來解引用的話，我們要實作 <code>Deref</code> 特徵。</p>
<h3><a class="header" href="#透過實作-deref-特徵來將一個型別能像引用般對待" id="透過實作-deref-特徵來將一個型別能像引用般對待">透過實作 <code>Deref</code> 特徵來將一個型別能像引用般對待</a></h3>
<p>如同第十章講過的，要實作一個特徵的話，我們需要提供該特徵要求的方法實作。標準函式庫所提供的 <code>Deref</code> 特徵要求我們實作一個方法叫做 <code>deref</code>，這會借用 <code>self</code> 並回傳內部資料的引用。範例 15-10 包含了對 <code>MyBox</code> 定義加上的 <code>Deref</code> 實作：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Deref;

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
<span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let x = 5;
</span><span class="boring">    let y = MyBox::new(x);
</span><span class="boring">
</span><span class="boring">    assert_eq!(5, x);
</span><span class="boring">    assert_eq!(5, *y);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 15-10：對 <code>MyBox&lt;T&gt;</code> 實作 <code>Deref</code></span></p>
<p><code>type Target = T;</code> 語法定義了一個供 <code>Deref</code> 特徵使用的關聯型別。關聯型別與宣告泛型參數會有一點差別，但是你現在先不用擔心它們，我們會在第十九章深入探討。</p>
<p>我們對 <code>deref</code> 的方法本體加上 <code>&amp;self.0</code>，<code>deref</code> 就可以回傳一個引用讓我們可以使用 <code>*</code> 運算子取得數值。範例 15-9 的 <code>main</code> 函式現在對 <code>MyBox&lt;T&gt;</code> 數值的 <code>*</code> 呼叫就可以編譯了，而且判定也會通過！</p>
<p>沒有 <code>Deref</code> 特徵的話，編譯器只能解引用 <code>&amp;</code> 的引用。<code>deref</code> 方法讓編譯器能夠從任何有實作 <code>Deref</code> 的型別呼叫 <code>deref</code> 方法取得 <code>&amp;</code> 引用，而它就可以進一步解引用獲取數值。</p>
<p>當我們在範例 15-9 中輸入 <code>*y</code> 時，Rust 背後實際上是執行此程式碼：</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust 將 <code>*</code> 運算子替換爲方法 <code>deref</code> 的呼叫再進行普通的解引用，所以我們不必煩惱何時該或不該呼叫 <code>deref</code> 方法。此 Rust 特性讓我們可以對無論是引用或是有實作 <code>Deref</code> 的型別都能寫出一致的程式碼。</p>
<p><code>deref</code> 方法會回傳一個數值引用，以及括號外要再加上普通解引用的原因，都是因爲所有權系統。如果 <code>deref</code> 方法直接回傳數值而非引用數值的話，該數值就會移出 <code>self</code>。我們不希望在此例或是大多數使用解引用運算子的場合下，取走 <code>MyBox&lt;T&gt;</code> 內部數值的所有權。</p>
<p>注意到每次我們在程式碼中使用 <code>*</code> 時，<code>*</code> 運算子被替換成 <code>deref</code> 方法呼叫，然後再呼叫 <code>*</code> 剛好一次。因爲 <code>*</code> 運算子不會被無限遞迴替換，我們能剛好取得型別 <code>i32</code> 並符合範例 15-9 <code>assert_eq!</code> 中與 <code>5</code> 的判定。</p>
<h3><a class="header" href="#函式與方法的隱式強制解引用" id="函式與方法的隱式強制解引用">函式與方法的隱式強制解引用</a></h3>
<p>*強制解引用（Deref coercion）*是一個 Rust 針對函式或方法的引數的便利設計。強制解引用只適用於有實作 <code>Deref</code> 特徵的型別。強制解引用會將一個型別轉換成另一個型別的引用。舉例來說，強制解引用可以轉換 <code>&amp;String</code> 成 <code>&amp;str</code>，因爲 <code>String</code> 有實作 <code>Deref</code> 特徵並能用它來回傳 <code>str</code>。當我們將某個特定型別數值的引用作爲引數傳入一個函式或方法，但該函式或方法所定義的參數卻不相符時，強制解引用就會自動發生，並進行一系列的 <code>deref</code> 方法呼叫，將我們提供的型別轉換成參數所需的型別。</p>
<p>Rust 會加入強制解引用的原因是因爲程式設計師在寫函式與方法呼叫時，就不必加上許多顯式引用 <code>&amp;</code> 與解引用 <code>*</code>。強制解引用還讓我們可以寫出能同時用於引用或智慧指標的程式碼。</p>
<p>爲了展示強制解引用，讓我們使用範例 15-8 定義的 <code>MyBox&lt;T&gt;</code> 型別以及範例 15-10 所加上的 <code>Deref</code> 實作。範例 15-11 有個函式定義且有個字串 slice 作爲參數：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 15-11：<code>hello</code> 函式且有參數 <code>name</code> 其型別爲 <code>&amp;str</code></span></p>
<p>我們可以使用字串 slice 作爲引數來呼叫函式 <code>hello</code>，比方說 <code>hello(&quot;Rust&quot;);</code>。強制解引用讓我們可以透過 <code>MyBox&lt;String&gt;</code> 型別數值的引用來呼叫 <code>hello</code>，如範例 15-12 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">範例 15-12：利用強制解引用透過 <code>MyBox&lt;String&gt;</code> 數值的引用來呼叫 <code>hello</code></span></p>
<p>我們在此使用 <code>&amp;m</code> 作爲引數來呼叫函式 <code>hello</code>，這是 <code>MyBox&lt;String&gt;</code> 數值的引用。因爲我們在範例 15-10 有對 <code>MyBox&lt;T&gt;</code> 實作 <code>Deref</code> 特徵，Rust 可以呼叫 <code>deref</code> 將 <code>&amp;MyBox&lt;String&gt;</code> 變成 <code>&amp;String</code>。標準函式庫對 <code>String</code> 也有實作 <code>Deref</code> 並會回傳字串 slice，這可以在 <code>Deref</code> 的 API 技術文件中看到。所以 Rust 會在呼叫 <code>deref</code> 一次來將 <code>&amp;String</code> 變成 <code>&amp;str</code>，這樣就符合函式 <code>hello</code> 的定義了。</p>
<p>如果 Rust 沒有實作強制解引用的話，我們就得用範例 15-13 的方式才能辦到範例 15-12 使用型別 <code>&amp;MyBox&lt;String&gt;</code> 的數值來呼叫 <code>hello</code> 的動作。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">範例 15-13：如果 Rust 沒有強制解引用，我們就得這樣寫程式碼</span></p>
<p><code>(*m)</code> 會將 <code>MyBox&lt;String&gt;</code> 解引用成 <code>String</code>，然後 <code>&amp;</code> 和 <code>[..]</code> 會從 <code>String</code> 中取得等於整個字串的字串 slice，這就符合 <code>hello</code> 的簽名。沒有強制解引用的程式碼就難以閱讀、寫入或是理解，因爲有太多的符號參雜其中。強制解引用能讓 Rust 自動幫我們做這些轉換。</p>
<p>當某型別有定義 <code>Deref</code> 特徵時，Rust 會分析該型別並重複使用 <code>Deref::deref</code> 直到能取得與參數型別相符的引用。<code>Deref::deref</code> 需要呼叫的次數會在編譯時期插入，所以使用強制解引用沒有任何的執行時開銷！</p>
<h3><a class="header" href="#強制解引用如何處理可變性" id="強制解引用如何處理可變性">強制解引用如何處理可變性</a></h3>
<p>類似於你如何使用 the <code>Deref</code> 特徵來覆蓋不可變引用的 <code>*</code> 運算子，你也可以使用 <code>DerefMut</code> 特徵來覆蓋可變引用的 <code>*</code> 運算子。</p>
<p>當 Rust 發現型別與特徵實作符合以下三種情況時，它就會進行強制解引用：</p>
<ul>
<li>從 <code>&amp;T</code> 到 <code>&amp;U</code> 且 <code>T: Deref&lt;Target=U&gt;</code></li>
<li>從 <code>&amp;mut T</code> 到 <code>&amp;mut U</code> 且 <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>從 <code>&amp;mut T</code> 到 <code>&amp;U</code> 且 <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>前兩個除了可變性之外是相同的。第一個情況表示如果你有個 <code>&amp;T</code> 且 <code>T</code> 有實作 <code>Deref</code> 到某個型別 <code>U</code>，你就可以直接得到 <code>&amp;U</code>。第二種情況指的的則是對可變引用的強制解引用。</p>
<p>第三種情況比較棘手：Rust 也能強制將可變引用轉爲一個不可變引用。但反過來是<em>不可行</em>的：不可變引用永遠不可能強制解引用成可變引用。由於借用規則，如果你有個可變引用，該可變引用必須是該資料的唯一引用（不然程式無法編譯）。轉換可變引用成不可變引用不會破壞借用規則。轉換不可變引用成可變引用的話，就需要此不可變引用是該資料的唯一引用，但借用規則無法做擔保。因此 Rust 無法將不可變引用轉換成可變引用。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch15-02-deref.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#透過-drop-特徵執行清除程式碼" id="透過-drop-特徵執行清除程式碼">透過 <code>Drop</code> 特徵執行清除程式碼</a></h2>
<p>第二個對智慧指標模式很重要的特徵是 <code>Drop</code>，這讓你能自訂數值離開作用域時的行爲。你可以對任何型別實作 <code>Drop</code> 特徵，然後你指定的程式碼就能用來釋放像是檔案或網路連線等資源。我們在智慧指標的章節介紹 <code>Drop</code> 的原因是因爲 <code>Drop</code> 特徵的功能幾乎永遠會在實作智慧指標時用到。舉例來說，當 <code>Box&lt;T&gt;</code> 離開作用域時，它會釋放該 box 在堆積上指向的記憶體空間。</p>
<p>在某些語言中，當程式設計師使用完智慧指標的實例後，每次都得呼叫釋放記憶體與資源的程式碼。如果他們忘記的話，系統可能就會過載並崩潰。在 Rust 中你可以對數值離開作用域時指定一些程式碼，然後編譯器就會自動插入此程式碼。所以你就不用每次在特定型別實例使用完時，在程式的每個地方都寫上清理程式碼。而且你還不會泄漏資源！</p>
<p>透過實作 <code>Drop</code> 特徵我們可以指定當數值離開作用域時要執行的程式碼。<code>Drop</code> 特徵會要求我們實作一個方法叫做 <code>drop</code>，這會取得 <code>self</code> 的可變引用。爲了觀察 Rust 何時會呼叫 <code>drop</code>，讓我們先用 <code>println!</code> 陳述式實作 <code>drop</code>。</p>
<p>範例 15-14 的結構體 <code>CustomSmartPointer</code> 只有一個功能那就是在實例離開作用域時印出 <code>Dropping CustomSmartPointer!</code>。此範例能夠展示 Rust 何時會執行 <code>drop</code> 函式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;my stuff&quot;),
    };
    let d = CustomSmartPointer {
        data: String::from(&quot;other stuff&quot;),
    };
    println!(&quot;CustomSmartPointers created.&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 15-14：<code>CustomSmartPointer</code> 結構體實作了會放置清理程式碼的 <code>Drop</code> 特徵</span></p>
<p><code>Drop</code> 特徵包含在 prelude 中，所以我們不需要特地引入作用域。我們對 <code>CustomSmartPointer</code> 實作 <code>Drop</code> 特徵並提供會呼叫 <code>println!</code> 的 <code>drop</code> 方法實作。<code>drop</code> 的函式本體用來放置你想要在型別實例離開作用域時執行的邏輯。我們在此印出一些文字來展示 Rust 如何呼叫 <code>drop</code>。</p>
<p>在 <code>main</code> 中，我們建立了兩個 <code>CustomSmartPointer</code> 實例並印出 <code>CustomSmartPointers created</code>。在 <code>main</code> 結尾，我們的 <code>CustomSmartPointer</code> 實例會離開作用域，然後 Rust 就會呼叫我們放在 <code>drop</code> 方法的程式碼，也就是印出我們的最終訊息。注意到我們不需要顯式呼叫 <code>drop</code> 方法。</p>
<p>當我們執行此程式時，我們會看到以下輸出：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
     Running `target/debug/drop-example`
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>當我們的實例離開作用域時，Rust 會自動呼叫 <code>drop</code>，呼叫我們指定的程式碼。變數會以與建立時相反的順序被釋放，所以 <code>d</code> 會在 <code>c</code> 之前被釋放。此範例給了我們一個觀察 <code>drop</code> 如何執行的視覺化指引，通常你會指定該型別所須得清除程式碼，而不是印出訊息。</p>
<h3><a class="header" href="#透過-stdmemdrop-提早釋放數值" id="透過-stdmemdrop-提早釋放數值">透過 <code>std::mem::drop</code> 提早釋放數值</a></h3>
<p>不幸的是，我們無法值接了當地取消自動 <code>drop</code> 的功能。停用 <code>drop</code> 通常是不必要的整個 <code>Drop</code> 的目的本來就是要能自動處理。不過有些時候你可能會想要提早清除數值。其中一個例子是使用智慧指標來管理鎖：你可能會想要強制呼叫 <code>drop</code> 方法來釋放鎖，好讓作用域中的其他程式碼可以取得該鎖。Rust 不會讓你手動呼叫 <code>Drop</code> 特徵的 <code>drop</code> 方法。不過如果你想要一個數值在離開作用域前就被釋放的話，你可以使用標準函式庫提供的 <code>std::mem::drop</code> 函式來呼叫。</p>
<p>如果我們嘗試修改範例 15-14 的 <code>main</code> 函式來手動呼叫 <code>Drop</code> 特徵的 <code>drop</code> 方法，如範例 15-15 所示，我們會得到編譯錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<p><span class="caption">範例 15-15：嘗試呼叫 <code>Drop</code> 特徵的 <code>drop</code> 方法來手動提早清除</span></p>
<p>當我們嘗試編譯此程式碼，我們會獲得以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:16:7
   |
16 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed

error: aborting due to previous error

For more information about this error, try `rustc --explain E0040`.
error: could not compile `drop-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>此錯誤訊息表示我們不允許顯式呼叫 <code>drop</code>。錯誤訊息使用了一個術語<em>解構子（destructor）</em>，這是通用程式設計術語中表達會清除實例的函式。<em>解構子</em>對應的術語就是<em>建構子（constructor）</em>，這會建立實例。Rust 中的 <code>drop</code> 函式就是一種特定的解構子。</p>
<p>Rust 不讓我們顯式呼叫 <code>drop</code>，因爲 Rust 還是會在 <code>main</code> 結束時自動呼叫 <code>drop</code>。這樣可能會導致*重複釋放（double free）*的錯誤，因爲 Rust 可能會嘗試清除相同的數值兩次。</p>
<p>當數值離開作用域時我們無法停用自動插入的 <code>drop</code>，而且我們無法顯式呼叫 <code>drop</code> 方法，所以如果我必須強制讓一個數值提早清除的話，我們可以用 <code>std::mem::drop</code> 函式。</p>
<p><code>std::mem::drop</code> 函式不同於 <code>Drop</code> 中的 <code>drop</code> 方法，我們將我們想要強制提早釋放的數值作爲引數傳遞並呼叫它。此函式也包含在 prelude，所以我們可以修改範例 15-15 的 <code>main</code> 來呼叫 <code>drop</code> 函式，如範例 15-16 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer {
        data: String::from(&quot;some data&quot;),
    };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<p><span class="caption">範例 15-16：在數值離開作用域前呼叫 <code>std::mem::drop</code> 來顯示釋放數值</span></p>
<p>執行此程式會印出以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling drop-example v0.1.0 (file:///projects/drop-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/drop-example`
CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p><code>Dropping CustomSmartPointer with data `some data`!</code> 這段文字會在 <code>CustomSmartPointer created.</code> 與 <code>CustomSmartPointer dropped before the end of main.</code> 文字之間印出，顯示  <code>drop</code> 方法會在那時釋放 <code>c</code>。</p>
<p>你可以在許多地方使用 <code>Drop</code> 特徵實作所指定的程式碼，讓清除實例變得方便又安全。舉例來說，你可以用它來建立你自己的記憶體分配器！透過 <code>Drop</code> 特徵與 Rust 的所有權系統，你不必去擔心要既得清理，因爲 Rust 會自動處理。</p>
<p>你也不必擔心會意外清理仍在使用的數值：所有權系統會確保所有引用永遠有效，並確保當數值不再需要使用時只會呼叫 <code>drop</code> 一次。</p>
<p>現在你看過 <code>Box&lt;T&gt;</code> 以及一些智慧指標的特性了，讓我們來看看一些其他定義在標準函式庫的智慧指標吧。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch15-03-drop.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#rct-引用計數智慧指標" id="rct-引用計數智慧指標"><code>Rc&lt;T&gt;</code> 引用計數智慧指標</a></h2>
<p>在大多數的場合，所有權是很明確的：你能確切知道哪些變數擁有哪些數值。然而還是有些情況會需要讓一個數值能有數個擁有者。舉例來說，在資料結構中數個邊可能就會指向同個節點，而該節點概念上就被所有指向它的邊所擁有。節點直到沒有任何邊指向它時才會被清除。</p>
<p>要有多重所有權的話，Rust 有一個型別叫做 <code>Rc&lt;T&gt;</code>，這是*引用計數（reference counting）*的簡寫。<code>Rc&lt;T&gt;</code> 型別會追蹤引用其數值的數量來決定該數值是否還在使用中。如果數值沒有任何引用的話，該數值就可以被清除，因爲不會產生任何無效引用。</p>
<p>想像 <code>Rc&lt;T&gt;</code> 是個在客廳裡的電視，當有人進入客廳要看電視時，它們就會打開它。其他人也能進來觀看電視。當最後一個人離開客廳時，它們會關掉電視，因爲沒有任何人會再看了。如果當其他人還在看電視時，有人關掉了它，其他在看電視的人肯定會生氣。</p>
<p><code>Rc&lt;T&gt;</code> 型別的使用時機在於當我們想要在堆積上分配一些資料給程式中數個部分讀取，但是我們無法在編譯時期決定哪個部分會最後一個結束使用數值的部分。如果我們知道哪個部分會最後結束的話，我們可以將那個部分作爲資料的擁有者就好，然後正常的所有權規則就會在編譯時生效。</p>
<p>注意到 <code>Rc&lt;T&gt;</code> 只適用於單一執行緒（single-threaded）的場合。當我們在第十六章討論並行（concurrency）時，我們會介紹如何在多執行緒程式達成引用計數。</p>
<h3><a class="header" href="#使用-rct-來分享資料" id="使用-rct-來分享資料">使用 <code>Rc&lt;T&gt;</code> 來分享資料</a></h3>
<p>讓我們回顧範例 15-5 的 cons list 範例。回想一下我們當時適用 <code>Box&lt;T&gt;</code> 定義。這次我們會建立兩個列表，它們會同時共享第三個列表的所有權。概念上會如圖示 15-3 所示：</p>
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
<p><span class="caption">圖示 15-3：兩個列表 <code>b</code> 和 <code>c</code> 共享第三個列表 <code>a</code> 的所有權</span></p>
<p>我們會建立列表 <code>a</code> 來包含 5 然後是 10。然後我們會在建立兩個列表：<code>b</code> 以 3 爲開頭而 <code>c</code> 以 4 爲開頭。<code>b</code> 與 <code>c</code> 列表會同時連接包含 5 與 10 的第一個列表 <code>a</code>。換句話說，兩個列表會同時共享包含 5 與 10 的第一個列表。</p>
<p>嘗試使用 <code>Box&lt;T&gt;</code> 來定義這種情境的 <code>List</code> 的話會無法成功，如範例 15-17 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">範例 15-17：展示我們無法用 <code>Box&lt;T&gt;</code> 讓兩個列表嘗試共享第三個列表的所有權</span></p>
<p>當我們編譯此程式碼，我們會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:11:30
   |
9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait
10 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
11 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `cons-list`.

To learn more, run the command again with --verbose.
</code></pre>
<p><code>Cons</code> 變體擁有它們存有的資料，所以當我們建立列表 <code>b</code> 時，<code>a</code> 會移動到 <code>b</code>，所以 <code>b</code> 就擁有 <code>a</code>。然後當我們嘗試再次使用 <code>a</code> 來建立 <code>c</code> 時，這就不會被允許，因爲 <code>a</code> 已經被移走了。</p>
<p>我們可以嘗試改用引用來變更 <code>Cons</code> 的定義，但是這樣我們就必須指定生命週期參數。透過指定生命週期參數，我們會指定列表中的每個元素會至少活得跟整個列表一樣久。舉例來說，這樣借用檢查器就不會讓我們編譯過 <code>let a = Cons(10, &amp;Nil);</code>，因爲暫時的數值 <code>Nil</code> 會在 <code>a</code> 取得引用之前就被釋放。</p>
<p>我們最後可以改用 <code>Rc&lt;T&gt;</code> 來變更 <code>List</code> 的定義，如範例 15-18 所示。每個 <code>Cons</code> 變體都會存有一個數值以及一個由 <code>Rc&lt;T&gt;</code> 指向的 <code>List</code>。當我們建立 <code>b</code> 時，不會取走 <code>a</code> 的所有權，我們會克隆（clone） <code>a</code> 存有的 <code>Rc&lt;List&gt;</code>，因而增加引用的數量從一增加到二，並讓 <code>a</code> 與 <code>b</code> 共享 <code>Rc&lt;List&gt;</code> 資料的所有權。我們也在在建立 <code>c</code> 時克隆 <code>a</code>，增加引用的數量從二增加到三。每次我們呼叫 <code>Rc::clone</code> 時，對 <code>Rc&lt;List&gt;</code> 資料的引用計數就會成增加，然後資料不會被清除直到沒有任何引用爲止。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">範例 15-18：使用 <code>Rc&lt;T&gt;</code> 來定義 <code>List</code></span></p>
<p>我們需要使用 <code>use</code> 陳述式來將 <code>Rc&lt;T&gt;</code> 引入作用域，因爲它沒有被包含在 prelude 中。在 <code>main</code> 中，我們建立了一個包含 5 與 10 的列表並存入 <code>a</code> 的 <code>Rc&lt;List&gt;</code>。然後當我們建立 <code>b</code> 與 <code>c</code> 時，我們會呼叫函式 <code>Rc::clone</code> 來將 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 引用作爲引數傳入。</p>
<p>當然我們可以呼叫 <code>a.clone()</code> 而非 <code>Rc::clone(&amp;a)</code>，但是在此情形中 Rust 的慣例是使用 <code>Rc::clone</code>。<code>Rc::clone</code> 的實作不會像大多數型別的 <code>clone</code> 實作會深拷貝（deep copy）所有的資料。 <code>Rc::clone</code> 的呼叫只會增加引用計數，這花費的時間就相對很少。深拷貝通常會花費比較多的時間。透過使用 <code>Rc::clone</code> 來引用計數，我們可以以視覺辨別出這是深拷貝的克隆還是增加引用計數的克隆。當我們需要調查程式碼的效能問題時，我們就只需要考慮深拷貝的克隆，而不必在意 <code>Rc::clone</code>。</p>
<h3><a class="header" href="#cloning-an-rct-increases-the-reference-count" id="cloning-an-rct-increases-the-reference-count">Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</a></h3>
<p>讓我們改變範例 15-18 的範例，好讓我們能觀察引用計數在我們建立與釋放 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 引用時產生的變化。</p>
<p>範例 15-19，我們改變了 <code>main</code> 讓列表 <code>c</code> 寫在一個內部作用域中，然後我們就能觀察到當 <code>c</code> 離開作用域時引用計數產生的改變。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">範例 15-19：印出引用計數</span></p>
<p>在程式中每次引用計數產生改變的地方，我們就印出引用計數，我們可以透過呼叫函式 <code>Rc::strong_count</code> 來取得。此函式叫做 <code>strong_count</code> 而非 <code>count</code> 是因爲 <code>Rc&lt;T&gt;</code> 型別還有個 <code>weak_count</code>，我們會在 <a href="ch15-06-reference-cycles.html#%E9%81%BF%E5%85%8D%E5%BC%95%E7%94%A8%E5%BE%AA%E7%92%B0%E5%B0%87-rct-%E8%BD%89%E6%8F%9B%E6%88%90-weakt">「避免引用循環：將 <code>Rc&lt;T&gt;</code> 轉換成 <code>Weak&lt;T&gt;</code>」</a><!-- ignore --> 段落看到 <code>weak_count</code> 的使用方式。</p>
<p>此程式碼印出以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.45s
     Running `target/debug/cons-list`
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>我們可以看到 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 會有個初始引用計數 1，然後我們每次呼叫 <code>clone</code> 時，計數會加 1。當 <code>c</code> 離開作用域時，計數會減 1。我們不必呼叫任何函式來減少引用計數，像呼叫 <code>Rc::clone</code> 時才會增加引用計數那樣。當 <code>Rc&lt;T&gt;</code> 數值離開作用域時，<code>Drop</code> 特徵的實作就會自動減少引用計數。</p>
<p>我們無法從此例觀察到的是當 <code>b</code> 然後是 <code>a</code> 從 <code>main</code> 的結尾離開作用域時，計數會是 0，然後 <code>Rc&lt;List&gt;</code> 在此時就會完全被清除。使用 <code>Rc&lt;T&gt;</code> 能允許單一數值能有數個擁有者，然後計數會確保只要有任何擁有者還存在的狀況下，數值會保持是有效的。</p>
<p>透過不可變引用，<code>Rc&lt;T&gt;</code> 能讓你分享資料給程式中數個部分來只做讀取的動作。如果 <code>Rc&lt;T&gt;</code> 允許你也擁有數個可變引用的話，你可能就違反了第四章提及的借用規則：數個對相同位置的可變借用會導致資料競爭（data races）與不一致。但可變資料還是非常實用的！在下個段落，我們會討論內部可變性模式與 <code>RefCell&lt;T&gt;</code> 型別，此型別能讓你搭配 <code>Rc&lt;T&gt;</code> 使用來處理不可變的限制。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch15-04-rc.md">e5ed971</a></li>
<li>updated: 2020-09-19</li>
</ul>
</blockquote>
<h2><a class="header" href="#refcellt-與內部可變性模式" id="refcellt-與內部可變性模式"><code>RefCell&lt;T&gt;</code> 與內部可變性模式</a></h2>
<p>*內部可變性（Interior mutability）*是 Rust 中的一種設計模式，能讓你能對即使是不可變引用的資料也能改變。正常狀況下，借用規則是不允許這種動作的。爲了改變資料，這樣的模式會在資料結構內使用 <code>unsafe</code> 程式碼來繞過 Rust 的常見可變性與借用規則。我們尚未介紹什麼是不安全（unsafe）的程式碼，我們會在第十九章談到。當編譯器無法保障，但我們可以確保借用規則在執行時能夠遵循的話，我們就可以使用擁有內部可變性模式的型別。其內的 <code>unsafe</code> 程式碼會透過安全的 API 封裝起來，讓外部型別仍然是不可變的。</p>
<p>讓我們觀察擁有內部可變性模式的 <code>RefCell&lt;T&gt;</code> 型別來探討此概念。</p>
<h3><a class="header" href="#透過-refcellt-在執行時強制檢測借用規則" id="透過-refcellt-在執行時強制檢測借用規則">透過 <code>RefCell&lt;T&gt;</code> 在執行時強制檢測借用規則</a></h3>
<p>不像 <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 型別的資料只會有一個所有權。所以 <code>RefCell&lt;T&gt;</code> 與 <code>Box&lt;T&gt;</code> 這種型別有何差別呢？回憶一下你在第四章學到的借用規則：</p>
<ul>
<li>在任何時候，我們要麼<em>只能有</em>一個可變引用，要麼可以有<em>任意數量</em>的不可變引用。</li>
<li>引用必須永遠有效。</li>
</ul>
<p>對於引用與 <code>Box&lt;T&gt;</code>，借用規則會在編譯期強制檢測。對於 <code>RefCell&lt;T&gt;</code>，這些規則會在<em>執行時</em>才強制執行。對於引用來說，如果你打破這些規則，你會得到編譯錯誤。而對 <code>RefCell&lt;T&gt;</code> 來說，如果你打破這些規則，你的程式會恐慌並離開。</p>
<p>在編譯時期檢查借用規則的優勢在於錯誤能在開發過程及早獲取，而且這對執行時的效能沒有任何影響，因爲所有的分析都預先完成了。基於這些原因，在編譯時檢查借用規則在大多數情形都是最佳選擇，這也是爲何這是 Rust 預設設置的原因。</p>
<p>在執行時檢查借用規則的優勢則在於能允許一些特定記憶體安全的場合，而這些原本是不被編譯時檢查所允許的。像 Rust 編譯器這種靜態分析本質上是保守的。有些程式碼特性是無法透過分析程式碼檢測出的，最註明的範例就是停機問題（Halting Problem），這超出本書的範疇，但是是個有趣的研究議題。</p>
<p>因爲有些分析是不可能的，如果 Rust 編譯器無法確定程式碼是否符合所有權規則，它可能會拒絕一支正確的程式，所以由此觀點來看能知道 Rust 編譯器是保守的。如果 Rust 接受不正確的程式，使用者就無法信任 Rust 帶來的保障。然而如果 Rust 拒絕正確的程式，對程式設計師就會很不方便，但沒有任何嚴重的災難會發生。<code>RefCell&lt;T&gt;</code> 型別就適用於當你確定你的程式碼有遵循借用規則，但是編譯器無法理解並保證的時候。</p>
<p>類似於 <code>Rc&lt;T&gt;</code>，<code>RefCell&lt;T&gt;</code> 也只能用於單一執行緒（single-threaded）的場合，所以如果你嘗試用在多執行緒上的話就會出現編譯時錯誤。我們會在第十六章討論如何在多執行緒程式擁有 <code>RefCell&lt;T&gt;</code> 的功能。</p>
<p>以下是何時選擇 <code>Box&lt;T&gt;</code>、<code>Rc&lt;T&gt;</code> 或 <code>RefCell&lt;T&gt;</code> 的理由:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> 讓數個擁有者能共享相同資料；<code>Box&lt;T&gt;</code> 與 <code>RefCell&lt;T&gt;</code> 只能有一個擁有者。</li>
<li><code>Box&lt;T&gt;</code> 能有不可變或可變的借用並在編譯時檢查；<code>Rc&lt;T&gt;</code> 則只能有不可變借用並在編譯時檢查：<code>RefCell&lt;T&gt;</code> 能有不可變或可變借用但是在執行時檢查。</li>
<li>由於 <code>RefCell&lt;T&gt;</code> 允許在執行時檢查可變引用，你可以改變 <code>RefCell&lt;T&gt;</code> 內部的數值，就算 <code>RefCell&lt;T&gt;</code> 是不可變的。</li>
</ul>
<p>改變不可變數值內部的值就<em>內部可變性</em>模式。讓我們看看內部可變性何時會有用，且觀察爲何是可行的。</p>
<h3><a class="header" href="#內部可變性不可變數值的可變借用" id="內部可變性不可變數值的可變借用">內部可變性：不可變數值的可變借用</a></h3>
<p>借用規則的影響是當你有個不可變數值，你就無法取得可變引用。舉例來說，以下程式碼會無法編譯：</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>如果你嘗試編譯此程式碼，你會獲得以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
2 |     let x = 5;
  |         - help: consider changing this to be mutable: `mut x`
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing`.

To learn more, run the command again with --verbose.
</code></pre>
<p>然而在某些特定情況，我們會想要能夠有個方法可以改變一個數值，但該數值對其他程式碼而言仍然是不可變的。數值提供的方法以外的程式碼都無法改變其值。使用 <code>RefCell&lt;T&gt;</code> 是取得內部可變性的方式之一。但 <code>RefCell&lt;T&gt;</code> 仍然要完全遵守借用規則：編譯器的借用檢查器會允許這些內部可變性，然後在執行時才檢查借用規則。如果你違反規則，你就會得到 <code>panic!</code> 而非編譯錯誤。</p>
<p>讓我們用一個實際例子來探討如何使用 <code>RefCell&lt;T&gt;</code> 來改變不可變數值，並瞭解爲何這是很實用的。</p>
<h4><a class="header" href="#內部可變性的使用案例模擬物件" id="內部可變性的使用案例模擬物件">內部可變性的使用案例：模擬物件</a></h4>
<p>*測試替身（test double）*是一個通用程式設計概念，表示一個在測試中替代某種型別的型別。*模擬物件（Mock objects）*是測試替身其中一種特定型別，這能紀錄測試過程中發生什麼事並讓你能判斷動作是否正確。</p>
<p>Rust 的物件與其他語言中的物件概念並不全然相同，而且 Rust 的標準函式庫內也沒有如其他語言會內建的模擬物件功能。不過你還是可以有方法來建立結構體來作爲模擬物件。</p>
<p>以下是我們要測試的情境：我們建立一個函式庫來追蹤一個數值與最大值的差距，並依據該差距傳送訊息。舉例來說，此函式庫就能用來追蹤使用者允許呼叫 API 次數的上限。</p>
<p>我們的函式庫提供的功能這只有追蹤與最大值的距離以及何時該傳送什麼訊息。使用函式庫的應用程式要提供傳送訊息的機制，應用程式可以將訊息存在應用程式內、傳送電子郵件、傳送文字訊息或其他等等。函式庫不需要知道細節，它只需要在意會有項目實作我們提供的 <code>Messenger</code> 特徵。範例 15-20 顯示了函式庫的程式碼：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 15-20：追蹤某個值與最大值差距的函式庫並以此值的特定層級傳送警告</span></p>
<p>此程式碼其中一個重點是 <code>Messenger</code> 特徵有個方法叫做 <code>send</code>，這會接收一個 <code>self</code> 的不可變引用與一串訊息文字。這就是我們的模擬物件所需的介面。另一個重點是我們想要測試 <code>LimitTracker</code> 中 <code>set_value</code> 方法的行爲。我們可以改變傳給參數 <code>value</code> 的值，但是 <code>set_value</code> 沒有回傳任何東西好讓我們做判斷。我們希望如果我們透過某個實作 <code>Messenger</code> 的型別與特定數值 <code>max</code> 來建立 <code>LimitTracker</code> 時，傳送訊息者能被通知要傳遞合適的訊息。</p>
<p>我們需要有個模擬物件，而不是在呼叫 <code>send</code> 時真的傳送電子郵件或文字訊息，我們只想紀錄訊息被通知要傳送了。我們可以建立模擬物件的實例，以此建立 <code>LimitTracker</code>、呼叫 <code>LimitTracker</code> 的 <code>set_value</code>，並檢查模擬物件有我們預期的訊息。範例 15-21 展示一個嘗試實作此事的模擬物件，但借用檢查器卻不允許：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
</code></pre>
<p><span class="caption">範例 15-21：嘗試實作 <code>MockMessenger</code> 但借用檢查器不允許</span></p>
<p>此測試程式碼定義了一個結構體 <code>MockMessenger</code> 其有個 <code>sent_messages</code> 欄位並存有 <code>String</code> 數值的 <code>Vec</code> 來追蹤被通知要傳送的訊息。我們也定義了一個關聯函式 <code>new</code> 讓我們可以方便建立起始訊息列表爲空的 <code>MockMessenger</code>。我們對 <code>MockMessenger</code> 實作 <code>Messenger</code> 特徵，這樣我們才能將 <code>MockMessenger</code> 交給 <code>LimitTracker</code>。在 <code>send</code> 方法的定義中，我們取得由參數傳遞的訊息，並存入 <code>MockMessenger</code> 的 <code>sent_messages</code> 列表中。</p>
<p>在測試中，我們測試當 <code>LimitTracker</code> 被通知將 <code>value</code> 設爲超過 <code>max</code> 數值 75% 的某個值。首先，我們建立新的 <code>MockMessenger</code>，其起始爲一個空的訊息列表。然後我們建立一個新的 <code>LimitTracker</code> 並將 <code>MockMessenger</code> 的引用與一個 <code>max</code> 爲 100 的數值賦值給它。我們用數值 80 來呼叫 <code>LimitTracker</code> 的 <code>set_value</code> 方法，此值會超過 100 的 75%。然後我們判定 <code>MockMessenger</code> 追蹤的訊息列表需要至守有一個訊息。</p>
<p>但是此測試有個問題，如以下所示：</p>
<pre><code class="language-text">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
57 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- help: consider changing this to be a mutable reference: `&amp;mut self`
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker`.

To learn more, run the command again with --verbose.
</code></pre>
<p>我們無法修改 <code>MockMessenger</code> 來追蹤訊息，因爲 <code>send</code> 方法取得的是 <code>self</code> 的不可變引用。而我們也無法使用錯誤訊息中推薦使用的 <code>&amp;mut self</code>，因爲 <code>send</code> 的簽名就會與 <code>Messenger</code> 特徵所定義的不相符（你可以是看看並觀察錯誤訊息）。</p>
<p>這就是內部可變性能帶來幫助的場合！我們會將 <code>sent_messages</code> 存入 <code>RefCell&lt;T&gt;</code> 內，然後 <code>send</code> 訊息就也能夠進行修改存入訊息。範例 15-22 顯示了變更後的程式碼：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 15-22：在外部數值爲不可變時，使用 <code>RefCell&lt;T&gt;</code> 來改變內部數值</span></p>
<p><code>sent_messages</code> 欄位現在是型別 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 而非 <code>Vec&lt;String&gt;</code>。在 <code>new</code> 函式中，我們用空的 vector 來建立新的 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>。</p>
<p>至於 <code>send</code> 方法的實作，第一個參數仍然是 <code>self</code> 的不可變借用，這就符合特徵所定義的。我們在 <code>self.sent_messages</code> 對 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 呼叫 <code>borrow_mut</code> 來取得 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 內的可變引用數值，也就是 vector。然後我們對 vector 的可變引用呼叫 <code>push</code> 來追蹤測試中的訊息。</p>
<p>最後一項改變是判定：要看到內部 vector 有多少項目的話，我們對 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 呼叫 <code>borrow</code> 來取得 vector 的不可變引用。</p>
<p>現在你已經知道如何使用 <code>RefCell&lt;T&gt;</code>，讓我們進一步探討它如何運作的吧！</p>
<h4><a class="header" href="#keeping-track-of-borrows-at-runtime-with-refcellt" id="keeping-track-of-borrows-at-runtime-with-refcellt">Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></a></h4>
<p>當建立不可變與可變引用時，我們分別使用 <code>&amp;</code> 和 <code>&amp;mut</code> 語法。而對於 <code>RefCell&lt;T&gt;</code> 的話，我們使用 <code>borrow</code> 和 <code>borrow_mut</code> 方法，這是 <code>RefCell&lt;T&gt;</code> 所提供的安全 API 之一。<code>borrow</code> 方法回傳一個智慧指標型別 <code>Ref&lt;T&gt;</code>，而 <code>borrow_mut</code> 回傳智慧指標型別 <code>RefMut&lt;T&gt;</code>。這兩個型別都有實作 <code>Deref</code>，所以我們可以像一般引用來對待它們。</p>
<p><code>RefCell&lt;T&gt;</code> 會追蹤當前有多少 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code> 智慧指標存在。每次我們呼叫 <code>borrow</code> 時，<code>RefCell&lt;T&gt;</code> 會增加不可變借用計數。當 <code>Ref&lt;T&gt;</code> 離開作用域時，不可變借用計數就會減一。就和編譯時借用規則一樣，<code>RefCell&lt;T&gt;</code> 讓我們同一時間要麼只能有一個可變引用，要麼可以有數個不可變引用。</p>
<p>如果我們嘗試違法這些規則，我們不會像引用那樣得到編譯器錯誤，<code>RefCell&lt;T&gt;</code> 的實作會在執行時恐慌。 範例 15-23 修改了範例 15-22 的 <code>send</code> 實作。我們故意嘗試在同個作用域下建立兩個可變引用，來說明 <code>RefCell&lt;T&gt;</code> 會不允許我們在執行時這樣做。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 15-23：在同個作用域建立兩個可變引用並觀察到 <code>RefCell&lt;T&gt;</code> 會恐慌</span></p>
<p>我們從 <code>borrow_mut</code> 回傳的 <code>RefMut&lt;T&gt;</code> 智慧指標來建立變數 <code>one_borrow</code>。然後我們再以相同方式建立另一個變數 <code>two_borrow</code>。這在同個作用域下產生了兩個可變引用，而這是不允許的。我們執行函式庫的測試時，範例 15-23 可以編譯通過，但是執行測試會失敗：</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/limit_tracker-d1b2637139dca6ca

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'main' panicked at 'already borrowed: BorrowMutError', src/libcore/result.rs:1188:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>注意到程式碼恐慌時的訊息 <code>already borrowed: BorrowMutError</code>。這就是 <code>RefCell&lt;T&gt;</code> 如何在執行時處理違反借用規則的情況。</p>
<p>在執行時獲取借用錯誤而不是在編譯時代表你會在開發過程之後才找到程式碼錯誤，並有可能一直到程式碼部署到生產環境後才查覺。而且你的程式碼也會多了一寫小小的執行時效能開銷，作爲在執行時而非編譯時檢查的代價。不過使用 <code>RefCell&lt;T&gt;</code>  讓你能在只允許有不可變數值的環境中寫出能夠變更內部追蹤訊息的模擬物件。這是想獲得 <code>RefCell&lt;T&gt;</code> 帶來的功能時，要與一般引用之間作出的取捨。</p>
<h3><a class="header" href="#組合-rct-與-refcellt-來擁有多個可變資料的擁有者" id="組合-rct-與-refcellt-來擁有多個可變資料的擁有者">組合 <code>Rc&lt;T&gt;</code> 與 <code>RefCell&lt;T&gt;</code> 來擁有多個可變資料的擁有者</a></h3>
<p><code>RefCell&lt;T&gt;</code> 的常見使用方法是搭配 <code>Rc&lt;T&gt;</code>。回想一下 <code>Rc&lt;T&gt;</code> 讓你可以對數個擁有者共享相同資料，但是它只能用於不可變資料。如果你有一個 <code>Rc&lt;T&gt;</code> 並存有 <code>RefCell&lt;T&gt;</code> 的話，你就可以取得一個有數個擁有者<em>而且</em>可變的數值！</p>
<p>舉例來說，回憶一下範例 15-18 cons list 的範例我們使用了 <code>Rc&lt;T&gt;</code> 來讓數個列表可以共享另一個列表的所有權。因爲 <code>Rc&lt;T&gt;</code> 只能有不可變數值，我們一旦建立它們後就無法變更列表中的任何數值。讓我們加上 <code>RefCell&lt;T&gt;</code> 來獲得能改變列表數值的能力吧。範例 15-24 顯示了在 <code>Cons</code> 定義中使用 <code>RefCell&lt;T&gt;</code>，這樣一來我們就可以變更儲存在列表中的所有數值：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">範例 15-24：使用 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 建立一個可變的 <code>List</code></span></p>
<p>我們建立了一個 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> 實例數值並將其存入變數 <code>value</code> 好像我們之後可以直接取得。然後我們在 <code>a</code> 用持有 <code>value</code> 的 <code>Cons</code> 變體來建立 <code>List</code>。我們需要克隆 <code>value</code>，這樣 <code>a</code> 和 <code>value</code> 才能都有內部數值 <code>5</code> 的所有權，而不是從 <code>value</code> 轉移所有權給 <code>a</code>，或是讓 <code>a</code> 借用 <code>value</code>。</p>
<p>我們用 <code>Rc&lt;T&gt;</code> 封裝列表 <code>a</code>，所以當我們建立列表 <code>b</code> 和 <code>c</code> 時，它們都可以引用 <code>a</code>，就像範例 15-18 一樣。</p>
<p>在我們建立完列表 <code>a</code>、<code>b</code> 和 <code>c</code> 之後，我們對 <code>value</code> 的數值加上 10。我們對 <code>value</code> 呼叫 <code>borrow_mut</code>，其中使用到了我們在第五章討論過的自動解引用功能（請查閱<a href="ch05-03-method-syntax.html#%E9%81%8B%E7%AE%97%E5%AD%90%E8%B7%91%E5%8E%BB%E5%93%AA%E4%BA%86">「<code>-&gt;</code> 運算子跑去哪了？」</a><!-- ignore -->的段落）來解引用 <code>Rc&lt;T&gt;</code> 成內部的 <code>RefCell&lt;T&gt;</code> 數值。<code>borrow_mut</code> 方法會回傳 <code>RefMut&lt;T&gt;</code> 智慧指標，而我們使用解引用運算子並改變其內部數值。</p>
<p>當我們印出 <code>a</code>、<code>b</code> 和 <code>c</code> 時，我們可以看到它們的數值都改成了 15 而非 5：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>此技巧是不是很厲害！透過使用 <code>RefCell&lt;T&gt;</code>，我們可以得到一個外部是不可變的 <code>List</code> 數值，但是我們可以使用 <code>RefCell&lt;T&gt;</code> 提供的方法來取得其內部可變性，讓我們可以在我們想要時改變我們的資料。執行時的借用規則檢查檢查能防止資料競爭，並在某些場合犧牲一點速度來換取資料結構的彈性。</p>
<p>標準函式庫也提供了其他具有內部可變性的型別。像是 <code>Cell&lt;T&gt;</code>，這類似 <code>RefCell&lt;T&gt;</code> 但不同於給予內部數值的引用，<code>Cell&lt;T&gt;</code> 的數值會被拷貝出去。還有 <code>Mutex&lt;T&gt;</code> 能提供跨執行緒安全的內部可變性，我們會在第十六章討論如何使用它。歡迎查閱標準函式庫的計數文件來瞭解這些型別之間的細節差異。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch15-05-interior-mutability.md">e5ed971</a></li>
<li>updated: 2020-09-20</li>
</ul>
</blockquote>
<h2><a class="header" href="#引用循環會導致記憶體泄漏" id="引用循環會導致記憶體泄漏">引用循環會導致記憶體泄漏</a></h2>
<p>Rust 的記憶體安全保障讓意外產生永遠不會清除的記憶體的情況（通稱爲<em>記憶體泄漏, memory leak</em>）難以發生，但這並不是絕對不可能。和在編譯期間不允許資料競爭的情況不同，Rust 並不保證能完全避免記憶體泄漏，代表記憶體泄漏 Rust 中被視爲是記憶體安全的。我們可以透過使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 觀察到 Rust 仍會產生記憶體泄漏，產生引用循環是有可能的，這會導致記憶體泄漏，因爲循環中的引用計數永遠不會變成 0，所以數值永遠不會被釋放。</p>
<h3><a class="header" href="#產生引用循環" id="產生引用循環">產生引用循環</a></h3>
<p>讓我們看看引用循環是怎麼發生的，以及如何避免它。我們從範例 15-25 的 <code>List</code> 枚舉定義與一個 <code>tail</code> 方法開始：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}

fn main() {}
</code></pre></pre>
<p><span class="caption">範例 15-25：一個 cons list 定義並持有 <code>RefCell&lt;T&gt;</code>，所以我們可以修改 <code>Cons</code> 變體引用的值</span></p>
<p>我們用的是範例 15-5 中 <code>List</code> 的另一種定義寫法。<code>Cons</code> 變體的第二個元素現在是 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>，代表不同於範例 15-24 那樣能修改 <code>i32</code> 數值，我們想要能修改 <code>Cons</code> 變體指向的 <code>List</code> 數值。我們也加了一個 <code>tail</code> 方法讓我們如果有 <code>Cons</code> 變體的話，能方便取得第二個項目。</p>
<p>在範例 15-26 我們要加入 <code>main</code> 函式並使用範例 15-25 的定義。此程式碼建立了列表 <code>a</code> 與指向列表 <code>a</code> 的列表 <code>b</code>。然後它修改了列表 <code>a</code> 來指向 <code>b</code>，因而產生循環引用。在程序過程中 <code>println!</code> 陳述式會顯示不同位置時的引用計數。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">範例 15-26：透過兩個彼此指向對方的 <code>List</code> 數值來產生引用循環</span></p>
<p>我們在變數 <code>a</code> 建立了一個 <code>Rc&lt;List&gt;</code> 實例的 <code>List</code> 數值並持有 <code>5, Nil</code> 初始列表的 。我們然後在變數  <code>b</code> 建立另一個 <code>Rc&lt;List&gt;</code> 實例的 <code>List</code> 數值並持有數值 10 與指向的列表 <code>a</code>。</p>
<p>我們將 <code>a</code> 修改爲指向 <code>b</code> 而非 <code>Nil</code> 來產生循環。我們透過使用 <code>tail</code> 方法來取得 <code>a</code> 的 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 引用，並放入變數 <code>link</code> 中。然後我們對 <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 使用 <code>borrow_mut</code> 方法來改變 <code>Rc&lt;List&gt;</code> 的值，從數值 <code>Nil</code> 改成 <code>b</code> 的 <code>Rc&lt;List&gt;</code>。</p>
<p>當我們執行此程式並維持將最後一行的 <code>println!</code> 註解掉的話，我們會得到以下輸出：</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>在我們變更列表 <code>a</code> 來指向 <code>b</code> 後，<code>a</code> 和 <code>b</code> 的 <code>Rc&lt;List&gt;</code> 實例引用計數都是 2。在 <code>main</code> 結束後，Rust 會先嘗試釋放 <code>b</code>，讓 <code>b</code> 的 <code>Rc&lt;List&gt;</code> 實例計數減一。</p>
<p>然而，因爲 <code>a</code> 仍然引用 <code>b</code> 的 <code>Rc&lt;List&gt;</code>，該 <code>Rc&lt;List&gt;</code> 的計數會是 1 而非 0，所以 <code>Rc&lt;List&gt;</code> 在堆積上的記憶體不會被釋放。記憶體會永遠維持在那並保持計數爲 1。爲了視覺化引用循環，我們用圖示 15-4 表示。</p>
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
<p><span class="caption">圖示 15-4：列表 <code>a</code> 與 <code>b</code> 彼此指向對方的引用循環</span></p>
<p>如果你解除最後一個 <code>println!</code> 的註解並執行程式的話，Rust 會嘗試印出此循環，因爲 <code>a</code> 會指向 <code>b</code> 會指向 <code>a</code> 以此循環下去，直到堆疊溢位（stack overflow）。</p>
<p>在此例中，當我們建立完循環引用，程式究詰數了。此循環造成的影響並不嚴重。不過要是有個更複雜的程式分配了大量的記憶體而產生循環，並維持很常一段時間的話，程式會用到比原本預期還多的記憶體，並可能壓垮系統，導致它將記憶體用光。</p>
<p>要產生循環引用並不是件容易的事，但也不是絕對不可能。如果你有包含 <code>Rc&lt;T&gt;</code> 數值的 <code>RefCell&lt;T&gt;</code> 數值，或是有類似具內部可變性與引用計數巢狀組合的話，你必須確保不會產生循環引用，你無法依靠 Rust 來檢查它們。產生循環引用是程式中的邏輯錯誤，你需要使用自動化測試、程式碼審查以及其他軟體開發技巧來最小化問題。</p>
<p>另一個避免引用循環的解決辦法是重新組織你的資料結構，確定哪些引用要有所有權，哪些引用不用。這樣一來，循環會由一些有所有權的關係與沒有所有權的關係所組成，而只有所有權關係能影響數值是否能被釋放。在範例 15-25 中。我們永遠會希望 <code>Cons</code> 變體擁有它們的列表，讓重新組織資料結構變得有可能。讓我們看看一個由父節點與子節點的圖形結構，來看看無所有權的關係何時適合用來避免循環引用。</p>
<h3><a class="header" href="#避免引用循環將-rct-轉換成-weakt" id="避免引用循環將-rct-轉換成-weakt">避免引用循環：將 <code>Rc&lt;T&gt;</code> 轉換成 <code>Weak&lt;T&gt;</code></a></h3>
<p>目前，我們解釋過呼叫 <code>Rc::clone</code> 會增加 <code>Rc&lt;T&gt;</code> 實例的 <code>strong_count</code>，而 <code>Rc&lt;T&gt;</code> 只會在 <code>strong_count</code> 爲 0 時被清除。你也可以對 <code>Rc&lt;T&gt;</code> 實例呼叫 <code>Rc::downgrade</code> 並傳入 <code>Rc&lt;T&gt;</code> 的引用來建立<em>弱引用（weak reference）</em>。當你呼叫 <code>Rc::downgrade</code> 時，你會得到一個型別爲 <code>Weak&lt;T&gt;</code> 的智慧指標。不同於對 <code>Rc&lt;T&gt;</code> 實例的 <code>strong_count</code> 增加 1，呼叫 <code>Rc::downgrade</code> 會對 <code>weak_count</code> 增加 1。<code>Rc&lt;T&gt;</code> 型別使用 <code>weak_count</code> 來追蹤有多少 <code>Weak&lt;T&gt;</code> 的引用存在，這類似於 <code>strong_count</code>。不同的地方在於 <code>weak_count</code> 不需要歸零才能將 <code>Rc&lt;T&gt;</code> 清除。</p>
<p>強引用是你分享 <code>Rc&lt;T&gt;</code> 實例的方式。弱引用不會表達所有權關係。它們不會造成引用循環，因爲弱引用的循環會在其強引用計數歸零時解除。</p>
<p>由於 <code>Weak&lt;T&gt;</code> 的引用數值可能會被釋放，要對 <code>Weak&lt;T&gt;</code> 指向的數值做任何事情時，你都必須確保該數值還存在。你可以透過對 <code>Weak&lt;T&gt;</code> 實例呼叫 <code>upgrade</code> 方法，這會回傳 <code>Option&lt;Rc&lt;T&gt;&gt;</code>。如果 <code>Rc&lt;T&gt;</code> 數值還沒被釋放的話，你就會得到 <code>Some</code>；而如果 <code>Rc&lt;T&gt;</code> 數值已經被釋放的話，就會得到 <code>None</code>。因爲 <code>upgrade</code> 回傳 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，Rust 會確保 <code>Some</code> 與 <code>None</code> 的分支都有處理好，所以不會取得無效指標。</p>
<p>爲了做示範，與其使用知道下一項的列表的例子，我們會建立一個樹狀結構，每一個項目會知道它們的子項目<em>以及</em>它們的父項目。</p>
<h4><a class="header" href="#建立樹狀資料結構帶有子節點的-node" id="建立樹狀資料結構帶有子節點的-node">建立樹狀資料結構：帶有子節點的 <code>Node</code></a></h4>
<p>首先我們建立一個帶有節點的樹，每個節點知道它們的子節點。我們會定義一個結構體 <code>Node</code> 來存有它自己的 <code>i32</code> 數值以及其子數值 <code>Node</code> 的引用：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">}
</span></code></pre></pre>
<p>我們想要 <code>Node</code> 擁有自己的子節點，而且我們想要透過變數分享所有權，讓我們可以在樹中取得每個 <code>Node</code>。爲此我們定義 <code>Vec&lt;T&gt;</code> 項目作爲型別 <code>Rc&lt;Node&gt;</code> 的數值。我們還想要能夠修改哪些節點才是該項目的子節點，所以我們將 <code>children</code> 中的 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> 加進 <code>RefCell&lt;T&gt;</code>。</p>
<p>接著，我們使用我們定義的結構體來建立一個 <code>Node</code> 實例叫做 <code>leaf</code>，其數值爲 3 且沒有子節點；我們再建立另一個實例叫做 <code>branch</code>，其數值爲 5 且有個子節點 <code>leaf</code>。如範例 15-27 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">範例 15-27：建立一個沒有子節點的 <code>leaf</code> 節點與一個有 <code>leaf</code> 作爲子節點的 <code>branch</code> 節點</span></p>
<p>我們克隆 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 並存入 <code>branch</code>，代表 <code>leaf</code> 的 <code>Node</code> 現在有兩個擁有者：<code>leaf</code> 和 <code>branch</code>。我們可以透過 <code>branch.children</code> 從 <code>branch</code> 取得 <code>leaf</code>，但是從 <code>leaf</code> 無法取得 <code>branch</code>。云因是因爲 <code>leaf</code> 沒有 <code>branch</code> 的引用且不知道它們之間是有關聯的。我們想要 <code>leaf</code> 能知道 <code>branch</code> 是它的父節點。這就是我們接下來要做的事。</p>
<h4><a class="header" href="#新增從子節點到父節點的引用" id="新增從子節點到父節點的引用">新增從子節點到父節點的引用</a></h4>
<p>要讓子節點意識到它的父節點，我們需要在我們的 <code>Node</code> 結構體定義中加個 <code>parent</code> 欄位。問題在於 <code>parent</code> 應該要是什麼型別。我們知道它不能包含 <code>Rc&lt;T&gt;</code>，因爲那就會造成引用循環，<code>leaf.parent</code> 就會指向 <code>branch</code> 且 <code>branch.children</code> 就會指向 <code>leaf</code>，導致同名的 <code>strong_count</code> 數值無法歸零。</p>
<p>讓我們換種方式思考此關係，父節點必須擁有它的子節點，如果父節點釋放的話，它的子節點也應該要被釋放。但子節點不應該擁有它的父節點，如果我們釋放子節點的話，父節點應該要還存在。這就是弱引用的使用時機！</p>
<p>所以與其使用 <code>Rc&lt;T&gt;</code>，我們使用 <code>Weak&lt;T&gt;</code> 來建立 <code>parent</code> 的型別，更明確的話就是 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>。現在我們的 <code>Node</code> 結構體定義看起來會像這樣：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let leaf = Rc::new(Node {
</span><span class="boring">        value: 3,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">
</span><span class="boring">    let branch = Rc::new(Node {
</span><span class="boring">        value: 5,
</span><span class="boring">        parent: RefCell::new(Weak::new()),
</span><span class="boring">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
</span><span class="boring">
</span><span class="boring">    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
</span><span class="boring">}
</span></code></pre></pre>
<p>節點能夠引用其父節點但不會擁有它。在範例 15-28 中我們更新了 <code>main</code> 來使用新的定義，讓 <code>leaf</code> 節點有辦法引用它的父節點 <code>branch</code>：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">範例 15-28：<code>leaf</code> 節點有其父節點 <code>branch</code> 的弱引用</span></p>
<p>建立 <code>leaf</code> 節點與建立範例 15-27 的 <code>leaf</code> 節點類似，只是要多加個 <code>parent</code> 欄位：<code>leaf</code> 一開始沒有任何父節點，所以我們建立一個空的 <code>Weak&lt;Node&gt;</code> 引用實例。</p>
<p>此時當我們透過 <code>upgrade</code> 方法嘗試取得 <code>leaf</code> 的父節點引用的話，我們會取得 <code>None</code> 數值。我們能在輸出結果的第一個 <code>println!</code> 陳述式看到：</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>當我們建立 <code>branch</code> 節點，它的 <code>parent</code> 欄位也會有個新的 <code>Weak&lt;Node&gt;</code> 引用，因爲 <code>branch</code> 沒有父節點。我們仍然有 <code>leaf</code> 作爲 <code>branch</code> 其中一個子節點。一旦我們有了 <code>branch</code> 的 <code>Node</code> 實例，我們可以修改 <code>leaf</code> 使其擁有父節點的 <code>Weak&lt;Node&gt;</code> 引用。我們對 <code>leaf</code> 中 <code>parent</code> 欄位的 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> 使用 <code>borrow_mut</code> 方法，然後我們使用 <code>Rc::downgrade</code> 函式來從 <code>branch</code> 的 <code>Rc&lt;Node&gt;</code> 建立一個 <code>branch</code> 的 <code>Weak&lt;Node&gt;</code> 引用。</p>
<p>當我們再次印出 <code>leaf</code> 的父節點，這次我們就會取得 <code>Some</code> 變體其內就是 <code>branch</code>，現在 <code>leaf</code> 可以取得它的父節點了！當我們印出 <code>leaf</code>，我們也能避免產生像範例 15-26 那樣最終導致堆疊溢位（stack overflow）的循環，<code>Weak&lt;Node&gt;</code> 會印成 <code>(Weak)</code>：</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>沒有無限的輸出代表此程式碼沒有產生引用循環。我們也能透過呼叫 <code>Rc::strong_count</code> 與 <code>Rc::weak_count</code> 的數值看出。</p>
<h4><a class="header" href="#視覺化-strong_count-與-weak_count-的變化" id="視覺化-strong_count-與-weak_count-的變化">視覺化 <code>strong_count</code> 與 <code>weak_count</code> 的變化</a></h4>
<p>讓我們看看 <code>Rc&lt;Node&gt;</code> 實例中 <code>strong_count</code> 與 <code>weak_count</code> 的數值如何變化，我們建立一個新的內部作用域，並將 <code>branch</code> 的產生移入作用域中。這樣我們就能看到 <code>branch</code> 建立與離開作用域而釋放時發生了什麼事。如範例 15-29 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">範例 15-29：在內部作用域建立 <code>branch</code> 並觀察強與弱引用計數</span></p>
<p>在 <code>leaf</code> 建立後，它的 <code>Rc&lt;Node&gt;</code> 有強計數爲 1 與弱計數爲 0。在內部作用域中，我們建立了 <code>branch</code> 並與 <code>leaf</code> 做連結，此時當我們印出計數時，<code>branch</code> 的 <code>Rc&lt;Node&gt;</code> 會有強計數爲 1 與弱計數爲 1（因爲 <code>leaf.parent</code> 透過 <code>Weak&lt;Node&gt;</code> 指向 <code>branch</code>）。當我們印出 <code>leaf</code> 的計數時，我們會看到它會有強計數爲 2，因爲 <code>branch</code> 現在有個 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 克隆儲存在 <code>branch.children</code>，但弱計數仍爲 0。</p>
<p>當內部作用域結束時，<code>branch</code> 會離開作用域且 <code>Rc&lt;Node&gt;</code> 的強計數會歸零，所以它的 <code>Node</code> 就會被釋放。<code>leaf.parent</code> 的弱計數 1 與 <code>Node</code> 是否被釋放無關，所以我們沒有產生任何記憶體泄漏！</p>
<p>如果我們嘗試在作用域結束後取得 <code>leaf</code> 的父節點，我們會再次獲得 <code>None</code>。在程式的最後，<code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 強計數爲 1 且弱計數爲 0，因爲變數 <code>leaf</code> 現在是 <code>Rc&lt;Node&gt;</code> 唯一的引用。</p>
<p>所有管理計數與數值釋放都已經實作在 <code>Rc&lt;T&gt;</code> 與 <code>Weak&lt;T&gt;</code>，它們都有 <code>Drop</code> 特的實作。在 <code>Node</code> 的定義中指定子節點對父節點的關係應爲 <code>Weak&lt;T&gt;</code> 引用，讓你能夠將父節點與子節點彼此關聯，且不必擔心產生引用循環與記憶體泄漏。</p>
<h2><a class="header" href="#總結-11" id="總結-11">總結</a></h2>
<p>本章節涵蓋了如何使用智慧指標來得到一些不同於 Rust 預設引用所帶來的保障以及取捨。<code>Box&lt;T&gt;</code> 型別有已知大小並能將資料分配到堆積上。<code>Rc&lt;T&gt;</code> 型別會追蹤堆積上資料的引用數量，讓該資料能有數個擁有者。<code>RefCell&lt;T&gt;</code> 型別具有內部可變性，提供一個外部不可變的型別，但有方法可以改變內部數值，其會在執行時強制檢測借用規則，而非編譯時。</p>
<p>我們也討論了 <code>Deref</code> 與 <code>Drop</code> 特徵，這些對智慧指標提供了許多功能。我們探討了引用循環可能會導致記憶體泄漏以及如何使用 <code>Weak&lt;T&gt;</code> 避免它們。</p>
<p>如果本章節引起你的興趣，讓你想要實作你自己的智慧指標的話，歡迎查閱<a href="../nomicon/index.html">「The Rustonomicon」</a>來學習更多實用資訊。</p>
<p>接下來，我們將討論 Rust 的並行性。你還會在學到一些新的智慧指標。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch15-06-reference-cycles.md">e5ed971</a></li>
<li>updated: 2020-09-20</li>
</ul>
</blockquote>
<h1><a class="header" href="#無懼並行" id="無懼並行">無懼並行</a></h1>
<p>能夠安全高效處理並行程式設計是 Rust 的另一像主要目標。*並行程式設計（Concurrent programming）<em>會讓程式的不同部分獨立執行，而</em>平行程式設計（parallel programming）*則是程式的不同部分同時執行。這些隨著電腦越能善用多處理器時也越顯得重要。歷史上，這種程式設計是很困難且容易出錯的，Rust 希望能改善這點。</p>
<p>起初 Rust 團隊認爲確保記憶體安全與預防並行問題是兩個分別的問題，要用不同的解決方案。隨著時間過去，團隊發現所有權與型別系統同時是管理記憶體安全<em>以及</em>並行問題的強大工具！透過藉助所有權與型別檢查，許多並行錯誤在 Rust 中都是編譯時錯誤而非執行時錯誤。因此，你不用花大量時間嘗試重現編譯時並行錯誤出現時的特定情況，不正確的程式碼會在編譯時就被拒絕，並顯示錯誤解釋問題原因。這樣一來，你就可以在開發時就修正問題，而不用等到可能都部署到生產環境了才發現問題。我們稱呼這個 Rust 的特色爲<em>無懼並行（fearless concurrency）</em>。無懼並行可以避免你寫出有微妙錯誤的程式碼，並能輕鬆重構，不用擔心產生新的程式錯誤。</p>
<blockquote>
<p>注意：出於簡潔考量，我們將把許多問題歸類爲<em>並行</em>，而不是精確地區分是<em>並行與/或平行</em>。如果本書是本專注在並行與/或平行的書，我們才會更在意用詞。至於本章節，當我們使用<em>並行</em>的詞彙時，請記得這代表 <em>並行與/或平行</em>。</p>
</blockquote>
<p>許多語言對於處理並行問題所提供的解決方案都很有特色。舉例來說，Erlang 有非常優雅的訊息傳遞並行功能，但跨執行緒共享狀態就只有比較隱晦的方法。只提供支援可能解決方案的子集對於高階語言來說是合理的策略，因爲高階語言所承諾的效益來自於犧牲一些掌控以換取大量的抽象層面。然而，低階語言則預期會提供在任何給定場合中能有最佳效能的解決方案，而且對硬體的抽象較少。因此 Rust 提供了多種工具來針對適合你的場合與需求將問題定義出來。</p>
<p>本章節中我們會涵蓋這些主題：</p>
<ul>
<li>如何建立執行緒（threads）來同時執行多段程式碼</li>
<li>*訊息傳遞（Message-passing）*並行提供通道（channels）在執行緒間傳遞訊息</li>
<li>*共享狀態（Shared-state）*並行提供多執行緒可以存取同一位置的資料</li>
<li><code>Sync</code> 與 <code>Send</code> 特徵擴展 Rust 的並行保障至使用者定義的型別與標準函式庫的型別中</li>
</ul>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch16-00-concurrency.md">e5ed971</a></li>
<li>updated: 2020-09-20</li>
</ul>
</blockquote>
<h2><a class="header" href="#使用執行緒同時執行程式碼" id="使用執行緒同時執行程式碼">使用執行緒同時執行程式碼</a></h2>
<p>在大部分的現代作業系統中，被執行的程式碼會在<em>程序（process）<em>中執行，作業系統會負責同時處理數個程序。在你的程式中，你也可以將各自獨立的部分同時執行。執行這些獨立部分的功能就叫做</em>執行緒（threads）</em>。</p>
<p>將程式中的運算拆成數個執行緒可以提升效能，因爲程式能同時執行多項任務，不過這也同時增加了複雜度。因爲執行緒可以同時執行，所以無法保證不同執行緒的程式碼執行的順序。這會導致以下問題：</p>
<ul>
<li>競爭條件（Race conditions）：數個執行緒已不一致的順序取得資料或資源</li>
<li>死結（Deadlocks）：兩個執行緒彼此都在等待對方停止使用它們所需的資源，因而讓執行緒無法繼續執行</li>
<li>只在特定情形會發生的程式錯誤，並難以重現與穩定修復</li>
</ul>
<p>Rust 嘗試降低使用執行緒所帶來的負面效果，不過對於多執行緒程式設計還是得格外小心，其所要求的程式結構也與單一執行緒的程式有所不同。</p>
<p>不同程式語言會以不同的方式實作執行緒。許多作業系統都有提供 API 來建立新的執行緒。這樣讓一個語言呼叫作業系統 APIs 來建立執行緒的方式有時會稱爲 <em>1:1</em>，代表每一個語言產生的執行緒就是一個作業系統的執行緒。</p>
<p>而有許多程式語言會提供它們自己的特殊執行緒實作。程式語言提供的執行緒被稱爲*綠色（green）*執行緒，而使用綠色執行緒的語言底層會執行數個作業系統執行緒。因此綠色執行緒的模型會被稱爲 <em>M:N</em>：每 <code>M</code> 個綠色執行緒會有 <code>N</code> 作業系統執行緒，<code>M</code> 和 <code>N</code> 的數量可能會不相同。</p>
<p>每種模型都有它的優勢與取捨，而對 Rust 來說最重要的取捨就是執行時支援。*執行時（Runtime）*是個令人困惑的術語且在不同場合會帶有不同意義。</p>
<p>在這裡我們指的<em>執行時</em>是每個二進制檔案中語言所提供的程式碼。此程式碼根據不同語言可大可小，但每個非組合語言的語言都一定會有一些執行時程式碼。所以說當人們常說一個語言「沒有執行時」的話，他們常常指的是「小執行時」。較小的執行時提供的功能就較少，但優勢在於可以產生較小的二進制檔案，這能使得與其他語言結合更加容易。雖然許多語言都能接受增加執行時的大小來換取更多功能，但 Rust 需要做到幾乎沒有執行時，且必須能夠呼叫 C 來維持效能，這也是不能妥協的。</p>
<p>綠色執行緒 M:N 模組需要更大的語言執行時來管理執行緒。因此 Rust 標準函式庫只提供了 1:1 執行緒的實作。因爲 Rust 屬於低階語言。如果你寧願花費一些開銷以換取像是更容易地控制執行緒於何時執行，或者能降低環境切換成本等功能的話，你可以尋找有實作 M:N 執行緒的 crate。</p>
<p>現在我們已經定義了 Rust 中的執行緒，讓我們來探討如何使用標準函式庫提供的執行緒 API 吧。</p>
<h3><a class="header" href="#透過-spawn-建立新的執行緒" id="透過-spawn-建立新的執行緒">透過 <code>spawn</code> 建立新的執行緒</a></h3>
<p>要建立一個新的執行緒，我們呼叫函式 <code>thread::spawn</code> 並傳入一個閉包（我們在第十三章談過閉包），其包含我們想在新執行緒執行的程式碼。範例 16-1 會在主執行緒印出一些文字，並在新執行緒印出其他文字：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">範例 16-1：建立一個會印出一些字的新執行緒，而主執行緒會印出其他字</span></p>
<p>注意到此函式中，如果主執行緒結束的話，新的執行緒也會被停止，無論它有沒有完成任務。此程式的輸出結果每次可能都會有點不相同，但它會類似以下這樣：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p><code>thread::sleep</code> 的呼叫強制執行緒短時間內停止運作，讓不同的執行緒可以執行。執行緒可能會輪流執行，但並不保證絕對如此，這會依據你的作業系統如何安排執行緒而有所不同。在這一輪中，主執行緒會先顯示，就算程式中是先寫新執行緒的 <code>println!</code> 陳述式。而且雖然我們是寫說新執行緒印出 <code>i</code> 一直到 9，但它在主執行緒結束前只印到 5。</p>
<p>如果當你執行此程式時只看到主執行緒的結果，或者沒有看到任何交錯的話，你可以嘗試增加數字範圍來增加作業系統切換執行緒的機會。</p>
<h3><a class="header" href="#使用-join-等待所有執行緒完成" id="使用-join-等待所有執行緒完成">使用 <code>join</code> 等待所有執行緒完成</a></h3>
<p>範例 16-1 的程式碼在主執行緒結束時不只會在大多數的時候提早結束新產生的執行緒，還有可能完全不讓新執行緒執行。原因是因爲執行緒無法保證執行的順序！</p>
<p>透過儲存 <code>thread::spawn</code> 回傳的數值爲變數，我們可以修正產生的執行緒完全沒有執行或沒有執行完成的問題。<code>thread::spawn</code> 的回傳型別爲 <code>JoinHandle</code>。<code>JoinHandle</code> 是個有所有權的數值，當我們對它呼叫 <code>join</code> 方法時，它就會等待它的執行緒完成。範例 16-2 顯示了如何使用我們在範例 16-1 中執行緒的 <code>JoinHandle</code> 並呼叫 <code>join</code> 來確保產生的執行緒會在 <code>main</code> 離開之前完成：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 16-2：從 <code>thread::spawn</code> 儲存 <code>JoinHandle</code> 以保障執行緒能執行完成</span></p>
<p>對其呼叫 <code>join</code> 會阻擋當前正在執行的執行緒中直到 <code>JoinHandle</code> 的執行緒結束爲止。*阻擋（Blocking）*一條執行緒代表該執行緒不會繼續運作或離開。因爲我們在主執行緒的 <code>for</code> 迴圈之後加上了 <code>join</code> 的呼叫，範例 16-2 應該會產生類似以下的輸出：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>兩條執行緒會互相交錯，但是主執行緒這次會因爲 <code>handle.join()</code> 而等待，直到產生的執行緒完成前都不會結束。</p>
<p>那如果我們如以下這樣將 <code>handle.join()</code> 移到 <code>main</code> 中的 <code>for</code> 迴圈前會發生什麼事呢：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>主執行緒會等待產生的執行緒完成才會執行它的 <code>for</code> 迴圈，所以輸出結果就不會彼此交錯，如以下所示：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>像這樣將 <code>join</code> 呼叫置於何處的小細節，會影響你的執行緒會不會同時運行。</p>
<h3><a class="header" href="#透過執行緒使用-move-閉包" id="透過執行緒使用-move-閉包">透過執行緒使用 <code>move</code> 閉包</a></h3>
<p><code>move</code> 閉包通常會搭配 <code>thread::spawn</code> 使用因爲它讓你的執行緒可以使用其他執行緒的資料。</p>
<p>在第十三章中，我們提到我們可以在閉包參數列表前使用 <code>move</code> 關鍵字來強制閉包取得其從環境獲取數值的所有權。此技巧在建立新的執行緒特別有用，讓我們可以從一個執行緒轉移數值所有權到另一個執行緒。</p>
<p>注意到範例 16-1 中我們傳入 <code>thread::spawn</code> 的閉包沒有任何引數，我們在產生的執行緒程式碼內沒有使用主執行緒的任何資料。要在產生的執行緒中使用主執行緒的資料的話，產生的執行緒閉包必須獲取它所需的資料。範例 16-3 嘗試在主執行緒建立一個 vector 並在產生的執行緒使用它。不過這目前無法執行，你會在稍後知道原因。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">範例 16-3：嘗試在其他執行緒使用主執行緒建立的 vector</span></p>
<p>閉包想使用 <code>v</code>，所以它得獲取 <code>v</code> 並使其成爲閉包環境的一部分。因爲 <code>thread::spawn</code> 會在新的執行緒執行此閉包，我們要能在新的執行緒內存取 <code>v</code>。但當我們編譯此範例時，我們會得到以下錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
note: function requires argument type to outlive `'static`
 --&gt; src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!(&quot;Here's a vector: {:?}&quot;, v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust 會<em>推斷</em>如何獲取 <code>v</code> 而且因爲 <code>println!</code> 只需要 <code>v</code> 的引用，閉包得借用 <code>v</code>。不過這會有個問題，Rust 無法知道產生的執行緒會執行多久，所以它無法確定 <code>v</code> 的引用是不是永遠有效。</p>
<p>範例 16-4 提供了一個情境讓 <code>v</code> 很有可能不再有效：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">範例 16-4：執行緒的閉包嘗試獲取 <code>v</code> 的引用，但主執行緒會釋放 <code>v</code></span></p>
<p>如果我們允許執行此程式碼，產生的執行緒是有可能會置於背景而沒有馬上執行。產生的執行緒內部有 <code>v</code> 的引用，但主執行緒會立即釋放 <code>v</code>，使用我們在第十五章討論過的 <code>drop</code> 函式。然後當產生的執行緒開始執行時，<code>v</code> 就不再有效了，所以它的引用也是無效的了。喔不！</p>
<p>要修正範例 16-3 的編譯錯誤，我們可以使用錯誤訊息的建議：</p>
<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>透過在閉包前面加上 <code>move</code> 關鍵字，我們強制讓閉包取得它所要使用數值的所有權，而非任由 Rust 去推斷它是否該借用數值。範例 16-5 修改了範例 16-3 並能夠如期編譯與執行：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 16-5：使用 <code>move</code> 關鍵字強制閉包取得它所使用數值的所有權</span></p>
<p>如果我們使用 <code>move</code> 閉包的話，只執行緒會呼叫 <code>drop</code> 的範例 16-4 會發生什麼事呢？<code>move</code> 能修正這樣的情況嗎？不幸的是，不行。我們會得到不同的錯誤，因爲範例 16-4 想做的事情會因爲不同原因而不被允許。如果我們對閉包加上了 <code>move</code>，我們會將 <code>v</code> 移入閉包環境，然後我們就無法在主執行緒對它呼叫 <code>drop</code>了。我們會得到另一個編譯錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait
5  | 
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
7  |         println!(&quot;Here's a vector: {:?}&quot;, v);
   |                                           - variable moved due to use in closure
...
10 |     drop(v); // oh no!
   |          ^ value used here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust 的所有權規則再次整救了我們！我們在範例 16-3 會得到錯誤是因爲 Rust 是保守的所以只會爲執行緒借用 <code>v</code>，這代表主執行緒理論上可能會使產生的執行緒的引用無效化。透過告訴 Rust 將 <code>v</code> 的所有權移入產生的執行緒中，我們向 Rust 保證不會在主執行緒用到 <code>v</code>。如果我們用相同方式修改範例 16-4 的話，當我們嘗試在主執行緒使用 <code>v</code> 的話，我們就違反了所有權規則。<code>move</code> 關鍵字會覆蓋 Rust 保守的預設借用行爲，且也不允許我們違反所有權規則。</p>
<p>有了對執行緒與執行緒 API 的基本瞭解，讓我們看看我們可以透過執行緒<em>做些</em>什麼。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch16-01-threads.md">e5ed971</a></li>
<li>updated: 2020-09-21</li>
</ul>
</blockquote>
<h2><a class="header" href="#使用訊息傳遞在執行緒間傳送資料" id="使用訊息傳遞在執行緒間傳送資料">使用訊息傳遞在執行緒間傳送資料</a></h2>
<p>其中一種確保安全並行且漸漸流行起來的方式是<em>訊息傳遞（message passing）</em>，執行緒或 actors 透過傳遞包含資料的訊息給彼此來溝通。此理念源自於 <a href="https://golang.org/doc/effective_go.html#concurrency">Go 語言技術文件</a>中的口號：「別透過共享記憶體來溝通，而是透過溝通來共享記憶體。」 </p>
<p>Rust 其中一個達成訊息傳遞並行的主要工具是<em>通道（channel）</em>，這是 Rust 標準函式庫有提供的程式設計概念。你可以把程式設計的通道想像成水流的通道，像是河流或小溪。如果你將橡皮小鴨或船隻放入河流中，它會順流而下到下游。</p>
<p>程式設計中的通道有兩個部分：發送者（transmitter）與接收者（receiver）。發送者正是你會放置橡皮小鴨到河流中的上游，而接收者則是橡皮小鴨最後漂流到的下游。你程式碼中的一部分會呼叫發送者的方法來傳送你想要傳遞的資料，然後另一部分的程式碼會檢查接收者收到的訊息。當發送者或接收者有一方被釋放掉時，該通道就會被<em>關閉</em>。</p>
<p>我們在此將寫一支程式，它會在一個執行緒中產生數值，傳送給通道，然後另一個執行緒會接收到數值並印出來。我們會使用通道在執行緒間傳送簡單的數值來作爲這個功能的解說。一旦你熟悉此技巧後，你可以使用通道來實作個聊天系統，或是一個利用數個執行緒進行運算，然後將結果傳入一個執行緒統整結果的分散式系統。</p>
<p>首先在範例 16 -6，我們會建立個通道但還不會做任何事。注意這樣不會編譯通過因爲 Rust 無法知道我們想對通道傳入的數值型別爲何。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
</code></pre>
<p><span class="caption">範例 16-6：建立通道並賦值分別兩個部分給 <code>tx</code> 與 <code>rx</code></span></p>
<p>我們使用 <code>mpsc::channel</code> 函式來建立新的通道，<code>mpsc</code> 指的是<em>多重生產者、唯一消費者（multiple producer, single consumer）</em>。簡單來說，Rust 標準函式庫實作通道的方式讓通道可以有多個<em>發送端</em>來產生數值，不過只有一個<em>接收端</em>能消耗這些數值。想像有數個溪流匯聚成一條大河流，任何溪流傳送的任何東西最終都會流向河流的下游。我們會先從單一生產者開始，等這個範例能夠執行後我們再來增加數個生產者。</p>
<p><code>mpsc::channel</code> 函式會回傳一個元組，第一個元素是發送端然後第二個元素是接收端。<code>tx</code> 與 <code>rx</code> 通常分別作爲*發送者（transmitter）<em>與</em>接收者（receiver）*的縮寫，所以我們以此作爲我們的變數名稱。我們的 <code>let</code> 陳述式使用到了能解構元組的模式我們會在第時八章討論 <code>let</code> 陳述式的模式與解構方式。用這樣的方式使用 <code>let</code> 能輕鬆取出 <code>mpsc::channel</code> 回傳的元組每個部分。</p>
<p>讓我們將發送端移進一個新產生的執行緒並讓它傳送一條字串，這樣產生的執行緒就可以與主執行緒溝通了，如範例 16-7 所示。這就像是在河流上游放了一隻橡皮小鴨，或是從一條執行緒傳送一條聊天訊息給別條執行緒一樣。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">範例 16-7：將 <code>tx</code> 移入產生的執行緒並傳送「hi」</span></p>
<p>我們再次使用 <code>thread::spawn</code> 來建立新的執行緒並使用 <code>move</code> 將 <code>tx</code> 移入閉包，讓產生的執行緒擁有 <code>tx</code>。產生的執行緒必須要擁有通道的發送端才能夠傳送訊息至通道。</p>
<p>發送端有個 <code>send</code> 方法可以接受我們想傳遞的數值。<code>send</code> 方法會回傳 <code>Result&lt;T, E&gt;</code> 型別，所以如果接收端已經被釋放因而沒有任何地方可以傳遞數值的話，傳送的動作就會回傳錯誤。在此例中，我們呼叫 <code>unwrap</code> 所以有錯誤時就會直接恐慌。但在實際的應用程式中，我們會更妥善地處理它，你可以回顧第九章來複習如何適當地處理錯誤。</p>
<p>在範例 16-8 我們會在主執行緒中從通道的接收端取得數值。這就像在河流下游取回順流而下的橡皮小鴨，或是像取得一條聊天訊息一樣。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">範例 16-8：在主執行緒取得數值「hi」並顯示出來</span></p>
<p>通道的接收端有兩個實用的方法：<code>recv</code> 與 <code>try_recv</code>。我們使用 <code>recv</code> 作爲*接收（receive）*的縮寫，這位阻擋主執行緒的運行並等待直到通道有訊息傳入。一旦有數值傳遞，<code>recv</code> 會就以此回傳 <code>Result&lt;T, E&gt;</code>。當通道的發送端關閉時，<code>recv</code> 會回傳錯誤來通知不會再有任何數值出現了。</p>
<p><code>try_recv</code> 方法則不會阻擋，而是會立即回傳 <code>Result&lt;T, E&gt;</code>。如果有數值的話，就會是存有訊息的 <code>Ok</code> 數值，如果尚未有任何數值的話，就會是 <code>Err</code> 數值。<code>try_recv</code> 適用於如果此執行緒在等待訊息的同時有其他事要做的情形。我們可以寫個迴圈來時不時呼叫 <code>try_recv</code>，當有數值時處理訊息，不然的話就先做點其他事直到再次檢查爲止。</p>
<p>我們出於方便考量在此例使用 <code>recv</code>，我們的主執行緒除了等待訊息以外沒有其他事好做，所以阻擋主執行緒是合理的。</p>
<p>當我們執行範例 16-8 的程式碼，我們會看到主執行緒印出的數值：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
</code></pre>
<p>太棒了！</p>
<h3><a class="header" href="#通道與所有權轉移" id="通道與所有權轉移">通道與所有權轉移</a></h3>
<p>所有權規則在訊息傳遞中扮演了重要的角色，因爲它們可以幫助你寫出安全的並行程式碼。在 Rust 程式中考慮所有權的其中一項好處就是你能在並行程式設計避免錯誤發生。讓我們做個實驗來看通道與所有權如何一起合作來避免問題發生，我們會在 <code>val</code> 數值傳送給通道<em>之後</em>嘗試使用其值。請嘗試編譯範例 16-9 的程式碼並看看爲何此程式碼不被允許：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">範例 16-9：在我們將 <code>val</code> 傳入通道後嘗試使用其值</span></p>
<p>我們在這裡透過 <code>tx.send</code> 將 <code>val</code> 傳入通道之後嘗試印出其值。允許這麼做的話會是個壞主意，一旦數值被傳至其他執行緒，該執行緒就可以在我們嘗試再次使用該值之前修改或釋放其值。其他執行緒的修改有機會因爲不一致或不存在的資料而導致錯誤或意料之外的結果。不過如果我試著編譯範例 16-9 的程式碼的話，Rust 會給我們一個錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling message-passing v0.1.0 (file:///projects/message-passing)
error[E0382]: borrow of moved value: `val`
  --&gt; src/main.rs:10:31
   |
8  |         let val = String::from(&quot;hi&quot;);
   |             --- move occurs because `val` has type `std::string::String`, which does not implement the `Copy` trait
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `message-passing`.

To learn more, run the command again with --verbose.
</code></pre>
<p>我們的並行錯誤產生了一個編譯時錯誤。<code>send</code> 函式會取走其參數的所有權，並當數值移動時，接收端會在取得其所有權。這能阻止我們在傳送數值過後不小心再次使用其值，所有權系統會檢查一切是否符合規則。</p>
<h3><a class="header" href="#傳送多重數值並觀察接收者等待" id="傳送多重數值並觀察接收者等待">傳送多重數值並觀察接收者等待</a></h3>
<p>範例 16-8 的程式碼可以編譯通過並執行，但它並沒有清楚表達出兩個不同的執行緒正透過通道彼此溝通。在範例 16-10 中我們做了些修改來證明範例 16-8 的程式有正確執行，產生的執行緒先在會傳送數個訊息並在每個訊息間暫停個一秒鐘。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">範例 16-10：傳送數個訊息並在之間暫停片刻</span></p>
<p>這次產生的執行緒有個字串 vector，我們希望能傳送它們到主執行緒中。我們遍歷它們，單獨傳送每個值，然後透過 <code>Duration</code> 數值呼叫 <code>thread::sleep</code> 來暫停一秒。</p>
<p>在主執行緒中，我們不再顯式呼叫 <code>recv</code> 函式，我們改將 <code>rx</code> 作爲疊代器使用。對每個接收到的數值，我們印出它。當通道關閉時，疊代器就會結束。</p>
<p>當執行範例 16-10 的程式碼，你應該會看到以下輸出，每一行會間格一秒鐘：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>因爲我們在主執行緒中的 <code>for</code> 迴圈內沒有任何會暫停或延遲的程式碼，所以我們可以看出主執行緒是在等待產生的執行緒傳送的數值。</p>
<h3><a class="header" href="#透過克隆發送者來建立多重生產者creating-multiple-producers-by-cloning-the-transmitter" id="透過克隆發送者來建立多重生產者creating-multiple-producers-by-cloning-the-transmitter">透過克隆發送者來建立多重生產者Creating Multiple Producers by Cloning the Transmitter</a></h3>
<p>稍早之前我們提過 <code>mpsc</code> 是*多重生產者、唯一消費者（multiple producer, single consumer）*的縮寫。讓我們來使用 <code>mpsc</code> 並擴產範例 16-10 的程式碼來建立數個執行緒，它們都將傳遞數值給同個接收者。爲此我們可以克隆通道的發送部分，如範例 16-11 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    // --snip--

    let (tx, rx) = mpsc::channel();

    let tx1 = mpsc::Sender::clone(&amp;tx);
    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;more&quot;),
            String::from(&quot;messages&quot;),
            String::from(&quot;for&quot;),
            String::from(&quot;you&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }

    // --snip--
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 16-11：從多重生產者傳遞數個訊息</span></p>
<p>這次在我們建立第一個產生的執行緒前，我們會對通道的發送端呼叫 <code>clone</code>。這能給我們一個新的發送者，讓我們可以移入第一個產生的執行緒。接著我們將原本的通道發送端移入第二個產生的執行緒中。這樣我們就有了兩條執行緒，每條都能傳送不同的訊息給通道的接收端。</p>
<p>當你執行程式碼時，你的輸出應該會類似以下結果：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>你可能會看到數值以不同順序排序，這完全依據你的系統來決定。這正是並行程式設計既有趣卻又困難。如果你加上 <code>thread::sleep</code> 來實驗，並在不同執行緒給予不同數值的話，就會發現每一輪都會更不確定，每次都會產生不同的輸出結果。</p>
<p>現在我們已經看完通道如何運作，接著讓我們來看看並行的不同方法吧。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch16-02-message-passing.md">e5ed971</a></li>
<li>updated: 2020-09-21</li>
</ul>
</blockquote>
<h2><a class="header" href="#共享狀態並行" id="共享狀態並行">共享狀態並行</a></h2>
<p>訊息傳遞是個很好的並行處理方式，但它不是唯一。回憶一下之前 Go 語言技術文件中的口號：「別透過共享記憶體來溝通。」</p>
<p>透過共享記憶體來溝通會是什麼樣子呢？除此之外，爲何訊息傳遞愛好者不喜歡這種方式並反其道而行呢？</p>
<p>任何程式語言的通道某方面來說類似於單一所有權，因爲一旦你轉移數值給通道，你就不該使用該數值。共享記憶體並行則像多重所有權，數個執行緒可以同時存取同個記憶體位置。如同你在第十五章所見到的，智慧指標讓多重所有權成爲可能，但多重所有權會增加複雜度，因爲我們會需要管理這些不同的擁有者。Rust 的型別系統與所有權規則大幅地協助了正確管理這些所有權。作爲範例就讓我們看看互斥鎖（mutexes），這是共享記憶體中常見的並行原始元件之一。</p>
<h3><a class="header" href="#使用互斥鎖在同時間只允許一條執行緒存取資料" id="使用互斥鎖在同時間只允許一條執行緒存取資料">使用互斥鎖在同時間只允許一條執行緒存取資料</a></h3>
<p>*互斥鎖（Mutex）<em>是 <em>mutual exclusion</em> 的縮寫，顧名思義互斥鎖在任意時刻只允許一條執行緒可以存取一些資料。要取得互斥鎖中的資料，執行緒必須先透過獲取互斥鎖的</em>鎖（lock）<em>來表示它想要進行存取。鎖是互斥鎖其中一部分的資料結構，用來追蹤當前誰擁有資料的獨佔存取權。因此互斥鎖被描述爲會透過鎖定系統</em>守護（guarding）*其所持有的資料。</p>
<p>互斥鎖以難以使用著名，因爲你必須記住兩個規則：</p>
<ul>
<li>你必須在使用資料前獲取鎖。</li>
<li>當你用完互斥鎖守護的資料，你必須解鎖資料，所以其他的執行緒才能獲取鎖。</li>
</ul>
<p>要用真實世界來比喻互斥鎖的話，想像在會議中有個座談會只有一支麥克風。如果有講者想要發言時，他們需要請求或示意他們想要使用麥克風。當他們取得麥克風時，他們想講多久都沒問題，直到將麥克風遞給下個要求發言的講者。如果講者講完後忘記將麥克風遞給其他人的話，就沒有人有辦法發言。如果麥克風的分享出狀況的話，座談會就無法如期進行！</p>
<p>互斥鎖的管理要正確處理是極爲困難的，這也是爲何這麼多人傾向於使用通道。然而有了 Rust 的型別系統與所有權規則，你就不會在鎖定與解鎖之間出錯了。</p>
<h4><a class="header" href="#mutext-的-api" id="mutext-的-api"><code>Mutex&lt;T&gt;</code> 的 API</a></h4>
<p>作爲使用互斥鎖的範例，讓我們先在單執行緒使用互斥鎖，如範例 16-12 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">範例 16-12：基於簡便考量先用單一執行緒探討 <code>Mutex&lt;T&gt;</code> 的 API</span></p>
<p>就像許多型別一樣，我們使用關聯函式 <code>new</code> 建立 <code>Mutex&lt;T&gt;</code>。要取得互斥鎖內的資料，我們使用 <code>lock</code> 方法來獲取鎖。此呼叫會阻擋當前執行緒做任何事，直到輪到它取得鎖。</p>
<p>如果其他持有鎖的執行緒恐慌的話 <code>lock</code> 的呼該要就會失敗。在這樣的情況下，就沒有任何人可以獲得鎖，因此當我們遇到這種情況時，我們選擇 <code>unwrap</code> 並讓此執行緒恐慌。</p>
<p>在我們獲取鎖之後，我們在此例可以將回傳的數值取作 <code>num</code>，作爲內部資料的可變引用。型別系統能確保我們在使用數值 <code>m</code> 之前有獲取鎖，<code>Mutex&lt;i32&gt;</code> 並不是 <code>i32</code>，所以我們<em>必須</em>取得鎖才能使用 <code>i32</code> 數值。我們不可能會忘記這麼做，不然型別系統不會讓我們存取內部的 <code>i32</code>。</p>
<p>如同你所想像的，<code>Mutex&lt;T&gt;</code> 就是個智慧指標。更精確的來說，<code>lock</code> 的呼叫會<em>回傳</em>一個智慧指標叫做 <code>MutexGuard</code>，這是我們從 <code>LockResult</code> 呼叫 <code>unwrap</code> 取得的型別。<code>MutexGuard</code> 智慧指標有實作 <code>Deref</code> 特徵來指向我們的內部資料。此智慧指標也有 <code>Drop</code> 的實作，這會在 <code>MutexGuard</code> 離開作用域時自動釋放鎖，在範例 16-12 的內部作用域結尾就會執行此動作。這樣一來，我們就不會忘記釋放鎖，怕互斥鎖會阻擋其他執行緒，因爲鎖會自動被釋放。</p>
<p>在釋放鎖之後，我們就能印出互斥鎖的數值並觀察到我們能夠變更內部的 <code>i32</code> 爲 6。</p>
<h4><a class="header" href="#在數個執行緒間共享-mutext" id="在數個執行緒間共享-mutext">在數個執行緒間共享 <code>Mutex&lt;T&gt;</code></a></h4>
<p>現在讓我們來透過 <code>Mutex&lt;T&gt;</code> 來在數個執行緒間分享數值。我們會建立 10 個執行緒並讓它們都會對一個計數增加 1，讓計數能從 0 加到 10。作爲下個例子的範例 16-13 會出現一個編譯錯誤，我們會用此錯誤瞭解如何使用 <code>Mutex&lt;T&gt;</code> 以及 Rust 如何協助我們來正確使用它。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">範例 16-13：十個執行緒都會對 <code>Mutex&lt;T&gt;</code> 守護的計數增加 1</span></p>
<p>我們建立個變數 <code>counter</code> 並在 <code>Mutex&lt;T&gt;</code> 內存有 <code>i32</code>，就像我們在範例 16-12 所做的一樣。接著我們透過指定的範圍建立 10 個執行緒。我們使用 <code>thread::spawn</code> 讓所有的執行緒都有相同的閉包，此閉包會將計數移入執行緒、呼叫 <code>lock</code> 以獲取 <code>Mutex&lt;T&gt;</code> 的鎖，然後將互斥鎖內的數值加 1。當有執行緒執行完它的閉包時，<code>num</code> 會離開作用域並釋放鎖，讓其他的執行緒可以獲取它。</p>
<p>在主執行緒中，我們要收集所有的執行緒。然後如同我們在範例 16-2 所做的，我們呼叫每個執行緒的 <code>join</code> 來確保所有執行緒都有完成。在這時候，主執行緒就能獲取鎖並印出此程式的結果。</p>
<p>我們曾暗示範例不會編譯過，讓我們看看是爲何吧！</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:9:36
   |
5  |     let counter = Mutex::new(0);
   |         ------- move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`, which does not implement the `Copy` trait
...
9  |         let handle = thread::spawn(move || {
   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop
10 |             let mut num = counter.lock().unwrap();
   |                           ------- use occurs due to use in closure

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
</code></pre>
<p>錯誤訊息表示 <code>counter</code> 數值在之前的迴圈循環中被移動了，所以 Rust 告訴我們我們無法將 <code>counter</code> 鎖的所有權移至數個執行緒中。讓我們用第十五章提到的多重所有權方法來修正此編譯錯誤吧。</p>
<h4><a class="header" href="#多重執行緒中的多重所有權" id="多重執行緒中的多重所有權">多重執行緒中的多重所有權</a></h4>
<p>在第十五章中，我們透過智慧指標 <code>Rc&lt;T&gt;</code> 來建立引用計數數值讓該資料可以擁有數個擁有者。讓我們在此也做同樣的動作來看看會發生什麼事。我們會在範例 16-14 將 <code>Mutex&lt;T&gt;</code> 封裝進 <code>Rc&lt;T&gt;</code> 並在將所有權移至執行緒前克隆 <code>Rc&lt;T&gt;</code>。現在既然我們已經知道到錯誤的原因，讓我們也改回使用 <code>for</code> 迴圈，並保留閉包的 <code>move</code> 關鍵字。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">範例 16-14：嘗試使用 <code>Rc&lt;T&gt;</code> 來允許數個執行緒擁有 <code>Mutex&lt;T&gt;</code></span></p>
<p>再編譯一次的話我們會得到... 不同的錯誤！編譯器真的是教了我們很多事。</p>
<pre><code class="language-console">$ cargo run
   Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0277]: `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
   --&gt; src/main.rs:11:22
    |
11  |         let handle = thread::spawn(move || {
    |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely
    |
    = help: within `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `shared-state`.

To learn more, run the command again with --verbose.
</code></pre>
<p>哇，這個錯誤訊息的內容真多！這是我們需要注意到的部分：<code>`Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>。編譯器也告訴了我們原因：<code>the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;` </code>。我們會在下一個段落討論 <code>Send</code>，這是其中一種確保我們在執行緒中所使用的型別可以用於並行場合的特徵。</p>
<p>不幸的是 <code>Rc&lt;T&gt;</code> 無法安全地跨執行緒分享。當 <code>Rc&lt;T&gt;</code> 管理引用計數時，它會在每個 <code>clone</code> 的呼叫增加計數，並在每個克隆釋放時減少計數。但是它沒有使用任何並行原始元件來確保計數的改變不會被其他執行緒中斷。這樣的計數可能會導致微妙的程式錯誤，像是記憶體泄漏或是在數值釋放時嘗試使用其值。我們需要一個型別和 <code>Rc&lt;T&gt;</code> 一模一樣，但是其引用計數在執行緒間是安全的。</p>
<h4><a class="header" href="#原子引用計數-arct" id="原子引用計數-arct">原子引用計數 <code>Arc&lt;T&gt;</code></a></h4>
<p>幸運的是 <code>Arc&lt;T&gt;</code> <em>正是</em>一個類似 <code>Rc&lt;T&gt;</code> 且能安全用在並行場合的型別。字母 <em>A</em> 指的是<em>原子性（atomic）</em> 代表這是個<em>原子性引用的計數</em>型別。原子型別是另一種我們不會在此討論的並行原始元件，你可以查閱標準函式庫的 <a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a> 技術文件以瞭解更多詳情。在此你只需要知道原子型別和原始型別類似，但它們可以安全在執行緒間共享。</p>
<p>你可能會好奇爲何原始型別不是原子性的，以及爲何標準函式庫的型別預設不使用 <code>Arc&lt;T&gt;</code> 來實作。原因是因爲執行緒安全意味著效能開銷，你會希望在你真的需要時才買單。如果你只是在單一執行緒對數值做運算的話，你的程式碼就不必強制具有原子性的保障並能執行地更快。</p>
<p>讓我們回到我們的範例：<code>Arc&lt;T&gt;</code> 與 <code>Rc&lt;T&gt;</code> 具有相同的 API，所以我們透過更改 <code>use</code> 這行、<code>new</code> 的呼叫以及 <code>clone</code> 的呼叫來修正我們程式，。範例 16-15 的程式碼最終將能夠編譯並執行：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">範例 16-15：使用 <code>Arc&lt;T&gt;</code> 封裝 <code>Mutex&lt;T&gt;</code> 來在數個執行緒間分享所有權</span></p>
<p>此程式碼會印出以下結果：</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Result: 10
</code></pre>
<p>我們辦到了！我們從 0 數到了 10，雖然看起來不是很令人印象深刻，但這的確教會了我們很多有關 <code>Mutex&lt;T&gt;</code> 與執行緒安全的知識。你也可以使用此程式結構來做更多複雜的運算，而不只是數數而已。使用此策略，你可以將運算拆成數個獨立部分，將它們分配給執行緒，然後使用 <code>Mutex&lt;T&gt;</code> 來讓每個執行緒更新該部分的結果。</p>
<h3><a class="header" href="#refcelltrct-與-mutextarct-之間的相似度" id="refcelltrct-與-mutextarct-之間的相似度"><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> 與 <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code> 之間的相似度</a></h3>
<p>你可能已經注意到 <code>counter</code> 是不可變的，但我們卻可以取得數值其內部的可變引用，這代表 <code>Mutex&lt;T&gt;</code> 有提供內部可變性，就像 <code>Cell</code> 家族一樣。我們在第十五章也以相同的方式使用 <code>RefCell&lt;T&gt;</code> 來讓我們能改變 <code>Rc&lt;T&gt;</code> 內部的數值，而在此我們使用 <code>Mutex&lt;T&gt;</code> 改變 <code>Arc&lt;T&gt;</code> 內部的內容。</p>
<p>另一個值得注意的細節是當你使用 <code>Mutex&lt;T&gt;</code> 時，Rust 無法避免所有種類的邏輯錯誤。 回憶一下第十五章使用 <code>Rc&lt;T&gt;</code> 時會有可能產生引用循環的風險，兩個 <code>Rc&lt;T&gt;</code> 數值可能會彼此引用，造成記憶體泄漏。同樣地，<code>Mutex&lt;T&gt;</code> 有產生*死結（deadlocks）*的風險。這會發生在當有個動作需要鎖定兩個資源，而有兩個執行緒分別擁有其中一個鎖，導致它們永遠都在等待彼此。如果你對此有興趣的話，歡迎嘗試建立一個有死結的 Rust 程式，然後研究看看任何語言中避免的互斥鎖死結的策略，並嘗試實作它們在 Rust 中。標準函式庫中 <code>Mutex&lt;T&gt;</code> 與 <code>MutexGuard</code> 的 API 技術文件可以提供些實用資訊。</p>
<p>接下來在本章結尾我們會來討論 <code>Send</code> 與 <code>Sync</code> 特徵以及我們如何在自訂型別中使用它們。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch16-03-shared-state.md">e5ed971</a></li>
<li>updated: 2020-09-22</li>
</ul>
</blockquote>
<h2><a class="header" href="#可延展的並行與-sync-及-send-特徵" id="可延展的並行與-sync-及-send-特徵">可延展的並行與 <code>Sync</code> 及 <code>Send</code> 特徵</a></h2>
<p>有一個有趣的點是 Rust 語言提供的並行功能並<em>沒有很多</em>。本章節討論到的並行功能幾乎都來自於標準函式庫，並不是語言本身。你能處理並行的選項並不限於語言或標準函式庫，你可以寫出你自己的並行功能或使用其他人提供的。</p>
<p>然而，還有有兩個並行概念深植於語言中，那就是 <code>std::marker</code> 中的 <code>Sync</code> 與 <code>Send</code> 特徵。</p>
<h3><a class="header" href="#透過-send-來允許所有權能在執行緒間轉移" id="透過-send-來允許所有權能在執行緒間轉移">透過 <code>Send</code> 來允許所有權能在執行緒間轉移</a></h3>
<p><code>Send</code> 標記特徵（marker traits）指定有實作 <code>Send</code> 特徵的型別才能將其所有權在執行緒間轉移。幾乎所有的 Rust 型別都有 <code>Send</code>，但有些例外。這包含 <code>Rc&lt;T&gt;</code>，此型別沒有 <code>Send</code> 是因爲如果你克隆了 <code>Rc&lt;T&gt;</code> 數值並嘗試轉移克隆的所有權到其他執行緒，會有兩條執行緒可能同時更新引用引用計數。基於此原因，<code>Rc&lt;T&gt;</code> 是用於當你不想要付出執行緒安全效能開銷時而在單一執行緒使用的情況。</p>
<p>因此 Rust 的型別系統與特徵界限確保你無法意外不安全地傳送 <code>Rc&lt;T&gt;</code> 數值到其他執行緒。當我們嘗試範例 16-14 時，我們就會得到錯誤 <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>。當我們切換成有實作 <code>Send</code> 的 <code>Arc&lt;T&gt;</code> 的話，程式碼就能編譯通過。</p>
<p>任何由具有 <code>Send</code> 的型別所組成的型別也都會自動標記爲 <code>Send</code>。幾乎所有原始型別都是 <code>Send</code>，除了我們將在第十九章提及的裸指標（raw pointers）。</p>
<h3><a class="header" href="#透過-sync-來允許多重執行緒存取" id="透過-sync-來允許多重執行緒存取">透過 <code>Sync</code> 來允許多重執行緒存取</a></h3>
<p><code>Sync</code> 標記特徵指定有實作 <code>Sync</code> 的型別都能安全從多個執行緒來引用。換句話說，對於任何型別 <code>T</code>，如果 <code>&amp;T</code>（對 <code>T</code> 的引用）有 <code>Send</code> 的話，<code>T</code> 就是 <code>Sync</code> 的，這代表引用可以安全地傳給其他執行緒。與 <code>Send</code> 類似，原始型別都是 <code>Sync</code>，所以由具有 <code>Sync</code> 的型別所組成的型別也都有 <code>Sync</code>。</p>
<p>智慧指標 <code>Rc&lt;T&gt;</code> 沒有 <code>Sync</code> 的原因和沒有 <code>Send</code> 的原因一樣。<code>RefCell&lt;T&gt;</code> 型別（我們在第十五章提過）與其 <code>Cell&lt;T&gt;</code> 也都沒有 <code>Sync</code>。 <code>RefCell&lt;T&gt;</code> 在執行時的借用檢查實作沒有執行緒安全。智慧指標 <code>Mutex&lt;T&gt;</code> 才有 <code>Sync</code> 並能像你在<a href="ch16-03-shared-state.html#%E5%9C%A8%E6%95%B8%E5%80%8B%E5%9F%B7%E8%A1%8C%E7%B7%92%E9%96%93%E5%85%B1%E4%BA%AB-mutext">「在數個執行緒間共享 <code>Mutex&lt;T&gt;</code>」</a><!-- ignore -->段落看到的那樣用來在多個執行緒間分享存取。</p>
<h3><a class="header" href="#手動實作-send-與-sync-是不安全的" id="手動實作-send-與-sync-是不安全的">手動實作 <code>Send</code> 與 <code>Sync</code> 是不安全的</a></h3>
<p>因爲由具有 <code>Send</code> 與 <code>Sync</code> 的型別組成的型別自動就會有 <code>Send</code> 與 <code>Sync</code>，我們不需要親自實作這些特徵。至於標記特徵，它們甚至沒有任何方法需要實作。它們只是用於強制確保並行相關的不變性。</p>
<p>要手動實作這些特徵會需要實作不安全（unsafe）的 Rust 程式碼。我們會在第十九章討論如何使用不安全的 Rust 程式碼，現在最重要的資訊是要從不具有 <code>Send</code> 與 <code>Sync</code> 的元件來組成新的並行型別需要格外小心才能確保其安全保障。<a href="../nomicon/index.html">「The Rustonomicon」</a> 有更多關於這些保障與如何維持它們的資訊。</p>
<h2><a class="header" href="#總結-12" id="總結-12">總結</a></h2>
<p>這不會是你在本書中最後一次看到並行程式碼，第二十章的專案將會在更實際的場合中使用本章節的概念，而非這裡討論的簡單範例。</p>
<p>如之前提過的，因爲 Rust 語言本身很少處理並行的部分，許多並行解決方案都實作成 crate。這些 crate 通常發展的比標準函式庫還快，所以別忘了到線上尋找目前最先進的 crate 來在多執行緒場合中使用喔。</p>
<p>Rust 標準函式庫提供訊息傳遞的通道與智慧指標，像是 <code>Mutex&lt;T&gt;</code> 與 <code>Arc&lt;T&gt;</code>，能夠在並行環境中安全使用。型別系統與借用檢查器中確保使用這些解決方案的程式碼不會發生資料競爭或是無效引用。一旦你讓你的程式碼能編譯通過後，你可以放心地認定它會開開心心地在多執行緒中執行，並且不會發生任何在其他語言中常見且難以追蹤的程式錯誤。並行程式設計就不再是個令人害怕的概念，無畏無懼地開發並行程式吧！</p>
<p>接下來，我們要討論當你的 Rust 程式成長時，定義出問題並組織解決辦法的慣用方案。除此之外，我們也將討論 Rust 有哪些與物件導向程式設計（object-oriented programming）類似的概念。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch16-04-extensible-concurrency-sync-and-send.md">e5ed971</a></li>
<li>updated: 2020-09-22</li>
</ul>
</blockquote>
<h1><a class="header" href="#rust-的物件導向程式設計特色" id="rust-的物件導向程式設計特色">Rust 的物件導向程式設計特色</a></h1>
<p>物件導向程式設計（Object-oriented programming, OOP）是一種模組化程式的方式，物件的概念始於 1960 年的 Simula。這些物件影響了 Alan Kay 的程式設計架構中物件彼此之間訊息的傳遞。他在 1967 年提出了<em>物件導向程式設計</em>來描述此架構。對於 OOP 的定義有許多種描述，有些定義會將 Rust 歸類爲屬於物件導向的，而有些則不會。在本章節中，我們會探討特定常視爲是物件導向的特色並看看這些特色如何轉換成慣用的 Rust 程式碼。然後我們會向你展示如何在 Rust 中實作物件導向設計模式，並討論這麼做與利用 Rust 自身的優勢實現的版本有何取捨差別。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch17-00-oop.md">e5ed971</a></li>
<li>updated: 2020-09-22</li>
</ul>
</blockquote>
<h2><a class="header" href="#物件導向語言的特色" id="物件導向語言的特色">物件導向語言的特色</a></h2>
<p>對於一個被視爲物件導向的語言該有哪些功能，在程式設計語言社群中並沒有達成共識。Rust 受到許多程式設計理念影響，這當然包括 OOP。舉例來說，我們在第十三章探討了源自於函式語言的特性。同樣地，OOP 語言有一些特定常見特色，諸如物件、封裝（encapsulation）與繼承（inheritance）。讓我們看看這些特色分別是什麼意思以及 Rust 有沒有支援。</p>
<h3><a class="header" href="#物件包含資料與行爲" id="物件包含資料與行爲">物件包含資料與行爲</a></h3>
<p>由 Erich Gamma、Richard Helm、Ralph Johnson 與 John Vlissides（Addison-Wesley Professional, 1994) 所寫的書 <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> 俗稱爲 <em>The Gang of Four</em>，這是本物件導向設計模式的目錄。它是這樣定義 OOP 的：</p>
<blockquote>
<p>物件導向程式由物件所組成。<em>物件</em>會包裝資料以及運作在資料上的行爲。此行爲常稱爲<em>方法（methods）<em>或</em>操作（operations）</em>。</p>
</blockquote>
<p>在此定義下，Rust 是物件導向的，結構體與枚舉擁有資料，而 <code>impl</code> 區塊對結構體與枚舉提供方法。就算有方法的結構體與枚舉不會被稱爲<em>物件</em>，依據 Gang of Four 對物件的定義，它們還是有提供相同的功能。</p>
<h3><a class="header" href="#隱藏實作細節的封裝" id="隱藏實作細節的封裝">隱藏實作細節的封裝</a></h3>
<p>另外一個常和 OOP 相關的概念就是<em>封裝（encapsulation）</em>，這指的是物件的實作細節不會讓使用物件的程式碼取得。因此要與該物件互動的方式是透過它的公開 API，使用物件的程式碼不該有辦法觸及物件內部並直接變更資料的行爲。這讓程式設計師能變更並重構物件內部，無需擔心要變更使用物件的程式碼。</p>
<p>我們在第七章討論過如何控制封裝，我們可以使用 <code>pub</code> 關鍵字來決定程式中的哪些模組、型別、函式與方法要公開出來，且預設一切都是私有的。舉例來說，我們可以定義個結構體 <code>AveragedCollection</code> 並有個欄位包含一個 <code>i32</code> 數值的 vector。此結構體還有個欄位包含 vector 數值的平均值，讓我們不必在每次呼叫時都得重新計算平均值。換句話說，<code>AveragedCollection</code> 會爲我們快取計算出的平均值。範例 17-1 展示了結構體 <code>AveragedCollection</code> 的定義：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-1：結構體 <code>AveragedCollection</code> 有個整數列表與集合中的項目平均值
collection</span></p>
<p>此結構體有 <code>pub</code> 標記所以其他程式碼可以使用它，但結構體內部的欄位是私有的。這在此例中是很重要的，因爲我們希望在有數值加入或移出列表時，平均值也能更新。我們會實作結構體的 <code>add</code>、<code>remove</code> 與 <code>average</code> 方法來達成，如範例 17-2 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span><span class="boring">
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            }
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-2：對 <code>AveragedCollection</code> 實作公開方法 <code>add</code>、<code>remove</code> 與 <code>average</code></span></p>
<p>公開的方法 <code>add</code>、<code>remove</code> 與 <code>average</code> 是存取或修改 <code>AveragedCollection</code> 實例資料的唯一方法。當有個項目透過 <code>add</code> 方法加入或透過 <code>remove</code> 方法移出 <code>list</code> 中時，每個方法會同時呼叫 <code>update_average</code> 方法來更新 <code>average</code> 欄位。</p>
<p>我們讓 <code>list</code> 與 <code>average</code> 欄位維持私有，所以外部的程式碼不可能直接新增或移除 <code>list</code> 欄位的項目。不然的話，<code>average</code> 欄位可能就無法與變更的 <code>list</code> 同步了。<code>average</code> 方法會回傳 <code>average</code> 欄位的數值，讓外部程式碼能夠讀取 <code>average</code> 但不會修改它。</p>
<p>由於我們封裝了 <code>AveragedCollection</code> 結構體的實作細節，我們可以在未來輕鬆變更像是資料結構等內部細節。舉例來說，我們可以用 <code>HashSet&lt;i32&gt;</code> 來替換 <code>list</code> 欄位的 <code>Vec&lt;i32&gt;</code>。只要 <code>add</code>、<code>remove</code> 與 <code>average</code> 的公開方法簽名維持一樣，使用到 <code>AveragedCollection</code> 的程式碼就不需要改變。如果我們讓 <code>list</code> 公開的話，情況可能就不相同了，<code>HashSet&lt;i32&gt;</code> 與 <code>Vec&lt;i32&gt;</code> 有不同的方法來新增和移除項目，所以外部的程式碼如果會直接修改 <code>list</code> 的話，可能會需要做些改變。</p>
<p>如果封裝是物件導向的必備條件的話，Rust 也符合此條件。對程式碼中不同部分使用 <code>pub</code> 可以封裝實作細節。</p>
<h3><a class="header" href="#作爲型別系統與程式碼共享來繼承" id="作爲型別系統與程式碼共享來繼承">作爲型別系統與程式碼共享來繼承</a></h3>
<p>*繼承（Inheritance）*是指一個物件可以繼承其他物件定義的機制，使其可以獲取繼承物件的資料與行爲，不必再定義一次。</p>
<p>如果一個語言一定要有繼承才算物件導向語言的話，那麼 Rust 就不是。在定義結構體時我們無法繼承父結構體欄位的方法實作。然而如果你在程式設計時常常用到繼承的話，依據你想使用繼承的原因，Rust 還是有提供其他方案。</p>
<p>你選擇繼承通常會有兩個主要原因。第一個是想能重複使用程式碼，你可以定義一個型別的特定行爲，然後繼承讓你可以在不同的型別重複使用該實作。爲此你可以使用預設的特徵方法實作來分享 Rust 程式碼，你在範例 10-14 就有看到我們在 <code>Summary</code> 特徵加上的預設 <code>summarize</code> 方法實作。任何有實作 <code>Summary</code> 特徵的型別都不必加上更多程式碼就能有 <code>summarize</code> 可以呼叫。這就類似於父類型（class）實作的方法可以在繼承的子類型擁有該方法實作。我們也可以在實作 <code>Summary</code> 特徵時，覆寫 <code>summarize</code> 方法的預設實作，這就類似於子類型覆寫父類型的方法實作。</p>
<p>另一個想使用繼承的原因與型別系統有關，讓子類型可以視爲父類型來使用。這也稱爲<em>多型（polymorphism）</em>，代表要是數個物件有共享特定特性的話，你可以在執行時彼此替換使用。</p>
<blockquote>
<h3><a class="header" href="#多型" id="多型">多型</a></h3>
<p>對許多人來說，多型就是繼承的代名詞。不過這其實是個更通用的概念，用來指程式碼可適用於多種型別資料。而對繼承來說，這些型別通常都是子類型。</p>
<p>Rust 則是使用泛型來抽象化不同可能的型別，並以特徵界限來加強約束這些型別必須提供的內容。這有時會稱爲<em>限定的參數多型（bounded parametric polymorphism）</em>。</p>
</blockquote>
<p>近年來像繼承這種程式設計的解決方案在許多程式設計語言中都漸漸失寵了，因爲這經常有分享不必要程式碼的風險。子類型不應該永遠分享其父類型的所有特性，但繼承會這樣做。這會讓程式的設計較不具有彈性。這還可能產生不具意義或導致錯誤的子類型方法呼叫，因爲該方法不適用於子類型。除此之外，有些語言只會允許子類型繼承一個類型，進一步限制了程式設計的彈性。</p>
<p>基於這些原因，Rust 採取了不同的方案，使用特徵物件（trait objects）而非繼承。讓我們看看 Rust 的特徵物件如何達成多型。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch17-01-what-is-oo.md">e5ed971</a></li>
<li>updated: 2020-09-23</li>
</ul>
</blockquote>
<h2><a class="header" href="#允許不同型別數值的特徵物件" id="允許不同型別數值的特徵物件">允許不同型別數值的特徵物件</a></h2>
<p>在第八章中，我們提及 vector 其中一項限制是它儲存的元素只能有一種型別。我們在範例 8-10 提出一個替代方案，那就是我們定義 <code>SpreadsheetCell</code> 枚舉且其變體能存有整數、浮點數與文字。這讓我們可以對每個元素儲存不同的型別，且 vector 仍能代表元素的集合。當我們的可變換的項目有固定的型別集合，而且我們在編譯程式碼時就知道的話，這的確是完美的解決方案。</p>
<p>然而，有時我們會希望函式庫的使用者能夠在特定的情形下擴展型別的集合。爲了展示我們如何達成，我們來建立個圖形使用者介面（graphical user interface, GUI）工具範例來遍歷一個項目列表，呼叫其內每個項目的 <code>draw</code> 方法將其顯示在螢幕上，這是 GUI 工具常見的技巧。我們會建立個函式庫 crate 叫做 <code>gui</code>，這會包含 GUI 函式庫的結構體。此 crate 可能會包含一些人們會使用到的型別，像是 <code>Button</code> 或 <code>TextField</code>。除此之外，<code>gui</code> 使用者也能夠建立他們自己的型別來顯示出來。舉例來說，有些開發者可以加上 <code>Image</code> 而其他人可能會加上 <code>SelectBox</code>。</p>
<p>我們在此例中不會實作出整個 GUI 函式庫，但會展示各個元件是怎麼組合起來的。在寫函式庫時，我們無法知道並定義開發者想建立出來的所有型別。但我們知道 <code>gui</code> 需要追蹤許多不同型別的數值，且它需要能夠對這些不同的型別數值呼叫 <code>draw</code> 方法。它不需要知道當我們呼叫 <code>draw</code> 方法時實際發生了什麼事，只需要知道該數值有我們可以呼叫的方法。</p>
<p>在有具盛得語言中，我們可能會定義一個類型（class）叫做 <code>Component</code> 且其有個方法叫做 <code>draw</code>。其他的類型像是 <code>Button</code>、<code>Image</code> 和 <code>SelectBox</code> 等等，可以繼承 <code>Component</code> 以取得 <code>draw</code> 方法。它們可以覆寫 <code>draw</code> 方法來定義它們自己的自訂行爲，但是整個框架能將所有型別視爲像是 <code>Component</code> 實例來對待，並對它們呼叫 <code>draw</code>。但由於 Rust 並沒有繼承，我們需要其他方式來組織 <code>gui</code> 函式庫，好讓使用者可以透過新的型別來擴展它。</p>
<h3><a class="header" href="#定義共同行爲的特徵" id="定義共同行爲的特徵">定義共同行爲的特徵</a></h3>
<p>要定義我們希望 <code>gui</code> 能擁有的行爲，我們定義一個特徵叫做 <code>Draw</code> 並有個方法叫做 <code>draw</code>。然後我們可以定義一個接收*特徵物件（trait object）*的 vector。一個特徵物件會指向有實作指定特徵的型別以及一個在執行時尋找該型別方法的尋找表（look up table）。要建立特徵物件，我們指定一些指標，像是引用 <code>&amp;</code> 或者智慧指標 <code>Box&lt;T&gt;</code>，然後加上 <code>dyn</code> 關鍵字與指定的相關特徵。（我們會在第十九章的<a href="ch19-04-advanced-types.html#%E5%8B%95%E6%85%8B%E5%A4%A7%E5%B0%8F%E5%9E%8B%E5%88%A5%E8%88%87-sized-%E7%89%B9%E5%BE%B5">「動態大小型別與 <code>Sized</code> 特徵」</a><!-- ignore -->段落討論特徵物件必須使用指標的原因）我們可以對泛型或實際型別使用特徵物件。當我們使用特徵物件時，Rust 的型別系統會確保在編譯時該段落使用到的任何數值都有實作特徵物件的特徵。於是我們就不必在編譯時知道所有可能的型別。</p>
<p>我們提到在 Rust 中，我們避免將結構體和枚舉稱爲「物件」，來與其他語言的物件做區別。在結構體或枚舉中，結構你欄位中的資料與 <code>impl</code> 區塊的行爲是分開來的。在其他語言中，資料與行爲會組合成一個概念，也就是所謂的物件。然而特徵物件才比較像是其他語言中的物件，因爲這才會將資料與行爲組合起來。但特徵物件與傳統物件不同的地方在於，我們無法向特徵物件新增資料。特徵物件不像其他語言的物件那麼通用，它們是特別用於對共同行爲產生的抽象概念。</p>
<p>範例 17-3 定義了一個特徵叫做 <code>Draw</code> 以及一個方法叫做 <code>draw</code>：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-3：<code>Draw</code> 特徵的定義</span></p>
<p>此語法和我們在第十章介紹過的特徵定義方式相同。接下來才是新語法用到的地方，範例 17-4 定義了一個結構體叫做 <code>Screen</code> 並持有個 vector 叫做 <code>components</code>。此 vector 的型別爲 <code>Box&lt;dyn Draw&gt;</code>，這是一個特徵物件，這代表 <code>Box</code> 內的任何型別都得有實作 <code>Draw</code> 特徵。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-4：定義結構體 <code>Screen</code> 且有個 <code>components</code> 欄位來持有一個實作 <code>Draw</code> 特徵的特徵物件 vector</span></p>
<p>在 <code>Screen</code> 結構體中，我們定義了一個方法叫做 <code>run</code> 來對其 <code>components</code> 呼叫 <code>draw</code> 方法，如範例 17-5 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-5：<code>Screen</code> 的方法 <code>run</code> 會呼叫每個 <code>component</code> 的 <code>draw</code> 方法</span></p>
<p>這與定義一個結構體並使用附有特徵界限的泛型型別參數的方式不相同。泛型型別參數一次只能替換成一個實際型別，特徵物件則是在執行時允許數個實際型別能填入特徵物件中。舉例來說，我們可以使用泛型型別與特徵界限來定義 <code>Screen</code>，如範例 17-6 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
where
    T: Draw,
{
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-6：<code>Screen</code> 結構體的另種實作方式，它的方法 <code>run</code> 則使用泛型與特徵界限</span></p>
<p>這樣我們會限制 <code>Screen</code> 實例必須擁有一串全是 <code>Button</code> 型別或全是 <code>TextField</code> 型別的列表。如果你只會有同型別的集合，使用泛型與特徵界限的確是比較合適的，因爲其定義就會在編譯時單態化爲使用實際型別。</p>
<p>另一方面，透過使用特徵物件的方法，<code>Screen</code> 實例就能有個同時包含 <code>Box&lt;Button&gt;</code> 與 <code>Box&lt;TextField&gt;</code> 的 <code>Vec&lt;T&gt;</code>。 讓我們看看這如何辦到的，然後我們會討論其對執行時效能的影響。</p>
<h3><a class="header" href="#實作特徵" id="實作特徵">實作特徵</a></h3>
<p>現在我們來加上一些有實作 <code>Draw</code> 特徵的型別。我們會提供 <code>Button</code> 型別。再次重申 GUI 函式庫的實際實作超出了本書的範疇，所以 <code>draw</code> 的本體不會有任何有意義的實作。爲了想像該實作會像是什麼，<code>Button</code> 型別可能會有欄位 <code>width</code>、<code>height</code> 與 <code>label</code>，如範例 17-7 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Screen {
</span><span class="boring">    pub fn run(&amp;self) {
</span><span class="boring">        for component in self.components.iter() {
</span><span class="boring">            component.draw();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 17-7：結構體 <code>Button</code> 實作了 <code>Draw</code> 特徵</span></p>
<p>在 <code>Button</code> 中的 <code>width</code>、<code>height</code> 與 <code>label</code> 欄位會與其他元件不同，像是 <code>TextField</code> 可能就會有前面所有的欄位在加上 <code>placeholder</code> 欄位。每個我們想在螢幕上顯示的型別都會實作 <code>Draw</code> 特徵，但在 <code>draw</code> 方法會使用不同程式碼來定義如何印出該特定型別，像是這裡的 <code>Button</code> 型別（不包含實際 GUI 程式碼，因爲這超出本章範疇）。舉例來說，<code>Button</code> 可能會有額外的 <code>impl</code> 區塊來包含使用者點擊按鈕時該如何反應的方法。這種方法就不適用於 <code>TextField</code>。</p>
<p>如果有人想用我們的函式庫來實作個 <code>SelectBox</code> 結構體並擁有 <code>width</code>、<code>height</code> 與 <code>options</code> 欄位的話，他們也可以對 <code>SelectBox</code> 實作 <code>Draw</code> 特徵，如範例 17-8 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p><span class="caption">範例 17-8：別的 crate 使用 <code>gui</code> 來對 <code>SelectBox</code> 結構體實作 <code>Draw</code> 特徵</span></p>
<p>我們的函式庫使用者現在可以在他們的 <code>main</code> 建立個 <code>Screen</code> 實例。在 <code>Screen</code> 實例中，他們可以透過將 <code>SelectBox</code> 會 <code>Button</code> 放入 <code>Box&lt;T&gt;</code> 來成爲特徵物件並加入元件中。他們接著就可以對 <code>Screen</code> 實例呼叫 <code>run</code> 方法，這會呼叫每個元件的 <code>draw</code> 方法。如範例 17-9 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use gui::Draw;
</span><span class="boring">
</span><span class="boring">struct SelectBox {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    options: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Draw for SelectBox {
</span><span class="boring">    fn draw(&amp;self) {
</span><span class="boring">        // code to actually draw a select box
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use gui::{Button, Screen};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">範例 17-9：使用特徵物件來儲存實作相同特徵的不同型別數值</span></p>
<p>我們在寫函式庫時，我們並不知道有人會想要新增 <code>SelectBox</code> 型別，但我們的 <code>Screen</code> 實作能夠運用新的型別並顯示出來，因爲 <code>SelectBox</code> 有實作 <code>Draw</code> 特徵，這代表它就有實作 <code>draw</code> 方法。</p>
<p>這種只在意數值回應的訊息而非數值實際型別的概念，類似於動態型別語言中*鴨子型別（duck typing）*的概念。如果它走起來像隻鴨子、叫起來像隻鴨子，那它必定是隻鴨子！在範例 17-5 中 <code>Screen</code> 的 <code>run</code> 實作不需要知道每個元件的實際型別爲何。它不會檢查一個元件是 <code>Button</code> 還是 <code>SelectBox</code> 實例，它只會呼叫元件的 <code>draw</code> 方法。透過指定 <code>Box&lt;dyn Draw&gt;</code> 來作爲 <code>components</code> vector 中的數值型別，我們定義 <code>Screen</code> 需要我們能夠呼叫 <code>draw</code> 方法的數值。</p>
<p>我們使用特徵物件與 Rust 型別系統能寫出類似鴨子型別的程式碼，這樣的優勢在於我們在執行時永遠不必檢查一個數值有沒有實作特定方法，或擔心我們會不會呼叫了一個沒有實作該方法的數值而產生錯誤。如果數值沒有實作特徵物件要求的特徵的話，Rust 不會編譯通過我們的程式碼。</p>
<p>舉例來說，範例 17-10 展示了要是我們嘗試使用 <code>String</code> 作爲元件來建立 <code>Screen</code> 的話會發生什麼事：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![Box::new(String::from(&quot;Hi&quot;))],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">範例 17-10：嘗試使用沒有實作特徵物件的特徵的型別</span></p>
<p>我們會因爲 <code>String</code> 沒有實作 <code>Draw</code> 特徵而得到錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
 --&gt; src/main.rs:5:26
  |
5 |         components: vec![Box::new(String::from(&quot;Hi&quot;))],
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `gui::Draw` is not implemented for `std::string::String`
  |
  = note: required for the cast to the object type `dyn gui::Draw`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
</code></pre>
<p>此錯誤讓我們知道要麼我們傳遞了不希望傳給 <code>Screen</code> 的型別所以應該要傳遞其他型別，要麼我們應該要對 <code>String</code> 實作 <code>Draw</code>，這樣 <code>Screen</code> 才能對其呼叫 <code>draw</code>。</p>
<h3><a class="header" href="#特徵物件執行動態調度" id="特徵物件執行動態調度">特徵物件執行動態調度</a></h3>
<p>回想一下第十章的<a href="ch10-01-syntax.html#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%95%88%E8%83%BD">「使用泛型的程式碼效能」</a><!-- ignore -->段落我們討論過，當我們對泛型使用閉包時，編譯器會執行單態化（monomorphization）的過程。編譯器會在我們對每個用泛型型別參數取代的實際型別產生非泛型的函式與方法實作。單態化產生程式碼的動作會稱爲「靜態調度（static dispatch）」，這代表編譯器在編譯時知道我們呼叫的方法爲何。與其相反的則是<em>動態調度（dynamic dispatch）</em>，這種方式時編譯器在編譯時無法知道你呼叫的方法爲何。在動態調度的情況下，編譯器會生成在執行時能夠確定會呼叫何種方法的程式碼。</p>
<p>當我們使用特徵物件時，Rust 必須使用動態調度。編譯器無法知道使用特徵物件的程式碼會使用到的所有型別爲何，所以它會不知道該呼叫哪個型別的哪個實作方法。取而代之的是，Rust 在執行時會使用特徵物件內部的指標來知道該呼叫哪個方法。這樣尋找的動作會產生靜待調度所沒有的執行時開銷。動態調度也讓編譯器無法選擇內聯（inline）方法的程式碼，這樣會因而阻止一些優化。不過我們的確對範例 17-5 的程式碼增加了額外的彈性，並能夠支援範例 17-9，所以這是個權衡取捨。</p>
<h3><a class="header" href="#特徵物件要求物件安全" id="特徵物件要求物件安全">特徵物件要求物件安全</a></h3>
<p>特徵物件只能使用*物件安全（object-safe）*的特徵。Rust 會有一些複雜的規則來檢測其屬性以確保特徵物件安全，不過實際上，我們只需要在意兩條規則。如果特徵定義的所有方法撙守以下屬性的話，該特徵就是物件安全的：</p>
<ul>
<li>回傳值不是 <code>Self</code>。</li>
<li>沒有泛型型別參數。</li>
</ul>
<p><code>Self</code> 關鍵字是我們所實作特徵或方法的型別的別名。特徵物件必須是物件安全的，因爲一旦你使用特徵物件後，Rust 就無法知道實作該特徵的型別爲何。如果特徵方法回傳實際 <code>Self</code> 型別，但特徵物件忘記 <code>Self</code> 的確切型別的話，, 該方法不可能有辦法使用原本的實際型別。同理對於泛型型別參數來說，當特徵被使用到時，其就會填入實際的型別參數，實際型別變成了實作特徵的型別的一部分。當型別被使用的特徵物件遺忘時，就無從得知該填素何種泛型型別參數。</p>
<p>標準函式庫中其中一個不是物件安全的特徵範例是 <code>Clone</code> 特徵。<code>Clone</code> 特徵中的 <code>clone</code> 方法簽名長得像這樣：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p><code>String</code> 型別有實作 <code>Clone</code> 特徵，而當我們呼叫 <code>String</code> 實例的 <code>clone</code> 方法時，我們會取得 <code>String</code> 的實例。同樣地，如果我們呼叫 <code>Vec&lt;T&gt;</code> 的 <code>clone</code>，我們就會得到 <code>Vec&lt;T&gt;</code> 的實例。<code>clone</code> 的簽名需要知道 <code>Self</code> 的實際型別爲何，因爲這是它的回傳型別。</p>
<p>當你嘗試違反特徵物件的物件安全規則時，編譯器會提醒警告你。舉例來說，假設我們嘗試實作範例 17-4 的 <code>Screen</code> 結構體爲改儲存實作 <code>Clone</code> 特徵的型別而非 <code>Draw</code> 特徵，如以下所示：</p>
<pre><code class="language-rust ignore does_not_compile">pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
}
</code></pre>
<p>我們就會得到此錯誤：</p>
<pre><code class="language-console">$ cargo build
   Compiling gui v0.1.0 (file:///projects/gui)
error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0038`.
error: could not compile `gui`.

To learn more, run the command again with --verbose.
</code></pre>
<p>此錯誤表示你不能這樣在特徵物件使用此特徵。如果你對物件安全的細節有興趣的話，歡迎查閱 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch17-02-trait-objects.md">e5ed971</a></li>
<li>updated: 2020-09-23</li>
</ul>
</blockquote>
<h2><a class="header" href="#實作物件導向設計模式" id="實作物件導向設計模式">實作物件導向設計模式</a></h2>
<p>*狀態模式（state pattern）<em>是種物件導向設計模式。此模式的關鍵在於一個數值會有些內部狀態，會以</em>狀態物件（state objects）*呈現，然後數值的行爲會依據內部狀態而有所改變。狀態物件會分享功能，當然在 Rust 中我們使用結構體與特徵，而不是使用物件與繼承。每個狀態物件負責本身的行爲並監測何時要改變成其他狀態。持有狀態物件的數值不會知道狀態中不同的行爲，或是何時要轉換狀態。</p>
<p>使用狀態模式表示當我們程式的業務需求改變時，我們不需要改變持有狀態的數值或使用其數值的程式碼。我們只需要變更其中一個狀態物件的程式碼來改變其規則，或者新增更多狀態物件。讓我們看看狀態設計模式的範例，以及如何在 Rust 中使用。</p>
<p>我們會漸進式地實作一個網誌文章工作流程。網誌最終的功能會長得像這樣：</p>
<ol>
<li>網誌文章從空白草稿開始。</li>
<li>當草稿完成時，請求審核文章。</li>
<li>當文章通過時，它就會被發佈。</li>
<li>只有發佈的網誌文章內容會顯示出來，所以沒被通過的文章不會被意外顯示出來。</li>
</ol>
<p>其他任何對文章的修改不會有任何影響。舉例來說，如果我們嘗試在請求審核一個文章前，通過其他網誌文章草稿的話，該文章應維持未發佈的狀態。</p>
<p>此範例顯示了此工作流程的程式碼形式，這是個會用到我們等等會實作的函式庫 crate <code>blog</code> API 的範例。這目前還無法編譯，因爲我們還沒有實作 <code>blog</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">範例 17-11：展示我們所希望的 <code>blog</code> crate 預期行爲的程式碼</span></p>
<p>我們想要讓使用者能透過 <code>Post::new</code> 來建立新的網誌文章草稿，然後我們希望在草稿階段時能對網誌文章加入文字。如果我們想在通過前立即取得文章內容的話，我們什麼都不會看到，因爲該文章還只是個草稿。我們加入的 <code>assert_eq!</code> 在此只是作爲解釋目的。更好地做法是寫個判定網誌文章草稿是否會從 <code>content</code> 方法回傳空字串的單元測試，不過我們在此例不會寫任何測試。</p>
<p>接著，我們想要請求文章審核，且我們希望在等待審核時 <code>content</code> 仍是回傳空字串。當文章通過時，它就會被發佈，代表當 <code>content</code> 呼叫時，文章中的文字就會回傳。</p>
<p>注意到我們要使用此 crate 時只會接觸到到一個型別 <code>Post</code>。此型別會使用狀態模式，並持有個數值能包含三種狀態物件其中之一，來代表文章狀態可以是擬稿中、等待審核或已發佈。變更狀態由 <code>Post</code> 型別內部管理。狀態依據函式庫使用者對 <code>Post</code> 實例呼叫的方法而改變，但他們不用手動管理狀態的變更。而且使用者也不可能會在狀態中出錯，像是在審核前就發佈文章。</p>
<h3><a class="header" href="#定義-post-並在草稿階段建立新實例" id="定義-post-並在草稿階段建立新實例">定義 <code>Post</code> 並在草稿階段建立新實例</a></h3>
<p>讓我們開始實作出函式庫吧！我們知道我們需要一個公開的結構體 <code>Post</code> 來存有些內容，所以我們先從結構體的定義開始，它會有個公開的關聯函式 <code>new</code> 來建立 <code>Post</code> 的實例，如範例 17-12 所示。我們還會再定義一個私有的特徵 <code>State</code>。然後 <code>Post</code> 會有個私有欄位 <code>state</code> 來擁有 <code>Option&lt;T&gt;</code> 且其內會存有一個特徵物件 <code>Box&lt;dyn State&gt;</code>。你會在之後瞭解爲何 <code>Option&lt;T&gt;</code> 在此是必要的。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-12：<code>Post</code> 結構體、能建立新的 <code>Post</code> 實例的 <code>new</code> 函式、<code>State</code> 特徵與 <code>Draft</code> 結構體的定義</span></p>
<p><code>State</code> 定義了不同文章狀態共享的行爲，而且<code>Draft</code>、<code>PendingReview</code> 與 <code>Published</code> 狀態都會實作 <code>State</code> 特徵。目前特徵還沒有任何方法，而且我們也只先定義 <code>Draft</code> 狀態，因爲這是文章的初始狀態。</p>
<p>當我們建立新的 <code>Post</code>，我們對其 <code>state</code> 欄位給予存有 <code>Box</code> 的 <code>Some</code> 數值。此 <code>Box</code> 會指向一個新的 <code>Draft</code> 結構體實例。這確保每當我們建立 <code>Post</code> 的新實例時，它會從草稿起始。因爲 <code>Post</code> 的 <code>state</code> 欄位是私有的，我們沒有任何方法可以建立處於其他狀態的 <code>Post</code>！在 <code>Post::new</code> 函式中，我們設置 <code>content</code> 欄位爲一個新的空 <code>String</code>。</p>
<h3><a class="header" href="#儲存文章內容的文字" id="儲存文章內容的文字">儲存文章內容的文字</a></h3>
<p>範例 17-11 展示我們想要能夠呼叫一個叫做 <code>add_text</code> 的函式並傳入 <code>&amp;str</code> 來對網誌文章增加文字內容。我們實作此方法，而不是將 <code>content</code> 欄位透過 <code>pub</code> 公開出去。這代表我們之後可意實作個方法來控制 <code>content</code> 欄位資料該怎麼讀取。<code>add_text</code> 方法非常直觀，所以讓我們在 <code>impl Post</code> 區塊中加上範例 17-13 的實作吧：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 17-13：實作 <code>add_text</code> 方法來將文字加入文章的 <code>content</code> 中</span></p>
<p><code>add_text</code> 方法接收 <code>self</code> 的可變引用，因爲我們在呼叫 <code>add_text</code> 時會改變 <code>Post</code> 實例。然後我們對 <code>content</code> 中的 <code>String</code> 呼叫<code>push_str</code>，並傳入 <code>text</code> 引數來存到 <code>content</code> 之中。此行爲與文章的狀態無關，所以它沒有被包含在狀態模式中。<code>add_text</code> 方法不會與 <code>state</code> 欄位有關係，但它是我們想支援的部分行爲之一。</p>
<h3><a class="header" href="#確保文章草稿的內容爲空" id="確保文章草稿的內容爲空">確保文章草稿的內容爲空</a></h3>
<p>儘管我們已經能透過 <code>add_text</code> 來爲我們的文章加些內容，但我們還是希望 <code>content</code> 方法會回傳空字串 slice，因爲文章還在草稿階段中，如範例 17-11 的第七行所示。現在先讓我們用能滿足需求最簡單的方式來實作 <code>content</code> 方法，也就是永遠回傳空字串 slice。之後一旦我們實作出能改變文章狀態爲已發佈的能力，我們會回來修改這部分。目前文章只能處於草稿階段，所以文章內容應該要永遠爲空。範例 17-14 顯示了此暫時的實作方式：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 17-14：<code>Post</code> 暫時實作的 <code>content</code> 方法，這會永遠回傳一個空字串 slice</span></p>
<p>透過此 <code>content</code> 方法，範例 17-11 的程式碼到地七行都能如期執行。</p>
<h3><a class="header" href="#請求文章審核來變更它的狀態" id="請求文章審核來變更它的狀態">請求文章審核來變更它的狀態</a></h3>
<p>接下來，我們需要增加請求文章審核的功能，這會將其狀態從 <code>Draft</code> 變更爲 <code>PendingReview</code>。如範例 14-15 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 17-15：對 <code>Post</code> 與 <code>State</code> 特徵實作的 <code>request_review</code> 方法</span></p>
<p><code>Post</code> 現在有個公開方法叫做 <code>request_review</code>，這會接收 <code>self</code> 的可變引用。然後我們對 <code>Post</code> 目前的狀態呼叫其內部的 <code>request_review</code> 方法，然後此 <code>request_review</code> 方法會消耗目前的狀態並回傳新的狀態。</p>
<p>我們對 <code>State</code> 特徵也加上了 <code>request_review</code> 方法，所有有實作此特徵的型別現在都需要實作 <code>request_review</code> 方法。注意到不同於擁有 <code>self</code>、<code>&amp;self</code> 或 <code>&amp;mut self</code> 來作爲方法的第一個參數，我們用的是 <code>self: Box&lt;Self&gt;</code>。此語法代表對持有型別的 <code>Box</code> 呼叫方法才有效。此語法取得 <code>Box&lt;Self&gt;</code> 的所有權，將舊的狀態無效化，讓 <code>Post</code> 的狀態數值可以轉換成新的狀態。</p>
<p>要消耗掉舊的狀態，<code>request_review</code> 方法需要取得狀態數值的所有權。這正是 <code>Post</code> 的 <code>state</code> 欄位中使用 <code>Option</code> 的用途，我們呼叫 <code>take</code> 方法來取得 <code>state</code> 欄位中 <code>Some</code> 的數值，並留下 <code>None</code>，因爲 Rust 不允許結構體的欄位爲空。這讓我們將 <code>Post</code> 的 <code>state</code> 移出來，而不只是借用。然後我們會將文章 <code>state</code> 數值設爲此運算的結果。</p>
<p>我們需要暫時將 <code>state</code> 設爲 <code>None</code>，而非只是像這樣 <code>self.state = self.state.request_review();</code> 直接設置來取得 <code>state</code> 的數值。這確保 <code>Post</code> 不會在我們轉換到新狀態時，使用到舊的 <code>state</code> 數值。</p>
<p><code>Draft</code> 的 <code>request_review</code> 方法需要回傳一個新的結構體 <code>PendingReview</code> box 實例，這代表文章正在等待審核的狀態。<code>PendingReview</code> 結構體也實作了 <code>request_review</code> 方法但沒有做任何轉換。反之，它只會回傳自己，因爲當我們向已經處於 <code>PendingReview</code> 狀態的文章請求審核的話，它應該會維持 <code>PendingReview</code> 的狀態。</p>
<p>現在我們可以開始看出狀態模式的優勢了，<code>Post</code> 的 <code>request_review</code> 方法不管其 <code>state</code> 數值爲何都是一樣的。每個狀態負責自己的規則。</p>
<p>我們維持 <code>Post</code> 的方法 <code>content</code> 不變，依然回傳一個空字串 slice。我們現在的 <code>Post</code> 可以處於 <code>PendingReview</code> 狀態與 <code>Draft</code> 狀態，但我們想要 <code>PendingReview</code> 狀態也有相同的行爲。現在範例 17-11 可以運行到第十行了！</p>
<h3><a class="header" href="#新增改變-content-行爲的-approve-方法" id="新增改變-content-行爲的-approve-方法">新增改變 <code>content</code> 行爲的 <code>approve</code> 方法</a></h3>
<p><code>approve</code> 方法會類似於 <code>request_review</code> 方法，它會設置 <code>state</code> 的數值爲目前狀態審核通過時該處於的狀態，如範例 17-16 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &quot;&quot;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-16：對 <code>Post</code> 與 <code>State</code> 特徵實作 <code>approve</code> 方法</span></p>
<p>我們在 <code>State</code> 特徵加上 <code>approve</code> 方法，並新增一個也有實作 <code>State</code> 的新結構體 <code>Published</code> 特徵。</p>
<p>和 <code>request_review</code> 類似，如果我們對 <code>Draft</code> 呼叫 <code>approve</code> 方法，它不會有任何效果，因爲它會回傳 <code>self</code>。當我們對 <code>PendingReview</code> 呼叫 <code>approve</code>，它會回傳一個新的結構體 <code>Published</code> box 實例。<code>Published</code> 也有實作 <code>State</code> 特徵，對於 <code>request_review</code> 方法與 <code>approve</code> 方法，它只會回傳自己，因爲文章在這些情況下都應該維持 <code>Published</code> 狀態。</p>
<p>現在我們需要更新 <code>Post</code> 的 <code>content</code> 方法，如果狀態是 <code>Published</code> 的話，我們想回傳文章的 <code>content</code> 欄位；不然的話，我們仍然回傳一個空字串 slice，如範例 17-17 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 17-17：更新 <code>Post</code> 的 <code>content</code> 方法來呼叫 <code>State</code> 的 <code>content</code> 方法</span></p>
<p>因爲目標是將這些所有規則維持在實作 <code>State</code> 的結構體內，我們對 <code>state</code> 呼叫 <code>content</code> 方法並傳遞文章實例（也就是 <code>self</code>）來作爲引數。然後我們的回傳值就是對 <code>state</code> 數值使用 <code>content</code> 的回傳值。</p>
<p>我們對 <code>Option</code> 呼叫 <code>as_ref</code> 方法，因爲我們希望取得 <code>Option</code> 內的數值引用，而不是該值的所有權。因爲 <code>state</code> 的型別是 <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>，當我們呼叫 <code>as_ref</code> 時會回傳 <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code>。如果我們沒有呼叫 <code>as_ref</code> 的話，我們會得到錯誤，因爲我們無法從借用的函式參數 <code>&amp;self</code> 移動 <code>state</code>。</p>
<p>然後我們呼叫 <code>unwrap</code> 方法，我們知道這絕對不會恐慌，因爲我們知道當 <code>Post</code> 的方法完成執行時，它們會確保 <code>state</code> 永遠包含一個 <code>Some</code> 數值。這是我們在第九章的<a href="ch09-03-to-panic-or-not-to-panic.html#%E7%95%B6%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E6%AF%94%E7%B7%A8%E8%AD%AF%E5%99%A8%E9%82%84%E5%A4%9A%E7%9A%84%E6%99%82%E5%80%99">「當你知道的比編譯器還多的時候」</a><!-- ignore -->段落介紹過的其中一種情況。雖然編譯器不能理解，但我們知道永遠不可能會有 <code>None</code> 數值。</p>
<p>此時當我們呼叫 <code>&amp;Box&lt;dyn State&gt;</code> 的 <code>content</code>，強制解引用（deref coercion）對 <code>&amp;</code> 與 <code>Box</code> 產生影響，讓 <code>content</code> 方法最終對有實作 <code>State</code> 特徵的型別呼叫。這代表我需要在 <code>State</code> 特徵定義加上 <code>content</code>，而這正是我們要填入依據狀態爲何來回傳何種內容的地方，如範例 17-18 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-18：在 <code>State</code> 特徵加上 <code>content</code> 方法</span></p>
<p>我們對 <code>content</code> 方法加上預設實作來回傳一個空字串 slice。這代表我們不需要在 <code>Draft</code> 與 <code>PendingReview</code> 結構體實作 <code>content</code>。<code>Published</code> 結構體會覆寫 <code>content</code> 方法並回傳 <code>post.content</code> 的數值。</p>
<p>注意到我們在此方法需要生命週期詮釋，如我們在第十章所討論到的。我們取得 <code>post</code> 的引用作爲引數並回傳 <code>post</code> 的部分引用，所以回傳引用的生命週期與 <code>post</code> 引數的生命週期有關聯。</p>
<p>這樣就完成了！範例 17-11 可以成功執行！我們實作了網誌文章工作流程規則的狀態模式。規則邏輯會位於狀態物件中，而不會分散在 <code>Post</code> 中。</p>
<h3><a class="header" href="#狀態模式的權衡取捨" id="狀態模式的權衡取捨">狀態模式的權衡取捨</a></h3>
<p>我們展示了 Rust 能夠實作出物件導向狀態模式，來封裝文章每個狀態之間不同的行爲。<code>Post</code> 的方法不會知道這些不同的行爲。我們組織程式碼的方式，讓我們可以只看一個地方就能知道已發佈文章會擁有的各種行爲，也就是實作 <code>State</code> 特徵的 <code>Published</code> 結構體。</p>
<p>如果我們要建立個不使用狀態模式的替代實作，我們可能會在 <code>Post</code> 或甚至在 <code>main</code> 程式碼中改使用 <code>match</code> 表達式檢查文章狀態並變更行爲。這意味著我們得查看許多地方才能知道已發佈文章狀態的含義！而且當我們增加的狀態越多，每個 <code>match</code> 表達式就需要更多分支。</p>
<p>透過狀態模式，<code>Post</code> 方法以及我們使用 <code>Post</code> 的地方就不需要 <code>match</code> 表達式，而且要加入新的狀態的話，我們只需要新增一個結構體並對其實作特徵方法。</p>
<p>使用狀態模式的實作能非常容易地擴展功能。爲了觀察維護使用狀態模式的程式碼有多簡單，你可以嘗試以下一些建議：</p>
<ul>
<li>新增一個 <code>reject</code> 方法讓文章狀態從 <code>PendingReview</code> 變回 <code>Draft</code>。</li>
<li>要求要呼叫兩次 <code>approve</code> 狀態才會變成 <code>Published</code>。</li>
<li>只允許使用者在 <code>Draft</code> 狀態才能新增文字內容。提示：讓狀態物件負責內容會發生什麼改變，但不負責修改 <code>Post</code>。</li>
</ul>
<p>不過狀態模式有個劣勢，由於狀態實作狀態的轉換，有些狀態之間是彼此耦合的。如果我們在 <code>PendingReview</code> 與 <code>Published</code> 之間再加上另一個狀態像是 <code>Scheduled</code> 的話，我們就需要變更 <code>PendingReview</code> 的程式碼改轉換成
<code>Scheduled</code>。如果 <code>PendingReview</code> 不需要因爲新狀態的加入做改變的話，我們可以少寫些程式碼，但這就意味著切換成其他種設計模式。</p>
<p>另一項劣勢是我們重複了一些邏輯。要消除掉一些重複的部分，我們可以是著對 <code>State</code> 的 <code>request_review</code> 和 <code>approve</code> 方法提供回傳 <code>self</code> 的預設實作。但是這樣就違反物件安全了，因爲特徵不知道 <code>self</code> 的實際型別爲何。我們想要能將 <code>State</code> 用在特徵物件中，所以它的方法必須是物件安全的。</p>
<p>另一個重複的部分包含 <code>Post</code> 的 <code>request_review</code> 與 <code>approve</code> 方法都以類似的方式實作。兩者均呼叫 <code>state</code> 欄位中 <code>Option</code> 內數值對應的相同方法。如果 <code>Post</code> 有很多方法都遵循這樣的模式的話，我們可以考慮定義巨集（macro）來消除重複的部分（請查閱第十九章的<a href="ch19-06-macros.html#macros">「巨集」</a><!-- ignore -->段落）。</p>
<p>如其他物件導向語言所定義的來實作狀態模式，我們並沒有完全發揮出 Rust 的所有潛力。讓我們看看我們能對 <code>blog</code> crate 做些什麼改善，讓無效的狀態與轉換會產生成編譯時錯誤。</p>
<h4><a class="header" href="#定義狀態與行爲成型別" id="定義狀態與行爲成型別">定義狀態與行爲成型別</a></h4>
<p>我們會向你展示如何重新思考狀態模式，來達到不同的取捨效果。與其完全封裝狀態與轉換，讓外部程式碼完全看不到它們，我們會將狀態定義成不同的型別。這樣一來，Rust 的型別檢查系統就能避免在只能使用已發佈文章的地方使用到了文章草稿，並在編譯時就回傳錯誤。</p>
<p>讓我們先想一下範例 17-11 中 <code>main</code> 的第一個部分：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!(&quot;&quot;, post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
</span>}
</code></pre>
<p>我們仍使用 <code>Post::new</code> 來建立新文章的草稿狀態以及能對文章內容新增文字的能力。但不同於在文章草稿的 <code>content</code> 方法中回傳空字串，我們這次選擇文章草稿不會實作 <code>content</code> 方法。這樣如果我們嘗試取得文章草稿內容時，我們會得到編譯錯誤告訴我們該方法不存在。如此一來，我們就不可能在生產環境意外顯示出文章草稿內容了，因爲程式碼根本不會編譯過。範例 17-19 顯示了 <code>Post</code> 結構體與 <code>DraftPost</code> 結構體的定義，以及它們個別的方法：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-19：<code>Post</code> 有 <code>content</code> 方法，而 <code>DraftPost</code> 則沒有 <code>content</code> 方法</span></p>
<p><code>Post</code> 與 <code>DraftPost</code> 結構體都有個私有欄位 <code>content</code> 來儲存網誌文章文字。結構體不再有 <code>state</code> 欄位，因爲我們將狀態的定義移到了結構體的型別中。<code>Post</code> 結構體就代表已發佈的文章，且其有個 <code>content</code> 方法來回傳 <code>content</code>。</p>
<p>我們仍然有 <code>Post::new</code> 函式，但是它沒有回傳 <code>Post</code> 實例，而是回傳了 <code>DraftPost</code> 的實例。因爲 <code>content</code> 是私有的，而且沒有任何函式回傳 <code>Post</code>，所以目前沒有任何辦法能建立 <code>Post</code> 的實例。</p>
<p><code>DraftPost</code> 結構體有個 <code>add_text</code> 方法，所以我們可以像之前一樣爲 <code>content</code> 新增文字，但注意到 <code>DraftPost</code> 沒有定義 <code>content</code> 方法！所以現在程式確保所有文章都已草稿爲起始，而且文章草稿不會提供顯示其內容的方法。任何想嘗試繞過此限制的方式都會產生變意錯誤。</p>
<h4><a class="header" href="#透過不同型別的轉移來實作狀態轉換" id="透過不同型別的轉移來實作狀態轉換">透過不同型別的轉移來實作狀態轉換</a></h4>
<p>所以我們該怎麼取得發佈的文章呢？我們想要遵守執行的規則，文章草稿在審核並通過後才能夠發佈。在審核中的文章狀態應保持不顯示任何內容。讓我們新增另一個結構體 <code>PendingReviewPost</code> 來遵守這些限制吧。在 <code>DraftPost</code> 中訂一個會回傳 <code>PendingReviewPost</code> 的 <code>request_review</code> 方法，再對 <code>PendingReviewPost</code> 定義 <code>approve</code> 方法來回傳 <code>Post</code>，如範例 17-20 所示：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 17-20：呼叫 <code>DraftPost</code> 的 <code>request_review</code> 來建立 <code>PendingReviewPost</code>，且其有個 <code>approve</code> 方法能將 <code>PendingReviewPost</code> 轉換成已發佈的 <code>Post</code></span></p>
<p><code>request_review</code> 與 <code>approve</code> 方法都會取得 <code>self</code> 的所有權，因此會消耗 <code>DraftPost</code> 與 <code>PendingReviewPost</code> 實例，並分別轉換成 <code>PendingReviewPost</code> 與已發佈的 <code>Post</code>。這樣在我們呼叫 <code>request_review</code> 時，就不會有殘留的 <code>DraftPost</code> 實例，以此類推。<code>PendingReviewPost</code> 結構體也沒有定義 <code>content</code> 方法，所以嘗試讀取其內容會導致編譯錯誤，就如同 <code>DraftPost</code>。由於唯一能取得有 <code>content</code> 方法定義的已發佈 <code>Post</code> 是透過呼叫 <code>PendingReviewPost</code> 的 <code>approve</code> 方法，而唯一能取得 <code>PendingReviewPost</code> 的方法是呼叫 <code>DraftPost</code> 的 <code>request_review</code> 方法，我們現在將網誌文章工作流程寫進了型別系統中。</p>
<p>但我們也得對 <code>main</code> 做些小修改。<code>request_review</code> 與 <code>approve</code> 方法會回傳新的實例，而不是修改它們所呼叫的結構體，所以我們需要加些 <code>let post =</code> 來遮蔽賦值來儲存回傳的實例。我們也無法判定草稿與審核中的文章內容是否是空字串，不過我們其實也不需要它們，我們不再能編譯嘗試讀取這些狀態文章內容的程式碼了。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">範例 17-21：修改 <code>main</code> 來使用新的網誌文章工作流程實作</span></p>
<p>我們修改 <code>main</code> 來重新賦值 <code>post</code> 意味著此實作不再遵循物件導向狀態模式了，狀態的轉換不再完全封裝在 <code>Post</code> 實作內部。然而我們得到的好處是的是無效狀態是不可能發生的了，這都多虧了型別系統與編譯時型別檢查！這確保了特定程式錯誤會在進入生產環境前就被察覺，像是顯示尚未發佈的文章內容。</p>
<p>你可以試試看在範例 17-20 之後，對 <code>blog</code> crate 實作我們在此段落稍早提及的額外需求任務建議，來看看你覺得此版本的程式碼設計如何。注意有些任務很可能在此設計就已經實作完成了。</p>
<p>我們看到儘管 Rust 能夠實作物件導向設計模式、其他像是將狀態寫入型別系統中的模式在 Rust 中也是可行的。這些模式有不同的取捨。雖然你可能非常熟悉物件導向模式，但重新思考問題，並善用 Rust 的特色可以帶來不少優勢，像是在執行時就避免錯誤發生。物件導向模式在 Rust 中不會永遠是最好的解決方案，因爲 Rust 有像是所有權這樣物件導向語言所沒有的特定功能。</p>
<h2><a class="header" href="#總結-13" id="總結-13">總結</a></h2>
<p>無論你讀完此章後，認爲 Rust 是否屬於物件導向語言，你知道在 Rust 中你可以使用特徵物件來取得一些物件導向的特色。動態分配能給予你的程式碼更多的彈性，但會犧牲一點執行時效能。你可以使用此彈性來實作物件導向模式，幫助提升程式碼可維護性。Rust 還有其他像是所有權等物件導向語言所沒有的功能。物件導向模式不會永遠是善用 Rust 潛能的最佳方案，不過仍是個不錯的選項。</p>
<p>接下來，我們要看看模式（patterns），這是 Rust 另一個可以提供大量彈性的功能。我們在書中一路下來簡單看過它們好幾次了，不過我們還沒見識到它們全部的本事。讓我們來探索吧！</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch17-03-oo-design-patterns.md">e5ed971</a></li>
<li>updated: 2020-09-24</li>
</ul>
</blockquote>
<h1><a class="header" href="#模式與配對" id="模式與配對">模式與配對</a></h1>
<p>模式（Patterns）是 Rust 中的特殊語法，能用來配對複雜與簡單的型別結構。搭配 <code>match</code> 表達式與其他結構來使用模式的話，可以給予你對程式控制流更多的掌控權。模式與以下元件組合而成：</p>
<ul>
<li>字面值（Literals）</li>
<li>解構的陣列、枚舉結構體或元組</li>
<li>變數</li>
<li>通配符（Wildcards）</li>
<li>佔位符（Placeholders）</li>
</ul>
<p>這些元件描述了我們要處理的資料行狀，讓我們可以與其數值配對來決定我們的程式是否有取得正確的資料來繼續執行特定部分的程式碼。</p>
<p>要是永模式，我們將其與一些數值做比較。如果模式配對到數值的話，我們就能在程式碼中使用該數值部分。回憶一下第六章中使用模式的 <code>match</code> 表達式，像是硬幣分類機器的範例。如果有數值符合模式的行狀，我們就可以使用這些命名的部分。如果沒有的話，配對相關的程式碼就不會執行。</p>
<p>本章節會涵蓋所有與模式相關的內容。我們會討論能使用模式的地方，可反駁（refutable）與不可反駁（irrefutable）模式間的差別，以及不同種類的模式語法。在本章結束後，你便能知道如何使用模式來清楚表達許多概念。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch18-00-patterns.md">e5ed971</a></li>
<li>updated: 2020-09-24</li>
</ul>
</blockquote>
<h2><a class="header" href="#所有能使用模式的地方" id="所有能使用模式的地方">所有能使用模式的地方</a></h2>
<p>模式常出現於 Rust 中數個位置，而你已經不經意使用了很多模式了！此段落會介紹所有模式能有效出現的地方。</p>
<h3><a class="header" href="#match-分支" id="match-分支"><code>match</code> 分支</a></h3>
<p>如同第六章所討論過的，我們可以在 <code>match</code> 表達式中的分支使用模式。正式來說，<code>match</code> 表達式的定義爲 <code>match</code> 關鍵字加上一個要配對的數值，然後會有一或數個包含模式的分支，以及如果數值配對到該分支模式之後要執行的表達式，如以下所示：</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p><code>match</code> 表達式有個要求就是它們必須是<em>徹底的（exhaustive）</em>，所有 <code>match</code> 表達式數值可能的結果都必須涵蓋到。其中一個確保你有考慮到所有可能性的方式是在最後一個分支使用捕獲模式，命名一個能配對任何數值的變數就覺不會失敗，因此可以涵蓋剩餘的情況。</p>
<p>還有一個特定模式 <code>_</code> 可以獲取任意可能情況，但它不會綁定到變數中，所以它也很常用在最後的配對分支。舉例來說，<code>_</code> 模式就很適合用來忽略任何沒指明的數值。我們會在本章之後的 <a href="ch18-03-pattern-syntax.html#%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%95%B8%E5%80%BC">「忽略模式中的數值」</a><!-- ignore -->段落談到更多 <code>_</code> 的細節。</p>
<h3><a class="header" href="#if-let-條件表達式" id="if-let-條件表達式"><code>if let</code> 條件表達式</a></h3>
<p>在第六章中我們介紹了如何使用 <code>if let</code> 表達式，它等同於只配對一種情況的 <code>match</code> 表達式，主要作爲更簡潔的語法。此外，<code>if let</code> 可以再加上 <code>else</code> 來包含如果 <code>if let</code> 模式不符的話能執行的程式碼。</p>
<p>範例 18-1 展示了我們能夠混合並配對 <code>if let</code>、<code>else if</code> 與 <code>else if let</code> 表達式。這樣做可以比 <code>match</code> 表達式還來得有彈性，因爲 <code>match</code> 只能有一個數值與模式們配對。另外，<code>if let</code>、<code>else if</code> 與 <code>else if let</code> 分支之間的條件彼此並不需要有關聯。</p>
<p>範例 18-1 的程式碼顯示了一系列的條件檢查來決定背景顏色該爲何。在此例中，我們建立一個寫死的變數數值，在實際程式中應該會由使用者輸入。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-1：混合 <code>if let</code>、<code>else if</code>、<code>else if let</code> 與 <code>else</code></span></p>
<p>如果使用者指定的最喜歡的顏色，該顏色就是背景顏色。如果今天是星期二，背景顏色就是綠色。如果使用者用字串指定他們的年齡且可以成功轉換成數字的話，背景顏色依據數字結果就是紫色或橘色。如果以上條件都不符合的話，背景顏色就是藍色。</p>
<p>這樣的條件結構讓我們可以職員複雜的需求。透過我們在此寫死的數值，此例會印出 <code>Using purple as the background color</code>。</p>
<p>你可以看到 <code>if let</code> 也能如同 <code>match</code> 的分支一樣遮蔽變數，<code>if let Ok(age) = age</code> 這行就產生了新的遮蔽變數 <code>age</code> 來包含 <code>Ok</code> 變體內的數值。這意味著我們需要將 <code>if age &gt; 30</code> 的條件方在區塊內，我們不能組合這兩個條件成 <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>。遮蔽的 <code>age</code> 在大括號開始之後的新作用域才有效，此時才能與 30 做比較。</p>
<p>使用 <code>if let</code> 表達式的缺點是編譯器不會徹底檢查，而 <code>match</code> 表達式則會。如果我們省略最後一個 <code>else</code> 區塊而因此忘了處理一些情況，編譯器不會警告我們這種可能的邏輯錯誤。</p>
<h3><a class="header" href="#while-let-條件迴圈" id="while-let-條件迴圈"><code>while let</code> 條件迴圈</a></h3>
<p>與 <code>if let</code> 的結構類似，<code>while let</code> 條件迴圈允許 <code>while</code> 迴圈只要在模式持續配對符合的情況下一直執行。範例 18-2 的例子展示一個 <code>while let</code> 迴圈使用 vector 最爲堆疊，並以數值被插入 vector 時相反的順序印出它們。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!(&quot;{}&quot;, top);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-2：使用 <code>while let</code> 迴圈，且只要 <code>stack.pop()</code> 有回傳 <code>Some</code> 就持續印出數值</span></p>
<p>此範例會依序顯示 3、2 然後是 1。<code>pop</code> 方法會取得 vector 最後一個數值並回傳 <code>Some(value)</code>。如果 vector 是空的，<code>pop</code> 就回傳 <code>None</code>。只要 <code>pop</code> 有回傳 <code>Some</code>，<code>while</code> 迴圈就會持續執行其區塊中的程式碼。當 <code>pop</code> 回傳 <code>None</code> 時，迴圈就會結束。我們可以使用 <code>while let</code> 來取得堆疊彈出的每個數值。</p>
<h3><a class="header" href="#for-迴圈" id="for-迴圈"><code>for</code> 迴圈</a></h3>
<p>在第三章中，我們提到 <code>for</code> 迴圈是 Rust 程式碼中最常見的迴圈結構，但我們尚未介紹要如何在  <code>for</code> 中使用模式。在 <code>for</code> 迴圈中，<code>for</code> 關鍵字之後的數值就是模式，所以在 <code>for x in y</code> 中 <code>x</code> 就是模式。</p>
<p>範例 19-3 展示了如何在 <code>for</code> 迴圈使用模式來解構或拆開一個 <code>for</code> 迴圈中的元組。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec!['a', 'b', 'c'];

    for (index, value) in v.iter().enumerate() {
        println!(&quot;{} is at index {}&quot;, value, index);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-3：使用模式來解構 <code>for</code> 迴圈中的元組</span></p>
<p>範例 18-3 的程式碼會顯示以下結果：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>我們使用 <code>enumerate</code> 方法來配接一個疊代器來產生一個數值與該數值在疊代器中的索引，並放入元組中。第一次呼叫 <code>enumerate</code> 會產生元組 <code>(0, 'a')</code>。當此數值配對到 <code>(index, value)</code> 模式時，<code>index</code> 會是 <code>0</code> 而 <code>value</code> 會是 <code>'a'</code>，並印出第一行的輸出。</p>
<h3><a class="header" href="#let-陳述式" id="let-陳述式"><code>let</code> 陳述式</a></h3>
<p>在本章節之前，我們只有告訴你模式能用在 <code>match</code> 和 <code>if let</code>，但事實上我們在其他地方也早就使用過模式了，這包含 <code>let</code> 陳述式。舉例來說，請看看以下這個使用 <code>let</code> 賦值變數的直白例子：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>在整本書中，我們已經像這樣使用 <code>let</code> 無數次，而雖然你還沒有察覺到，但你已經使用過模式了！所以更正式地來說，<code>let</code> 陳述式是這樣定義的：</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>像 <code>let x = 5;</code> 這樣的陳述式中變數名稱會爲於 <code>PATTERN</code> 的位置，變數名稱恰好是種特別簡單的模式。Rust 會將表達式與模式做比較，並賦值給它找到的任何名稱。所以在 <code>let x = 5;</code> 的範例中，<code>x</code> 是個模式並表示「將配對到的數值綁定給變數 <code>x</code>」。因爲名稱 <code>x</code> 就是整個模式，此模式實際上等同於「將任何數值綁定給變數 <code>x</code>，無論該數值爲何」。</p>
<p>爲了更清楚理解 <code>let</code> 怎麼使用模式配對，請參考範例 18-4，這對 <code>let</code> 使用模式來解構一個元組。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-4：使用模式來解構元組，並同時建立三個變數</span></p>
<p>我們在此用一個元組來配對一個模式。Rust 會將數值 <code>(1, 2, 3)</code> 與模式 <code>(x, y, z)</code> 做比較，並看出數值能配對到模式中，所以 Rust 將 <code>1</code> 綁定給 <code>x</code>、<code>2</code> 給 <code>y</code> 然後 <code>3</code> 給 <code>z</code>。你可以把此元組模式想成是三個獨立的變數模式組合在一起。</p>
<p>如果模式中的元素數量與元組中的元素數量不符合的話，整體型別就無法配對，所以我們會得到編譯錯誤。舉例來說，範例 18-5 嘗試將有三個元素的元組解構到兩個變數中，這樣就無法成功。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let (x, y) = (1, 2, 3);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 18-5：錯誤的模式結構，因爲變數數量與元組元素數量不符</span></p>
<p>嘗試編譯此程式碼的話，會得到此型別錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected tuple `({integer}, {integer}, {integer})`
             found tuple `(_, _)`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<p>如果我們在元組中想要忽略一或數個數值的話，我們可以使用 <code>_</code> 或 <code>..</code>，你會在<a href="ch18-03-pattern-syntax.html#%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%95%B8%E5%80%BC">「忽略模式中的數值」</a><!-- ignore -->段落中瞭解更多詳情。如果問題出在於我們模式中有太多變數的話，解決辦法就是移除些變數使變數數量等同於元組元素數量，讓型別可以配對。</p>
<h3><a class="header" href="#函式參數-1" id="函式參數-1">函式參數</a></h3>
<p>函式參數也可以是模式。範例 18-6 的程式碼宣告了一個函式叫做 <code>foo</code> 來接收一個參數叫做 <code>x</code> 其型別爲 <code>i32</code>，現在這看起來你應該都還很熟悉。</p>
<pre><pre class="playground"><code class="language-rust">fn foo(x: i32) {
    // code goes here
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 18-6：在參數中使用模式的函式簽名</span></p>
<p><code>x</code> 的部分就是模式！就如同我們在 <code>let</code> 所做的一樣，我們可以在函式引數中使用模式來配對元組，範例 18-7 將傳遞給函式的元組拆爲不同數值。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">範例 18-7：函式透過參數來解構元組</span></p>
<p>此程式碼會顯示 <code>Current location: (3, 5)</code>。數值 <code>&amp;(3, 5)</code> 能配對到模式 <code>&amp;(x, y)</code>，所以 <code>x</code> 會是數值 <code>3</code> 而 <code>y</code> 會是數值 <code>5</code>。</p>
<p>我們還可以在閉包參數列表中像函式參數列表這樣使用模式，因爲第十三章就提過閉包類似於函式。</p>
<p>到目前爲止，你已經見過許多使用模式的方式，但模式在我們能使用的地方並不都會有相同的行爲。在某些地方，模式必須是不可反駁的（irrefutable），而在其他場合它們則是可反駁的（refutable）。接下來我們會來討論這兩個概念。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch18-01-all-the-places-for-patterns.md">e5ed971</a></li>
<li>updated: 2020-09-25</li>
</ul>
</blockquote>
<h2><a class="header" href="#可反駁性何時模式可能會配對失敗" id="可反駁性何時模式可能會配對失敗">可反駁性：何時模式可能會配對失敗</a></h2>
<p>模式有兩種形式：可反駁的（refutable）與不可反駁的（irrefutable）。可以配對任何可能數值的模式屬於<em>不可反駁的（irrefutable）</em>。其中一個例子就是陳述式 <code>let x = 5;</code> 中的 <code>x</code>，因爲 <code>x</code> 可以配對任何數值，因此不可能會配對失敗。而可能會對某些數值配對失敗的模式則屬於<em>可反駁的（refutable）</em>。其中一個例子是表達式 <code>if let Some(x) = a_value</code> 中的 <code>Some(x)</code>，因爲如果 <code>a_value</code> 變數中的數值爲 <code>None</code> 而非 <code>Some</code> 的話， <code>Some(x)</code> 模式就會配對失敗。</p>
<p>函式參數、<code>let</code> 陳述式與 <code>for</code> 迴圈只能接受不可反駁的模式，當數值無法配對時，程式無法作出任何有意義的事。<code>if let</code> 與 <code>while let</code> 表達式接受可反駁與不可反駁的模式，但是編譯器會警告不可反駁的模式，因爲定義上來說它們用來處理可能會失敗的場合，條件表達式的功能就是依據成功或失敗來執行不同動作。</p>
<p>大致上來說，你通常不需要擔心可反駁與不可反駁模式之間的區別，不過你會需要熟悉可反駁性這樣的概念，所以當你看到錯誤訊息時，能及時反應理解。在這樣的場合，你需要依據程式碼的預期行外來改變模式或是使用模式的結構。</p>
<p>讓我們看看當我們嘗試在 Rust 要求不可反駁模式的地方使用可反駁模式的範例與其反例。範例 18-8 顯示了一個 <code>let</code> 陳述式，但是我們指定的模式是 <code>Some(x)</code>，這是可反駁模式。如我們所預期的，此程式碼無法編譯。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    let Some(x) = some_option_value;
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 18-8：嘗試在 <code>let</code> 使用可反駁模式</span></p>
<p>如果 <code>some_option_value</code> 是數值 <code>None</code>，它會無法與模式 <code>Some(x)</code> 做配對，這意味著此模式是可反駁的。但是 <code>let</code> 陳述式只能接受不可反駁的模式，因爲 程式碼對 <code>None</code> 數值就無法作出任何有效的動作。在編譯時 Rust 就會抱怨我們嘗試在需要不可反駁模式的地方使用了可反駁模式：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt; src/main.rs:3:9
  |
3 |     let Some(x) = some_option_value;
  |         ^^^^^^^ pattern `None` not covered
  |
  = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant
  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html
help: you might want to use `if let` to ignore the variant that isn't matched
  |
3 |     if let Some(x) = some_option_value { /* */ }
  |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0005`.
error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<p>因爲 <code>Some(x)</code> 模式沒有涵蓋（且也涵蓋不了！）所有有效的數值，Rust 合理地產生了編譯錯誤。</p>
<p>要修正在需要不可反駁模式的地方使用可反駁模式的錯誤，我們可以變更使用此模式的程式碼，與其使用 <code>let</code>，我們可以改用 <code>if let</code>。這樣如果模式不符的話，程式碼就會跳過大括號鐘的程式碼，讓我們可以繼續有效執行下去。範例 18-9 顯示了如何修正範例 18-8 的程式碼。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let some_option_value: Option&lt;i32&gt; = None;
</span>    if let Some(x) = some_option_value {
        println!(&quot;{}&quot;, x);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-9：使用 <code>if let</code> 而非 <code>let</code> 來使用可反駁模式</span></p>
<p>我們給了程式碼出路！此程式碼可以完美執行，雖然這也代表我們使用不可反駁模式的話會得到一些警告。如果我們給予 <code>if let</code> 一個像是 <code>x</code> 這樣永遠能配對的模式的話，編譯器會出現警告，如範例 18-10 所示。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    if let x = 5 {
        println!(&quot;{}&quot;, x);
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-10：嘗試在 <code>if let</code> 使用不可反駁的模式</span></p>
<p>Rust 會抱怨說在 <code>if let</code> 使用不可反駁的模式沒有任何意義：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
warning: irrefutable if-let pattern
 --&gt; src/main.rs:2:5
  |
2 | /     if let x = 5 {
3 | |         println!(&quot;{}&quot;, x);
4 | |     };
  | |_____^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target/debug/patterns`
5
</code></pre>
<p>基於此原因，<code>match</code> 的分支必須是可反駁模式。除了最後一個分支因爲要配對任何剩餘數值，所以會是不可反駁模式。Rust 允許我們在 <code>match</code> 只使用一個不可反駁模式的分支，不過這樣做並不是很實用，且可以直接用簡單的 <code>let</code> 陳述式取代。</p>
<p>現在你知道哪裡能使用模式，以及可反駁與不可反駁模式的不同了。讓我們來涵蓋模式建立時可以使用的所有語法吧。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch18-02-refutability.md">e5ed971</a></li>
<li>updated: 2020-09-25</li>
</ul>
</blockquote>
<h2><a class="header" href="#模式語法" id="模式語法">模式語法</a></h2>
<p>在整本書中，我們已經看過許多種類的模式範例了。在此段落中，我們會收集所有模式中的有效語法，並討論你會怎麼使用它們。</p>
<h3><a class="header" href="#配對字面值" id="配對字面值">配對字面值</a></h3>
<p>如同你在第六章所見的，你可以直接使用字面值來配對模式，以下程式碼展示了一些範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會顯示 one 因爲 x 的數值爲 1。此語法適用於當你想要程式碼取得一個特定數值時，就馬上採取行動的情況。</p>
<h3><a class="header" href="#配對變數名稱" id="配對變數名稱">配對變數名稱</a></h3>
<p>變數名稱是能配對任何數值的不可反駁模式，而且我們在本書中已經使用非常多次。不過當你在 <code>match</code> 表達式中使用變數名稱時會複雜一點。因為 <code>match</code> 會初始一個新的作用域，作為 <code>match</code> 表達式部分模式的宣告變數會遮蔽 <code>match</code> 結構外同名的變數，和所有變數一樣。在範例 18-11 中，我宣告了一個變數叫做 <code>x</code> 其有數值 <code>Some(5)</code> 和一個變數 <code>y</code> 其有數值 <code>10</code>。然後我們建立一個數值 <code>x</code> 的 <code>match</code> 表達式。檢查配對分之中的模式並在最後用 <code>println!</code> 顯示出來，並嘗試在程式碼執行或進一步閱讀之前推測其會顯示的結果會為何。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-11：<code>match</code> 表達式其中一個分支宣告了遮蔽的變數 <code>y</code></span></p>
<p>讓我們跑一遍看看當 <code>match</code> 執行時發生了什麼事。第一個配對分支並不符合 <code>x</code> 定義的數值，所以程式繼續執行下去。</p>
<p>第二個配對分支宣告了一個新的變數叫做 <code>y</code> 來配對 <code>Some</code> 內的任何數值。因為我們位於 <code>match</code> 表達式內的新作用域，此新的 <code>y</code> 變數並不是我們一開始宣告有數值 10 的 <code>y</code>。這個新的 <code>y</code> 會配對 <code>Some</code> 內的任何數值，，也就是 <code>x</code> 擁有的數值。因此，這個新的 <code>y</code> 會綁定 <code>x</code> 中 <code>Some</code> 的內部數值。該數值是 <code>5</code>，所以該分支的表達式就會執行並印出 <code>Matched, y = 5</code>。</p>
<p>如果 <code>x</code> 是 <code>None</code> 數值而非 <code>Some(5)</code> 的話，前兩個分支的模式都不會配對到，所以數值會配對到底線的分支。我們沒有在底線分支的模式中宣告 <code>x</code> 變數，所以表達式中的 <code>x</code> 仍然是外部沒有被遮蔽的 <code>x</code> 。在這樣的假設狀況下，<code>match</code> 會印出 <code>Default case, x = None</code>。</p>
<p>當 <code>match</code> 完成時，其作用域就會結束，所以作用域內的內部 <code>y</code> 也會結束。最後一個 <code>println!</code> 會顯示 <code>at the end: x = Some(5), y = 10</code>。</p>
<p>要建立個能對外部 <code>x</code> 與 <code>y</code> 數值做比較的 <code>match</code> 表達式而非遮蔽變數的話，我們需要改用條件配對守護。我們會在之後的<a href="ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards">「提供額外條件的配對守護」</a><!-- ignore -->段落討論配對守護。</p>
<h3><a class="header" href="#多重模式" id="多重模式">多重模式</a></h3>
<p>在 <code>match</code> 表達式中，你可以使用 <code>|</code> 語法來配對數個模式，其代表 *OR（或）*的意思。舉例來說，以下程式碼會配對 <code>x</code> 的數值到配對分支，第一個分支有個 <em>OR</em> 的選項，代表如果 <code>x</code> 的數值配對的到分支中任一數值的話，該分支的程式碼就會執行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 1;

    match x {
        1 | 2 =&gt; println!(&quot;one or two&quot;),
        3 =&gt; println!(&quot;three&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼會印出 <code>one or two</code>。</p>
<h3><a class="header" href="#透過--配對數值範圍" id="透過--配對數值範圍">透過 <code>..=</code> 配對數值範圍</a></h3>
<p><code>..=</code> 語法讓我們可以配對一個範圍內包含的數值。在以下程式碼中，當模式配對的到範圍內的任何數值時，該分支就會執行：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;

    match x {
        1..=5 =&gt; println!(&quot;one through five&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>如果 <code>x</code> 是 1、2、3、4 或 5 的話，第一個分支就能配對到。此語法比使用 <code>|</code> 運算子來表達相同概念還輕鬆得多。如果我們使用 <code>|</code> 的話，就得指明 <code>1 | 2 | 3 | 4 | 5</code> 而非 <code>1..=5</code>。指定範圍相對就簡短許多，尤其是如果我們得配對像是數字 1 到 1,000 的話！</p>
<p>範圍只允許使用數字或 <code>char</code> 數值，因為編譯器會在編譯時檢查範圍是否為空。<code>char</code> 與數字數值是 Rust 中唯一能判斷範圍是否為空的型別。</p>
<p>以下是使用 <code>char</code> 數值作為範圍的範例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 'c';

    match x {
        'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
        'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
        _ =&gt; println!(&quot;something else&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p>Rust 可以知道 <code>c</code> 有包含在第一個模式的範圍內，所以印出 <code>early ASCII letter</code>。</p>
<h3><a class="header" href="#解構拆開數值" id="解構拆開數值">解構拆開數值</a></h3>
<p>我們可以使用模式來解構結構體、枚舉、元組與引用，以便使用這些數值的不同部分。讓我們依序來看看。</p>
<h4><a class="header" href="#解構結構體" id="解構結構體">解構結構體</a></h4>
<p>範例 18-12 有個結構體 <code>Point</code> 其有兩個欄位 <code>x</code> 與 <code>y</code>，我們可以在 <code>let</code> 陳述式使用模式來拆開它。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">範例 18-12：解構結構體欄位成獨立的變數</span></p>
<p>此程式碼建立了變數 <code>a</code> 與 <code>b</code> 來配對 <code>p</code> 結構體中 <code>x</code> 與 <code>y</code> 的欄位。此範例顯示出模式中的變數名稱不必與結構體中的欄位名稱一樣。不過通常還是建議變數名稱與欄位名稱一樣，以便記得哪些變數來自於哪個欄位。</p>
<p>因為用變數名稱來配對欄位是十分常見的，而且因為 <code>let Point { x: x, y: y } = p;</code> 會包含許多重複部分，所以配對結構體欄位的模式有另一種簡寫方式，你只需要列出結構體欄位的名稱，這樣從結構體建立的變數名稱就會有相同名稱。範例 18-13 顯示的程式碼行為與範例 18-12 一樣，但是在 <code>let</code> 模式建立的變數是 <code>x</code> 與 <code>y</code> 而非 <code>a</code> 與 <code>b</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">範例 18-13：使用結構體欄位簡寫來解構結構體欄位</span></p>
<p>此程式碼建立了變數 <code>x</code> 與 <code>y</code> 並配對到變數 <code>p</code> 的 <code>x</code> 與 <code>y</code> 欄位。結果就是變數 <code>x</code> 與 <code>y</code> 會包含 <code>p</code> 結構體中的數值。</p>
<p>我們也可以將字面值數值作為結構體模式中的一部分，而不用建立所有欄位的變數。這樣做我們可以在解構一些欄位成變數時，測試其他欄位是否有特定數值。</p>
<p>範例 18-14 的 <code>match</code> 表達式將 <code>Point</code> 的數值分成三種情況：位於 <code>x</code> 軸的點（也就是 <code>y = 0</code>）、位於 <code>y</code> 軸的點（<code>x = 0</code>） 或不在任何軸的點。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-14：解構並配對模式中的字面值數值</span></p>
<p>第一個分支透過指定 <code>y</code> 欄位配對字面值為 <code>0</code> 來配對任何在 <code>x</code> 軸上的點。此模式仍然會建立變數 <code>x</code> 能讓我們在此分支的程式碼中使用。</p>
<p>同樣地，第二個分支透過指定 <code>x</code> 欄位配對字面值為 <code>0</code> 來配對任何在 <code>y</code> 軸上的點，並建立擁有 <code>y</code> 欄位數值的變數 <code>y</code>。 第三個分支沒有指定任何字面值，所以它能配對任何其他 <code>Point</code> 並建立 <code>x</code> 與 <code>y</code> 欄位對應的變數。</p>
<p>在此例中，數值 <code>p</code> 會配對到第二個分支，因為其 <code>x</code> 為 0，所以此程式碼會印出 <code>On the y axis at 7</code>。</p>
<h4><a class="header" href="#解構枚舉" id="解構枚舉">解構枚舉</a></h4>
<p>我們已經在本書中之前的章節就解構過枚舉。舉例來說，第六章的範例 6-5 我們就解構了 <code>Option&lt;i32&gt;</code>。其中一個我們還沒談到的細節是解構枚舉的模式必須與枚舉定義中其所儲存的資料相符。作為示範，我們在範例 18-15 中使用範例 6-2 的 <code>Message</code> 枚舉並寫一個 <code>match</code> 來提供會解構每個內部數值的模式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-15：解構持有不同種數值的枚舉變體</span></p>
<p>此程式碼會印出 <code>Change the color to red 0, green 160, and blue 255</code>。請嘗試變更 <code>msg</code> 的數值來看看其他分支的程式碼會執行出什麼。</p>
<p>對於像是 <code>Message::Quit</code> 這種沒有任何資料的枚舉，我們無法進一步解構出任何資料。我們只能配對其本身的數值 <code>Message::Quit</code>，所以在該模式中沒有任何變數。</p>
<p>對於像是 <code>Message::Move</code> 這種類結構體枚舉變體，我們可以使用類似於指定配對結構體的模式。在變體名稱之後，我們加上大括號以及列出欄位名稱作為變數，讓我們能拆成不同部分並在此分支的程式碼中使用。我們在此使用範例 18-13 一樣的簡寫形式。</p>
<p>對於像是 <code>Message::Write</code> 這種持有一個元素，以及 <code>Message::ChangeColor</code> 這種持有三個元素的類元組枚舉變體，我們可以使用類似於配對元組的模式。模式中的變數數量必須與我們要配對的變體中元素數量相符。</p>
<h4><a class="header" href="#解構巢狀結構體與枚舉" id="解構巢狀結構體與枚舉">解構巢狀結構體與枚舉</a></h4>
<p>到目前為止，我們所有的結構體或枚舉配對範例的深度都只有一層。配對也可以用於巢狀項目中！</p>
<p>舉例來說，我們可以重構範例 18-15 的程式碼，在 <code>ChangeColor</code> 中支援 RGB 與 HSV 顏色，如範例 18-16 所示。</p>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
            h, s, v
        ),
        _ =&gt; (),
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-16：配對巢狀枚舉</span></p>
<p><code>match</code> 表達式的第一個分支模式會配對包含 <code>Color::Rgb</code> 變體的 <code>Message::ChangeColor</code> 枚舉變體，然後該模式會綁定內部三個 <code>i32</code> 數值。第二個分支也是配對到 <code>Message::ChangeColor</code> 枚舉變體，但是內部枚舉會改配對 <code>Color::Hsv</code>。我們可以在一個 <code>match</code> 表達式指定這些複雜條件，即使有兩個枚舉參與其中。</p>
<h4><a class="header" href="#解構結構體與元組" id="解構結構體與元組">解構結構體與元組</a></h4>
<p>我們甚至可以用更複雜的方式來混合、配對並巢狀解構模式。以下範例展示了一個複雜的結構模式，其將一個結構體與一個元組置於另一個元組中，並將所有的原始數值全部解構出來：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    struct Point {
</span><span class="boring">        x: i32,
</span><span class="boring">        y: i32,
</span><span class="boring">    }
</span><span class="boring">
</span>    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>此程式碼讓我們將複雜的型別拆成部分元件，讓我們可以分別使用我們有興趣的數值。</p>
<p>解構模式是個能方便使用部分數值的方式，比如結構體每個欄位分別獨立的數值。</p>
<h3><a class="header" href="#忽略模式中的數值" id="忽略模式中的數值">忽略模式中的數值</a></h3>
<p>你已經看過有時候在模式中忽略數值是很實用的，像是在 <code>match</code> 中的最後一個分支能捕獲所有剩餘用不到的可能數值。模式有一些方式可以忽略所有或部分數值：使用（你已經看過的） <code>_</code> 模式、在其他模式使用 <code>_</code> 模式、在名稱前加上底線，或是使用 <code>..</code> 來忽略剩餘部分的數值。讓我們來探討如何與爲何要使用這些模式吧。</p>
<h4><a class="header" href="#透過-_-忽略整個數值" id="透過-_-忽略整個數值">透過 <code>_</code> 忽略整個數值</a></h4>
<p>我們使用底線在（<code>_</code>）來作爲通配符（wildcard）模式，這會配對任何數值，但不會綁定其值。雖然底線 <code>_</code> 模式特別適合作爲 <code>match</code> 表達式最後一個分支，但我們可以將它用在任何模式中，包含函式參數，如範例 18-17 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">範例 18-17：在函式簽名中使用 <code>_</code></span></p>
<p>此程式碼會完全忽略第一個引數傳入的數值 <code>3</code>，並會印出 <code>This code only uses the y parameter: 4</code>。</p>
<p>在大多數情況中如果當你不再需要特定函式參數的話，你會直接變更簽名讓它不會包含沒有使用到的參數。但忽略函式參數在某些場合會很有用。舉例來說，當你實作的特徵有個特定的型別簽名，但是你實作的函式本體不需要其中某個參數。這樣編譯器就不會警告沒有使用到的函式參數，會當做你有使用參數名稱一樣。</p>
<h4><a class="header" href="#透過巢狀-_-忽略部分數值" id="透過巢狀-_-忽略部分數值">透過巢狀 <code>_</code> 忽略部分數值</a></h4>
<p>我們也可以在其他模式中使用 <code>_</code> 來忽略部分數值。舉例來說，當我們只想測試部分數值，但不會用到執行的程式碼中其他部分數值的情況。範例 18-18 的程式碼負責管理設定值的數值。業務要求使用者不能覆寫已經存在的自訂數訂值，但可以取消設定值，也可以在目前未設定時提供數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut setting_value = Some(5);
    let new_setting_value = Some(10);

    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) =&gt; {
            println!(&quot;Can't overwrite an existing customized value&quot;);
        }
        _ =&gt; {
            setting_value = new_setting_value;
        }
    }

    println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-18：當我們不需要使用 <code>Some</code> 內部數值時，在模式中使用底線來配對 <code>Some</code> 變體</span></p>
<p>此程式碼會印出 <code>Can't overwrite an existing customized value</code> 接著印出 <code>setting is Some(5)</code>。在第一個配對分支中，我們不需要去配對或使用任一 <code>Some</code> 變體內的數值，但我們的確需要檢測  <code>setting_value</code> 與 <code>new_setting_value</code> 是否都爲 <code>Some</code> 變體的情況。在此情況下，我們印出爲何不能變更 <code>setting_value</code>，且不讓它被改變。</p>
<p>在其他所有情況下（無論是 <code>setting_value</code> 還是 <code>new_setting_value</code> 爲 <code>None</code>），我們用第二個分支的 <code>_</code> 模式來配對，我們讓 <code>new_setting_value</code> 變成 <code>setting_value</code>。</p>
<p>我們也可以在同個模式中的多重位置使用底線來忽略特定數值。範例 18-19 忽略了有五個元素的元組中第二個與第四個數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) =&gt; {
            println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-19：忽略元組中數個位置</span></p>
<p>此程式碼會印出 <code>Some numbers: 2, 8, 32</code>，然後數值 4 與 16 會被忽略。</p>
<h4><a class="header" href="#在名稱前加上-_-來忽略未使用的變數" id="在名稱前加上-_-來忽略未使用的變數">在名稱前加上 <code>_</code> 來忽略未使用的變數</a></h4>
<p>如果你建立了一個變數但沒有在任何地方使用到它，Rust 通常會提出警告，因爲這可能是個錯誤。但有時後先建立個你還沒有使用的變數是很有用的，像是你還在寫原型或是才剛開個專案而已。在這種場合，你可以在尚未使用的變數名稱前加上底線，來告訴 Rust 不用提出警告。在範例 18-20 中，我們建立了兩個未使用的變數，但當我們執行此程式碼時，我們應該會只收到其中一個的警告而已。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">範例 18-20：在變數名稱前加上底線來避免未使用變數的警告</span></p>
<p>我們在此收到沒有使用變數 <code>y</code> 的警告，但是我們沒有收到警告說未使用以底線開頭的變數。</p>
<p>注意到只使用 <code>_</code> 與在名稱前加上底線之間是有些差別的。<code>_x</code> 仍會綁定數值到變數中，但 <code>_</code> 不會做任何綁定。爲了展示這樣的區別是有差的，我們用範例 18-21 來展示一個錯誤。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_s) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre>
<p><span class="caption">範例 18-21：以底線開頭的未使用變數仍會綁定數值，因而造成數值所有權被移動</span></p>
<p>我們會收到錯誤，因爲 <code>s</code> 的數值仍會被移至 <code>_s</code>，讓我們無法再使用 <code>s</code>。不過只使用底線的話就不會綁定數值。範例 18-22 就能夠編譯不會產生任何錯誤，因爲 <code>s</code> 沒有移至 <code>_</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = Some(String::from(&quot;Hello!&quot;));

    if let Some(_) = s {
        println!(&quot;found a string&quot;);
    }

    println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-22：使用底線不會綁定數值</span></p>
<p>此程式碼就能執行，因爲我們沒有將 <code>s</code> 綁定給誰，它沒被移動。</p>
<h4><a class="header" href="#透過--忽略剩餘部分數值" id="透過--忽略剩餘部分數值">透過 <code>..</code> 忽略剩餘部分數值</a></h4>
<p>對於有許多部分的數值，我們可以用 <code>..</code> 語法來只使用一些部分，然後忽略剩餘部分，來避免需要對每個要忽略的數值都得加上底線。<code>..</code> 模式會忽略模式中剩餘尚未配對的任何部分數值。在範例 18-23 中，我們有個 <code>Point</code> 結構體存有三維空間中的座標。而在 <code>match</code> 表達式中，我們想要只處理 <code>x</code> 座標並忽略 <code>y</code> 與 <code>z</code> 欄位的數值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-23：透過使用 <code>..</code> 來忽略 <code>Point</code> 中除了 <code>x</code> 以外的所有數值</span></p>
<p>我們列出 <code>x</code> 數值接著只包含 <code>..</code> 模式。這比需要列出 <code>y: _</code> 和 <code>z: _</code> 還要快，尤其是當我們要處理有許多欄位的結構體，但只需要用到一或兩個欄位的狀況下。</p>
<p><code>..</code> 語法會擴展其所有所需得數值。範例 18-24 展示如何在元組使用 <code>..</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        }
    }
}
</code></pre></pre>
<p><span class="caption">範例 18-24：只配對元組中的第一個與最後一個數值，並忽略其他所有數值</span></p>
<p>在此程式碼中，第一個與最後一個數值會配對到 <code>first</code> 與 <code>last</code>。<code>..</code> 會配對並忽略中間所有數值。</p>
<p>然而，使用 <code>..</code> 必須是明確的。如果 Rust 無法確定是哪些數值要配對，而哪些是要忽略的話，它會回傳錯誤給我們。範例 18-25 含糊地使用了 <code>..</code>，所以它無法編譯。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">範例 18-25：嘗試含糊地使用 <code>..</code></span></p>
<p>當我們編譯此範例時，我們會得到此錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling patterns v0.1.0 (file:///projects/patterns)
error: `..` can only be used once per tuple pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |          --          ^^ can only be used once per tuple pattern
  |          |
  |          previously used here

error: aborting due to previous error

error: could not compile `patterns`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust 不可能會知道在配對 <code>second</code> 之前要忽略多少元組中的數值，以及在之後得再忽略多少數值此程式碼可以代表我們想要忽略 <code>2</code>、綁定 <code>second</code> 到 <code>4</code> 然後忽略 <code>8</code>、<code>16</code> 和 <code>32</code>；或者我們想要忽略 <code>2</code> 和 <code>4</code>、綁定 <code>second</code> 到 <code>8</code> 然後忽略 <code>16</code> 和 <code>32</code>，以及更多可能。變數名稱 <code>second</code> 對 Rust 沒有任何特別意義，所以我們得到編譯錯誤，因爲像這樣在兩個地方使用 <code>..</code> 是含糊不清的。</p>
<h3><a class="header" href="#提供額外條件的配對守護" id="提供額外條件的配對守護">提供額外條件的配對守護</a></h3>
<p><em>配對守護（match guard）</em> 是個在 <code>match</code> 分支之後額外指定的 <code>if</code> 條件，除了原本的模式配對，此條件也必須配對才能選擇該分支。配對守護適用於比單獨模式所能表達的還複雜的情況。</p>
<p>該條件能使用配對建立的變數。範例 18-26 展示 <code>match</code> 的第一個分支有個模式 <code>Some(x)</code> 並使用配對守護 <code>if x &lt; 5</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let num = Some(4);

    match num {
        Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; (),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-26：對模式加上配對守護</span></p>
<p>此範例會印出 <code>less than five: 4</code>。當 <code>num</code> 與第一個分支做比較時，它會配對到，因爲 <code>Some(4)</code> 能與 <code>Some(x)</code> 做配對。然後配對守護會檢查數值 <code>x</code> 是否小於 <code>5</code>，然後因爲的確如此，所以就選擇了第一個分支。</p>
<p>如果 <code>num</code> 爲 <code>Some(10)</code> 的話，第一個分支的配對守護則會是否，因爲 10 並不小於 5。Rust 就會接著檢查第二條分支，然後因爲第二條分支沒有任何配對守護所以能配對到任何 <code>Some</code> 變體。</p>
<p>在模式中沒有任何方式能夠表達 <code>if x &lt; 5</code>，所以配對守護讓我們能夠有能力表達此邏輯。</p>
<p>在範例 18-11 中，我們提到我們可以使用模式配對來解決我們的模式遮蔽問題。回想一下 <code>match</code> 表達式中使用的是模式內建立的新變數，而不是使用 <code>match</code> 外部的變數。該新變數會讓我們無法測試外部變數的數值。範例 18-27 展示我們如何使用配對守護來修正此問題。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">範例 18-27：使用配對守護來測試與外部變數是否相等</span></p>
<p>此程式碼現在會印出 <code>Default case, x = Some(5)</code>。第二個模式中沒有宣告新的變數 <code>y</code> 來遮蔽外部的 <code>y</code>，意味著我們可以在配對守護中使用外部的 <code>y</code>。我們不再指定模式爲 <code>Some(y)</code>，因爲這樣會遮蔽外部的 <code>y</code>，我們改指定成 <code>Some(n)</code>。這樣建立了一個新的變數 <code>n</code> 且不會遮蔽任何事物，因爲 <code>match</code> 外部沒有任何變數 <code>n</code>。</p>
<p>配對守護 <code>if n == y</code> 不屬於模式，因此不會宣告任何新變數。此 <code>y</code> <em>就是</em>外部的 <code>y</code> 而非新遮蔽的 <code>y</code>，而且我們可以透過將 <code>n</code> 與 <code>y</code> 做比較來檢查數值是否與外部 <code>y</code> 的數值相等。</p>
<p>你也可以在配對守護中使用 <em>OR</em> 運算子 <code>|</code> 來指定多重模式，配對守護的條件會套用在所有的模式中。範例 18-28 顯示了結合配對守護與使用 <code>|</code> 模式之間的優先層級（precedence）。此例中的重點部分在於 <code>if y</code> 配對守護能套用在 <code>4</code>、<code>5</code> <em>與</em> <code>6</code>，而不是只有 <code>6</code> 會用到 <code>if y</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 4;
    let y = false;

    match x {
        4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-28：結合數個模式與配對守護</span></p>
<p>此配對條件表示該分支只有在數值 <code>x</code> 等於 <code>4</code>、<code>5</code> 或 <code>6</code>，<em>以及</em>如果 <code>y</code> 爲 <code>true</code> 時才算配對到。當此程式碼執行時，第一個分支的模式有配對到，因爲 <code>x</code> 爲 <code>4</code>，但是配對守護 <code>if y</code> 爲否，所以不會選擇第一個分支。程式碼會移動到第二個分支，然後程式會配對到並印出 <code>no</code>。原因在於 <code>if</code> 條件會套用到整個模式 <code>4 | 5 | 6</code>，而不是只有最後一個數值 <code>6</code>。換句話說，配對守護與模式之間的優先層級會像是這樣：</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>而不是這樣：</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>在執行此程式碼之後，優先層級的行爲就很明顯了，如果配對守護只會用在由 <code>|</code> 運算子指定數值列表中最後一個數值的話，該分支應該要能配對到並讓程式印出 <code>yes</code>。</p>
<h3><a class="header" href="#-綁定" id="-綁定"><code>@</code> 綁定</a></h3>
<p><em>At</em> 運算子（<code>@</code>）能讓我們在測試某個數值是否配對的到一個模式的同時，建立出一個變數來持有該數值。範例 18-29 展示我們想要測試 <code>Message::Hello</code> 的 <code>id</code> 欄位是否位於 <code>3..=7</code> 的範圍中。但我們也想要將該數值綁定到變數 <code>id_variable</code> 之中，讓我們可以在該分支對應的程式碼中使用它。我們可以將此變數命名爲與欄位同名的 <code>id</code>，但在此例中我們會使用不同名稱。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Message {
        Hello { id: i32 },
    }

    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id: id_variable @ 3..=7,
        } =&gt; println!(&quot;Found an id in range: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 18-29：使用 <code>@</code> 來在測試時綁定模式中的數值</span></p>
<p>此範例會印出 <code>Found an id in range: 5</code>。透過在範圍 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我們能獲取要配對到範圍的數值，並同時測試該數值是否有配對到範圍模式。</p>
<p>在第二個分支中，我們只有在模式中指定範圍，該分支對應的程式碼就沒有變數能包含 <code>id</code> 欄位的實際數值。<code>id</code> 欄位數值可能是 10、11 或 12，但此模式的程式碼不會知道其值爲何。該模式程式碼無法使用 <code>id</code> 欄位的數值，因爲我們沒有將 <code>id</code> 數值存爲變數。</p>
<p>在最後一個分支中，我們指定沒有限制範圍的變數，我們有能在分支程式碼中使用的有效變數 <code>id</code>。原因是因爲我們使用了結構體欄位簡寫語法。不過我們在此分支沒有向前兩個條分支進行任何對 <code>id</code> 欄位的測試，任何數值都會配對到此模式。</p>
<p>使用 <code>@</code> 讓我們能在一個模式中測試數值並將其儲存至變數。</p>
<h2><a class="header" href="#總結-14" id="總結-14">總結</a></h2>
<p>Rust 的模式對於幫助分辨不同種資料來說非常實用。當在 <code>match</code> 表達式中使用時，Rust 確保你的模式有涵蓋所有可能數值，不然你的程式就不會編譯通過。在 <code>let</code> 陳述式與函式參數中的模式使它們的結構更實用，在能夠解構數值成更小部分的同時賦值給變數。我們能夠建立簡單或複雜的模式來滿足我們的需求。</p>
<p>接下來，在本書的倒數第二章中，我們要來看 Rust 眾多特色中的一些進階部分。</p>
<blockquote>
<ul>
<li>translators: [Ngô͘ Io̍k-ūi <a href="mailto:wusyong9104@gmail.com">wusyong9104@gmail.com</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/e5ed97128302d5fa45dbac0e64426bc7649a558c/src/ch18-03-pattern-syntax.md">e5ed971</a></li>
<li>updated: 2020-09-25</li>
</ul>
</blockquote>
<h1><a class="header" href="#進階特色" id="進階特色">進階特色</a></h1>
<p>現在，你已經了解 Rust 程式語言最常用的部分。在開始做第二十章的另一個專案之前，先來了解你可能偶爾會遇到的語言種種面向。當你使用 Rust 碰到一些未知情況時，可以將本章作為技術文件查閱。雖然可能不會經常碰到這些，但我們希望確保你能掌握 Rust 提供的所有特色。</p>
<p>本章涵蓋：</p>
<ul>
<li>Unsafe Rust：如何選擇捨棄部分 Rust 提供的保證，並自行負責遵守這些保證</li>
<li>進階特徵：關聯型別（associated type）、預設型別參數（default type parameter），完全限定語法（fully qualified syntax），超特徵（supertrait），以及跟特徵相關的新型別模式（newtype pattern）</li>
<li>進階型別：更多有關新型別模式、型別別名（type alias），永不型別（never type），以及動態大小型別（dynamically sized type）</li>
<li>進階函式與閉包：函式指標與回傳閉包</li>
<li>巨集（macro）：一種定義「在編譯期定義程式碼的程式碼」之方法</li>
</ul>
<p>這些 Rust 全功能特色適合所有人。一起來深究吧！</p>
<blockquote>
<ul>
<li>translators: [Weihang Lo <a href="mailto:me@weihanglo.tw">me@weihanglo.tw</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/10f89936b02dc366a2d0b34083b97cadda9e0ce4/src/ch19-00-advanced-features.md">10f8993</a></li>
<li>updated: 2020-09-11</li>
</ul>
</blockquote>
<h2><a class="header" href="#不安全的-rust" id="不安全的-rust">不安全的 Rust</a></h2>
<p>到目前為止，我們討論的所有程式碼都在編譯期強制加上 Rust 記憶體安全保證。然而，Rust 內部其實隱藏了第二種語言，並不強制加上這些記憶體安全保證：這語言叫做<strong>不安全的 Rust</strong>，可和常規 Rust 一樣正常執行，同時賦予我們極強的能力。</p>
<p>不安全的 Rust 之所以存在，是由於靜態分析本質上過於保守。當編譯器嘗試確認程式碼是否遵守這些安全保證時，比起接受一些非法的程式，寧願是拒絕部分合法程式。儘管有些程式碼看上去正確，但 Rust 就是會說「不」！這些案例中，你可以寫不安全程式碼並告訴編譯器：「相信我，我知道我在幹麼。」從反面來看這也有缺點，你必須自行承擔風險：若誤用不安全程式碼，可能會造成記憶體不安全，例如發生對空指標（null pointer）取值（dereference）。</p>
<p>Rust 擁有另一個不安全的自我的另一理由是電腦硬體本質上就不安全。如果 Rust 不允許這些不安全操作，就無法完成特定任務。Rust 必須允許你做這些底層系統程式設計，例如直接與作業系統互動，甚至撰寫自己的作業系統。系統程式設計是這個語言的目標之一，一起探索我們可以用不安全的 Rust 做什麼和如何使用吧。</p>
<h3><a class="header" href="#不安全的超能力" id="不安全的超能力">不安全的超能力</a></h3>
<p>欲切換成不安全的 Rust，可使用 <code>unsafe</code> 關鍵字開啟一個新程式碼區塊，並封裝這些不安全程式碼。在不安全的 Rust，你可使用在安全的 Rust 之下無法使用，我們稱之為<strong>不安全的超能力</strong>的五種功能。這些超能力包含：</p>
<ul>
<li>對裸指標（raw pointer）取值</li>
<li>呼叫不安全函式或方法</li>
<li>存取或修改可變的靜態變數（static variable）</li>
<li>實作不安全特徵（trait）</li>
<li>存取聯合體（union）的欄位（field）</li>
</ul>
<p>需要謹記在心的是，<code>unsafe</code> 並不會關閉借用檢查器（borrow checker）或是停用其他 Rust 的安全檢查：在不安全程式碼中操作一個引用仍然會經過檢查。<code>unsafe</code> 關鍵字只提供上述不經由編譯器檢查記憶體安全的五項功能，在不安全區塊內你依然保有一定程度的安全性。</p>
<p>此外，<code>unsafe</code> 並不意味在此區塊內的程式碼一定有風險或有記憶體安全問題：其目的是作為一個程式設計師，你必須確保在 <code>unsafe</code> 區塊內的程式碼透過合法途徑存取記憶體。</p>
<p>錯誤因人類不可靠而發生。不過，將五種不安全操作標記在 <code>unsafe</code> 區塊內，讓你得知任何記憶體安全相關的錯誤一定在某個 <code>unsafe</code> 內。請將 <code>unsafe</code> 區塊保持夠小，當你在調查一個記憶體臭蟲時，會慶幸當初有這麼做。</p>
<p>為了盡可能隔離不安全程式碼，最佳作法是將之封裝在安全的抽象並提供安全的 API，本章在後面的探討不安全函式和方法一併討論之。部分的標準函式庫同樣是在審核過的不安全程式碼上提供安全抽象。透過安全抽象封裝不安全程式碼，可防止你或你的使用者使用以 <code>unsafe</code> 實作的功能，不會將實際的 <code>unsafe</code> 使用洩漏到四散各地，因為安全抽象就是安全的 Rust。</p>
<p>接下來將依序探討這五個不安全的超能力。也會看看一些替不安全程式碼提供安全介面的抽象。</p>
<h3><a class="header" href="#對裸指標取值" id="對裸指標取值">對裸指標取值</a></h3>
<p>在第四章<a href="ch04-02-references-and-borrowing.html#%E8%BF%B7%E9%80%94%E5%BC%95%E7%94%A8">「迷途引用」</a>一節，我們提及編譯器確保引用一定是合法的。不安全的 Rust 有兩種新型別叫<strong>裸指標</strong>，和引用非常相似。和引用一樣，裸指標能是不可變或可變，分別寫做 <code>*const T</code> 和 <code>*mut T</code>。星號不是取值運算子，它就是型別名稱的一部分。在裸指標的脈絡下，<strong>不可變</strong> 代表指標不能在被取值之後直接賦值。</p>
<p>和引用與智慧指標（smart pointer）不同，裸指標是：</p>
<ul>
<li>允許忽略借用規則，同時可存在指向相同位置的可變和不可變的指標，或是多個可變指標</li>
<li>不能保證一定指向合法記憶體</li>
<li>可以為空（null）</li>
<li>並無實作任何自動清理機制</li>
</ul>
<p>在停用 Rust 的保證之後，你能透過放棄這些安全性保證換得更高的效能，或是介接其他語言與硬體等無法套用 Rust 安全保證的場景。</p>
<p>範例 19-1 展示了如何從引用分別建立不可變和可變的裸指標。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-1：從引用建立裸指標</span></p>
<p>注意，這段程式碼並無使用 <code>unsafe</code> 關鍵字。我們可以在安全程式碼中建立裸指標，我們只是不能在不安全區塊外對之取值，你將很快看到。</p>
<p>我們透過 <code>as</code> 將不可變與可變引用轉型稱個別對應的裸指標。由於這些裸指標是從保證合法的引用而來，就能得知這些裸指標同樣合法，但我們無法推導所有裸指標都合法。</p>
<p>接下來，我們將建立無法確認合法性的裸指標，範例 19-2 展示了如何從任意記憶體的位置建立裸指標。嘗試使用任意的記憶體行為並未定義，該位址上可能有也可能沒資料，且編譯器可能會最佳化該程式，所以該處可能不會存取記憶體，或是程式因區段錯誤導致崩潰。
一般情況下，雖然這種程式碼能寫得出來，但不會有任何好理由寫出它。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let address = 0x012345usize;
    let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-2：從任意記憶體位址建立裸指標</span></p>
<p>回想一下，我們可以在安全的程式碼下建立裸指標，但我們不能對裸指標<strong>取值</strong>並讀取它指向的資料。範例 19-3 我們對裸指標使用取值運算子 <code>*</code> 需要封裝在 <code>unsafe</code> 區塊內。</p>
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    let mut num = 5;

    let r1 = &amp;num as *const i32;
    let r2 = &amp;mut num as *mut i32;

    unsafe {
        println!(&quot;r1 is: {}&quot;, *r1);
        println!(&quot;r2 is: {}&quot;, *r2);
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-3：在 <code>unsafe</code> 區塊對裸指標取值</span></p>
<p>建立一個指標沒有危險性，只有當我們嘗試存取它指向的值時，才可能需要處理非法的值。</p>
<p>請注意，範例 19-1 與 19-3，我們建立了 <code>*const i32</code> 與 <code>*mut i32</code> 兩個裸指標，皆指向相同儲存 <code>num</code> 的記憶體位置。若我們走正常程序建立指向 <code>num</code>  的不可變與可變引用，，程式碼將因為 Rust 所有權規則不允許同時存在一個可變引用與多個不可變引用，進而無法編譯。有了裸指標，即可建立指向同個位置的可變指標和不可變指標，並透過可變指標改變其資料，但可能帶來資料競爭（data races），請小心！</p>
<p>既然有這些危險，為什麼你還要用裸指標呢？一個主要用例是與 C 程式碼介接，你將會在下一節<a href="ch19-01-unsafe-rust.html#%E5%91%BC%E5%8F%AB%E4%B8%8D%E5%AE%89%E5%85%A8%E5%87%BD%E5%BC%8F%E6%88%96%E6%96%B9%E6%B3%95">「呼叫不安全函式或方法」</a>讀到。另一個用例是在借用檢查器不理解之處建立一層安全抽象。我們將會介紹不安全函式，再探討一個使用到不安全程式碼的安全抽象範例。</p>
<h3><a class="header" href="#呼叫不安全函式或方法" id="呼叫不安全函式或方法">呼叫不安全函式或方法</a></h3>
<p>第二種需要不安全區塊的操作是呼叫不安全函式。不安全函式與方法外觀看起來與正常函式及方法並無二致，僅在整個函式定義前多了額外的 <code>unsafe</code> 。<code>unsafe</code> 關鍵字在此脈絡下是指此函式在呼叫時必須遵守某些要求，因為 Rust 無法保證我們能達成這項要求。當我們在一個 <code>unsafe</code> 區塊內呼叫一個 <code>unsafe</code> 函式，意味著我們已閱讀此函式的文件，而且有責任遵守此函式的使用條款。</p>
<p>這裡有個不安全函式叫做 <code>dangerous</code>，函式本體內無任何東西:</p>
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    unsafe fn dangerous() {}

    unsafe {
        dangerous();
    }
<span class="boring">}
</span></code></pre></pre>
<p>我們必須在單獨的 <code>unsafe</code> 區塊中呼叫 <code>dangerous</code> 函式，若不在 <code>unsafe</code> 區塊中呼叫，會得到一個錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0133]: call to unsafe function is unsafe and requires unsafe function or block
 --&gt; src/main.rs:4:5
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
  |
  = note: consult the function's documentation for information on how to avoid undefined behavior

error: aborting due to previous error

For more information about this error, try `rustc --explain E0133`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>藉由一個 <code>unsafe</code> 區塊封裝我們對 <code>dangerous</code> 的呼叫，我們可以對 Rust 聲明我們閱讀過該函式的文件，理解如何合理使用它，並且驗證過我們已履行該函式的使用條款。</p>
<p>不安全函式本體與 <code>unsafe</code> 區塊等效，所以可以在該不安全函式執行其他不安全操作，不需再加 <code>unsafe</code> 區塊。</p>
<h4><a class="header" href="#在不安全程式碼上建立安全的抽象" id="在不安全程式碼上建立安全的抽象">在不安全程式碼上建立安全的抽象</a></h4>
<p>一個函式有不安全程式碼並不代表我們必須將整個函式標註為不安全。事實上，將不安全程式碼封裝在安全函式中是一直常見的抽象。我們來研讀標準函式庫的 <code>split_at_mut</code> 函式作為範例，它需要一些不安全程式碼，並來探索我們能如何實作之。這個安全方法定義在可變的 slice 上：它將一個 slice 在給定的索引引數（argument）上一分為二。範例 19-4 展示了如何使用 <code>split_at_mut</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5, 6];

    let r = &amp;mut v[..];

    let (a, b) = r.split_at_mut(3);

    assert_eq!(a, &amp;mut [1, 2, 3]);
    assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-4：使用一個安全的 <code>split_at_mut</code> 函式</span></p>
<p>我們不可能在 saft Rust 下實作這個函式。一個嘗試可能會像範例 19-5 無法編譯。為了簡化，我們將 <code>split_at_mut</code> 實作為一個函式而非方法，並且以 <code>i32</code> 取代泛型型別 <code>T</code>。</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid], &amp;mut slice[mid..])
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 19-5：嘗試僅用安全的 Rust 實作 <code>split_at_mut</code></span></p>
<p>這個函式先取得該 slice 的總長度，再來檢查從參數而來的索引小於等於該長度。這項檢查代表若我們傳入欲分割的索引位置大於該長度，這個函式會在嘗試使用該索引前就恐慌（panic）。</p>
<p>之後，我們回傳一個元組（tuple），其內包含兩個可變 slice：一個從原始 slice 的起頭到 <code>mid</code> 索引位置，另一個則從 <code>mid</code> 到尾端。</p>
<p>當我們嘗試編譯範例 19-5 的程式碼，會得到一個錯誤。</p>
<pre><code class="language-console">$ cargo run
   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt; src/main.rs:6:30
  |
1 | fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
  |                        - let's call the lifetime of this reference `'1`
...
6 |     (&amp;mut slice[..mid], &amp;mut slice[mid..])
  |     -------------------------^^^^^--------
  |     |     |                  |
  |     |     |                  second mutable borrow occurs here
  |     |     first mutable borrow occurs here
  |     returning this value requires that `*slice` is borrowed for `'1`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `unsafe-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust 的借用檢查器（borrow checker）不能理解我們同時借用一個 slice 的不同部分，它只認知到我們借用同一個 slice 兩次。借用同一個 slice 的不同部分基本上沒什麼問題，因為兩個 slice 不會重疊，但 Rust 不夠聰明以致無法理解這件事。當我們知道程式碼沒問題，但 Rust 並不知道，就是時候搞一點 不安全程式碼了。</p>
<p>範例 19-6 展示了如何使用一個 <code>unsafe</code> 區塊、一個裸指標，以及呼叫一些不安全函式來實作可成功執行的 <code>split_at_mut</code></p>
<pre><pre class="playground"><code class="language-rust unsafe">use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (
            slice::from_raw_parts_mut(ptr, mid),
            slice::from_raw_parts_mut(ptr.add(mid), len - mid),
        )
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut vector = vec![1, 2, 3, 4, 5, 6];
</span><span class="boring">    let (left, right) = split_at_mut(&amp;mut vector, 3);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-6：在 <code>split_at_mut</code> 函式實作中使用不安全程式碼</span></p>
<p>回憶一下第四章<a href="ch04-03-slices.html#slice-%E5%9E%8B%E5%88%A5">「Slice 型別」</a> 一節中，提及 slice 會儲存指向某些資料的指標以及該 slice 長度。我們可使用 <code>len</code> 方法取得 slice 的長度，並用 <code>as_mut_ptr</code> 取得指向 slice 的裸指標。在此範例中，由於我們擁有指向某些 <code>i32</code> 值的可變 slice ，<code>as_mut_ptr</code> 會回傳一個型別為 <code>*mut i32</code> 的裸指標，即是儲存在 <code>ptr</code> 變數中的值。</p>
<p>我們繼續聲稱 <code>mid</code> 索引在該 slice 內。此後我們進入不安全程式碼：<code>slice::from_raw_parts_mut</code> 函式需要一個裸指標與一個長度，並建立一個 slice。我們使用這個函式來建立一個從 <code>ptr</code> 開始長度為 <code>mid</code> 的 slice。而後，我們以 <code>mid</code> 作為引數，對 <code>ptr</code> 呼叫 <code>add</code> 方法，以取得從 <code>mid</code> 開始的裸指標，再來用此指標與從 <code>mid</code> 開始剩下的元素個數作為長度，建立另一個 slice。</p>
<p><code>slice::from_raw_parts_mut</code> 之所以為不安全函式，是因為它需要裸指標，且必須相信這個指標合法。<code>add</code> 是不安全方法是由於它必須相信偏移後的位址是合法指標。因此，我們需要在呼叫 <code>slice::from_raw_parts_mut</code> 和 <code>add</code> 外包一層 <code>unsafe</code> 函式。透過閱讀程式碼與加上對 <code>mid</code> 一定等於或比 <code>len</code> 小的斷言，我們可以宣稱所有在 <code>unsafe</code> 區塊的裸指標都是指向原始 slice 內的合法指標。這是一個可接受且合理的 <code>unsafe</code> 使用情境。</p>
<p>注意，我們不需替 <code>split_at_mut</code> 函式輸出結果做上 <code>unsafe</code> 的記號，而且我們可以在安全的 Rust 呼叫它。我們藉由安全的方式使用 <code>unsafe</code> 函式，完成了對不安全程式碼建立一層安全抽象，這個抽象只會從該函式能夠存取的資料內建立合法指標。</p>
<p>對比之下，範例 19-7 中使用 <code>slice::from_raw_parts_mut</code> 則極有可能會在該 slice 被使用時崩潰。這段程式碼從任意的記憶體位置建立了一個 10,000 元素長的 slice。</p>
<pre><pre class="playground"><code class="language-rust unsafe"><span class="boring">fn main() {
</span>    use std::slice;

    let address = 0x01234usize;
    let r = address as *mut i32;

    let slice: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-7：從任意記憶體位址建立 slice</span></p>
<p>我們不擁有此位址之下的記憶體，且並不保證這段程式碼建立的 slice 一定包含合法的 <code>i32</code> 值。嘗試將 <code>slice</code> 當作合法的 slice 來使用，會導致為未定義行為（undefined behavior）。</p>
<h4><a class="header" href="#使用-extern-函式呼叫外部程式碼" id="使用-extern-函式呼叫外部程式碼">使用 <code>extern</code> 函式呼叫外部程式碼</a></h4>
<p>有些時候，你的 Rust 程式碼可能需要與其他語言撰寫的程式碼互動。這種情況 Rust 提供 <code>extern</code> 關鍵字，予以協助建立與使用<strong>外部函式介面（Foreign Function Interface，FFI）</strong>。FFI 的功能是給一程式語言定義函式，使得另一（外部）程式語言可以呼叫這些函式。</p>
<p>範例 19-8 展示了如何建立整合一個 C 標準函式庫的 <code>abc</code> 函式。由於其他語言並無強制遵守 Rust 的規則和保證，而且 Rust 也無法檢查之，因此在 Rust 程式碼中呼叫在 <code>extern</code> 區塊內宣告的函式一定是不安全的操作，所以確保安全的重責大任就會落在程式設計師身上。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">範例 19-8：宣告並呼叫一個用其他語言定義的 <code>extern</code> 函式</span></p>
<p>在 <code>extern &quot;C&quot;</code> 區塊內，我們列出我們想要呼叫的，從其他語言而來的外部函式名稱與簽名。<code>&quot;C&quot;</code> 的部分定義了外部函式使用了哪個應用程式二進位制介面（ABI）：ABI 定義了在組合語言層級該如何呼叫此函式。<code>&quot;C&quot;</code> ABI 最為通用且遵循 C 程式語言的 ABI 規範。</p>
<blockquote>
<h4><a class="header" href="#從其他語言呼叫-rust-函式" id="從其他語言呼叫-rust-函式">從其他語言呼叫 Rust 函式</a></h4>
<p>我們也可透過 <code>extern</code> 定義一個介面，允許其他語言呼叫 Rust 的函式。有別於使用 <code>extern</code> 區塊，我們會在 <code>fn</code> 關鍵字前加上 <code>extern</code> 關鍵字並指明應用程式二進位制介面（ABI）。我們甚至可加上 <code>#[no_mangle]</code> 註記來告訴編譯器不要重整（mangle）該函式名稱。<strong>重整</strong>是一個編譯器透過改變我們賦予函式的名稱，成為帶有更多資訊的名稱進而提供給編譯過程使用，但人類就相對難以閱讀。每個程式語言編譯器重整名稱的作法有些許不同，因此必須關閉 Rust 編譯器的名稱重整功能。</p>
<p>接下來的範例，我們寫了 <code>call_from_c</code> 函式，可以在編譯成共享函式庫（shared library）且連結至 C 後，由 C 程式碼存取：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;從 C 呼叫了一個 Rust 函式！&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>這類的 <code>extern</code> 用途不需要 <code>unsafe</code>。</p>
</blockquote>
<h3><a class="header" href="#存取或修改可變的靜態變數" id="存取或修改可變的靜態變數">存取或修改可變的靜態變數</a></h3>
<p>到此，我們還沒聊到<strong>全域變數（global variable）</strong>，這個 Rust 支援但會被 Rust 的所有權規則搞得七葷八素的功能。試想有兩個執行緒同時存取同一個可變全域變數，豈不導致資料競爭（data races）。</p>
<p>Rust 的全域變數稱做<strong>靜態</strong>變數。範例 19-9 展示了宣告並使用一個儲存字串 slice 的靜態變數。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">範例 19-9：定義並使用一個不可變的靜態變數</span></p>
<p>靜態變數（static variable）與我們在第三章「<a href="ch03-01-variables-and-mutability.html#%E8%AE%8A%E6%95%B8%E8%88%87%E5%B8%B8%E6%95%B8%E7%9A%84%E5%B7%AE%E7%95%B0">變數與常數的差異</a>」一節討論的常數相似。慣例上靜態變數會用尖叫蛇式命名（<code>SCREAMING_SNAKE_CASE</code>），且<strong>必須</strong>標註變數型別，例如範例中的 <code>*'static str</code>。由於靜態變數只能儲存 <code>static</code> 生命週期的引用，代表 Rust 編譯器可推導出它的生命週期，不需要我們手動標註。存取一個不可變的靜態變數是安全的。</p>
<p>常數和不可變靜態變數看似相同，實則有些許隱晦差異：靜態變數之值有固定的記憶體位址，使用該值永遠會存取相同的資料。反之，常數在使用上則可複製它們儲存的資料。</p>
<p>另一個常數與靜態變數的差異是，靜態變數能是可變的。存取並修改可變的靜態變數並「<strong>不安全</strong>」。範例 19-10 展示了如何宣告、存取、修改一個可變的靜態變數 <code>COUNTER</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust unsafe">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">範例 19-10：讀取與寫入可變的靜態變數為不安全的操作</span></p>
<p>與普通變數一樣，我們透過 <code>mut</code> 關鍵字指明可變性。任何讀寫 <code>COURTER</code> 的程式碼皆必須在 <code>unsafe</code> 區塊中。這個程式碼會編譯並打印出我們預期中的 <code>COUNTER: 3</code> 是因為他在單執行緒執行，若在多執行緒存取 <code>COUTER</code> 則可能導致資料競爭（data races）。</p>
<p>當能從全域存取可變資料時，確保沒有資料競爭就不容易了，這即是為什麼 Rust 將可變的靜態變數視為 不安全。若有可能，推薦使用第十六章討論的並行技術與執行緒安全（thread-safe）的智慧指標（smart pointer），如此一來編譯器就能檢查從不同執行緒存取資料是安全的。</p>
<h3><a class="header" href="#實作不安全特徵" id="實作不安全特徵">實作不安全特徵</a></h3>
<p>最後一個可以用在 <code>unsafe</code> 的功能是實作不安全特徵。當一個特徵是有至少一個方法包含編譯器無法驗證的不變條件（invariant），就稱該特徵不安全。我們可以透過在 <code>trait</code> 前加上 <code>unsafe</code> 關鍵字來宣告一個特徵為 <code>unsafe</code>，這也讓實作該特徵會變成 <code>unsafe</code>，如 19-11 所示。</p>
<pre><pre class="playground"><code class="language-rust unsafe">unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}
</code></pre></pre>
<p><span class="caption">範例 19-11：定義並實作一個不安全特徵</span></p>
<p>透過 <code>unsafe impl</code>，我們承諾我們將會遵守這些編譯器無法驗證的不變條件（invariant）。</p>
<p>回想第十六章<a href="ch16-04-extensible-concurrency-sync-and-send.html#%E5%8F%AF%E5%BB%B6%E5%B1%95%E7%9A%84%E4%B8%A6%E8%A1%8C%E8%88%87-sync-%E5%8F%8A-send-%E7%89%B9%E5%BE%B5">「可延展的並行與 <code>Sync</code> 及 <code>Send</code> 特徵」</a> 一節的兩個記號特徵（marker trait）<code>Sync</code> 與 <code>Send</code>：若我們的型別是由 <code>Send</code> 與 <code>Sync</code> 組合而成，編譯器會自動實作這些特徵。若我們的型別包含一些非 <code>Send</code> 或 <code>Sync</code> 的型別，例如裸指標，但我們希望替型別坐上 <code>Send</code> 或 <code>Sync</code> 的記號，就必須使用 <code>unsafe</code>。Rust 無法驗證我們的型別有遵守可以在多執行緒中傳遞或存取的保證。因而，我們需要自己手動檢查，並指明這是 <code>unsafe</code>。</p>
<h3><a class="header" href="#存取聯合體的欄位" id="存取聯合體的欄位">存取聯合體的欄位</a></h3>
<p><code>union</code> 與 <code>struct</code> 十分相似，差異是在一個聯合體實例中僅儲存其中一個宣告的欄位。聯合體主要用在與 C 程式碼的聯合體介接。存取聯合體的欄位並不安全，由於 Rust 無法保證當前儲存在聯合體實例中的資料是什麼型別，因此存取聯合體的欄位並不安全。你可以從<a href="../reference/items/unions.html">參考手冊</a>了解更多關於聯合體的資訊。</p>
<h3><a class="header" href="#何時該用不安全程式碼" id="何時該用不安全程式碼">何時該用不安全程式碼</a></h3>
<p>透過 <code>unsafe</code> 使用上述五種功能（超能力）並沒有錯，更並非不能接受，但由於編譯期無法協助遵守記憶體安全，這讓 <code>unsafe</code> 程式碼要正確無誤略顯棘手。當你因故需要使用 <code>unsafe</code> 程式碼，就去用吧，並且記得替 <code>unsafe</code> 撰寫明確的註釋，讓有問題發生時更容易追蹤查找源頭。</p>
<blockquote>
<ul>
<li>translators: [Weihang Lo <a href="mailto:me@weihanglo.tw">me@weihanglo.tw</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch19-01-unsafe-rust.md">d44317c</a></li>
<li>updated: 2020-09-12</li>
</ul>
</blockquote>
<h2><a class="header" href="#進階特徵" id="進階特徵">進階特徵</a></h2>
<p>我們在第十章<a href="ch10-02-traits.html#%E7%89%B9%E5%BE%B5-%E5%AE%9A%E7%BE%A9%E5%85%B1%E4%BA%AB%E8%A1%8C%E7%88%B2">「特徵：定義共享行爲」</a>一節首次提及特徵（trait），但和生命週期（lifetime）一樣，對其進階細節並無著墨。現在你已熟稔 Rust ，了解箇中真諦的時機已至。</p>
<h3><a class="header" href="#利用關聯型別在特徵定義中指定佔位符型別" id="利用關聯型別在特徵定義中指定佔位符型別">利用關聯型別在特徵定義中指定佔位符型別</a></h3>
<p><em>關聯型別（associated types）</em> 連結了一個型別佔位符（placeholder）與一個特徵，可以將這些佔位符型別使用在這些特徵所定義的方法簽名上。對特定實作來說，特徵的實作者必須指明在這個型別位置上會用到的具體型別。如此一來，我們可以定義一個特色，使用了某個型別，但直到特徵被實作之前，都不需知道實際上的型別。</p>
<p>多數在本章提及的進階特色都較少使用，而關聯型別則是介於其中：他們比書中其他內容來得少用，但比本章介紹的其他特色來得更常見。</p>
<p>一個具有關聯型別的特徵之範例是標準函式庫提供的 <code>Iterator</code> 特徵。這例子中的關聯型別叫做 <code>Item</code>，表示一型別實作 <code>Iterator</code> 特徵時，會被迭代的那些值的型別。範例 19-12 展示了在第十三章<a href="ch13-02-iterators.html#iterator-%E7%89%B9%E5%BE%B5%E8%88%87-next-%E6%96%B9%E6%B3%95">「<code>Iterator</code> 特徵與 <code>next</code> 方法」</a>一節提及的 <code>Iterator</code> 特徵定義：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-12：<code>Iterator</code> 特徵自帶一個關聯型別</span></p>
<p><code>Item</code> 型別是個佔位符型別，<code>next</code> 方法的定義顯示它會回傳型別為 <code>Option&lt;Self::Item&gt;</code> 之值。<code>Iterator</code> 特徵的實作者會指定 <code>Item</code> 的具體型別，而 <code>next</code> 方法則會回傳一個包含該具體型別的值的一個 <code>Option</code>。</p>
<p>關聯型別可能看起來和泛型的概念非常相似，而後者允許定義函式而不需指定該函式可以處理何種型別。那為什麼我們還需要關聯型別？</p>
<p>讓我們透過第十三章的例子，來檢視以下兩者概念上的差異，這例子的 <code>Counter</code> 結構體（struct）實作了 <code>Iterator</code> 特徵。範例 13-21 中，我們指定的 <code>Item</code> 的型別為 <code>u32</code></p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
<span class="boring">        if self.count &lt; 5 {
</span><span class="boring">            self.count += 1;
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>語法似乎和泛型很像，所以為什麼我們不使用泛型定義 <code>Iterator</code> 特徵，如範例 19-13 所示？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-13: 假設使用泛型來定義 <code>Iterator</code> 特徵</span></p>
<p>差別在於使用泛型時，如範例 19-13 所示，由於我們可以實作出 <code>Iterator&lt;String&gt; for Counter</code> 或以任意多個其他泛型型別來替 <code>Counter</code> 實作 <code>Iterator</code>，因此，必須在每個實作都標註該型別。換言之，當一特徵擁有泛型參數，一型別即可透過改變泛型型別參數（generic type parameter）的具體型別，進而實作該特徵多次。於是，當我們使用 <code>next</code> 方法時，必須提供型別標註，指名要用哪個 <code>Iterator</code> 的實作。</p>
<p>有了關聯型別，同個型別就不能實作同個特徵多次，所以我們不需要標註型別。範例 19-12 中的定義用上了關聯型別，因為只能擁有一個 <code>impl Iterator for Counter</code>，於是只能替 <code>Item</code> 選擇唯一一個型別。在任何地方呼叫 <code>Counter</code> 的 <code>next</code> 方法就不必再明確指定我們想要 <code>u32</code> 迭代器了。</p>
<h3><a class="header" href="#預設泛型型別參數與運算子重載" id="預設泛型型別參數與運算子重載">預設泛型型別參數與運算子重載</a></h3>
<p>我們可以透過泛型型別參數（generic type parameter）指定該泛型型別預設的具體型別。在預設型別可運作的情形下，這可省去實作者需要指定具體型別的勞動。替泛型型別指定預設型別的語法是在宣告泛型型別是寫稱 <code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p>
<p>運算子重載（operator overloading）就是一個使用這個技術的好例子。<em>運算子重載</em>是指特定情況下客製化運算子（如 <code>+</code>）的行為。</p>
<p>Rust 不允許建立你自己的運算子或重載任意的運算子，但你可以透過實作 <code>std::ops</code> 表列出的特徵與相關的運算子，來重載特定運算與相應特徵。在範例 19-14 我們重載了 <code>+</code> 運算子，讓兩個 <code>Point</code> 實例可相加。這個功能是透過對 <code>Point</code> 結構體實作 <code>Add</code> 特徵來達成：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 }
    );
}
</code></pre></pre>
<p><span class="caption">範例 19-14：藉實作 <code>Add</code> 特徵，重載 <code>Point</code> 實例的 <code>+</code> 運算子</span></p>
<p><code>add</code> 方法將兩個 <code>Point</code> 實例的 <code>x</code> 值相加，兩個 <code>y</code> 值相加，並建立新的 <code>Point</code> 實例。<code>Add</code> 特徵有個關聯型別 <code>Outpout</code> 可以決定 <code>add</code> 方法回傳的型別。</p>
<p>這段程式碼的預設泛型型別寫在 <code>Add</code> 特徵中，定義如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>這段程式碼大體上看起來很眼熟：具有一個方法與一個關聯型別的特徵。新朋友是 <code>Rhs=Self</code>，這部分叫做<em>預設型別參數（default type parameter）</em>。<code>Rhs</code> 泛型參數（「右運算元 right hand side」的縮寫）定義了 <code>add</code> 方法中 <code>rhs</code> 參數的型別。若我們未在實作 <code>Add</code> 特徵時指定 <code>Rhs</code> 的具體型別，這個 <code>Rhs</code> 的型別預設會是 <code>Self</code>，也就是我們正在實作 <code>Add</code> 的型別。</p>
<p>當我們對 <code>Point</code> 實作 <code>Add</code>，因為我們想要將兩個 <code>Point</code> 實例相加，所以用到預設的 <code>Rhs</code>。讓我們看一個實作 <code>Add</code> 的範例，如何不用預設值，轉而客製化 <code>Rhs</code>。</p>
<p>有兩個結構體，<code>Millimeters</code> 與 <code>Meters</code>，分別儲存不同單位的值。我們想將毫米透過 <code>Add</code> 做好正確單位轉換來加至公尺，這可透過對 <code>Millimeters</code> 實作 <code>Add</code> 並將 <code>Rhs</code> 設為 <code>Meters</code> 達成，如範例 19-15。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-15：藉由替 <code>Millimeters</code> 實作 <code>Add</code> 特徵，使 <code>Millimeters</code> 可與 <code>Meters</code> 相加Point</span></p>
<p>欲相加 <code>Millimeters</code> 與 <code>Meters</code>，先將 <code>Rhs</code> 型別參數指定為 <code>impl Add&lt;Meters&gt;</code>，替代預設的 <code>Self</code>。</p>
<p>你會在下列兩種情況下使用預設型別參數：</p>
<ul>
<li>擴充一個型別但不破壞既有程式碼</li>
<li>提供大多數使用者不會需要的特殊狀況之客製化空間</li>
</ul>
<p>標準函式庫是第二種情況的範例：通常你會將兩個相同的型別相加，但 <code>Add</code> 特徵提供超乎預設的客製化能力。<code>Add</code> 特徵定義中的預設型別參數讓我們大多數時候不需要指定額外的參數。換句話說，不用再寫部分重複的樣板，讓該特徵更易用。</p>
<p>第一種情況和第二種類似，但概念相反：若你想替既有特徵加上新的型別參數，可以給它一個預設值，允許擴充該特徵的功能，而不破壞既有的程式實作。</p>
<h3><a class="header" href="#消除歧義的完全限定語法呼叫同名的方法" id="消除歧義的完全限定語法呼叫同名的方法">消除歧義的完全限定語法：呼叫同名的方法</a></h3>
<p>Rust 並沒有限制不同特徵之間不能有同名的方法，也沒有阻止你對同一個型別實作這兩個特徵。有可能實作一個型別，其擁有多個從多個特徵而來的同名方法的型別。</p>
<p>當呼叫這些同名方法，你必須告訴 Rust 你想呼叫誰。試想範例 19-16 的程式碼，我們定義了兩個特徵 <code>Pilot</code> 與 <code>Wizard</code>，兩者都有 <code>fly</code> 方法。當我們對一個已經擁有 <code>fly</code> 方法的 <code>Human</code> 型別分別實作這兩個特徵時，每個 <code>fly</code> 方法的行為皆不同。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;這裡是艦長發言。&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;起！&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*狂揮雙臂*&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 19-16：Human 分別實作了兩個特徵的 <code>fly</code> 方法，且 <code>Human</code> 自己實作了一個 <code>fly</code> 方法</span></p>
<p>當我們對一個 <code>Human</code> 實例呼叫 <code>fly</code>，編譯器預設會呼叫直接在該型別上實作的方法，如範例 19-17 所示：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">範例 19-17：對 <code>Human</code> 實例呼叫 <code>fly</code></span></p>
<p>執行這段程式碼會印出 <code>*狂揮雙臂*</code>，表示 Rust 呼叫直接在 <code>Human</code> 上實作的 <code>fly</code> 方法。</p>
<p>欲呼叫在 <code>Pilot</code> 或 <code>Wizard</code> 特徵上的 <code>fly</code> 方法，我們要用更明確的語法指定我們想要的 <code>fly</code> 方法。範例 19-18 展示了這個語法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">範例 19-18：指定想要呼叫哪個特徵的 <code>fly</code> 方法</span></p>
<p>在你要呼叫的方法名前指定特徵名稱，可以讓 Rust 清楚得知我們要呼叫哪個實作 <code>fly</code>。我們也可以寫成 <code>Human::fly(&amp;person)</code>，同義於在範例 19-18 的 <code>person.fly()</code>，只是為了消歧義而寫得長一點罷了。</p>
<p>執行這段程式碼會印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
     Running `target/debug/traits-example`
這裡是艦長發言。
起！
*狂揮雙臂*
</code></pre>
<p>因為 <code>fly</code> 方法有個 <code>self</code> 參數，所以我們若有兩個<em>型別</em>都實作了同個特徵，Rust 可以透過 <code>self</code> 的型別理出該用哪個特徵的實作。</p>
<p>然而，當特徵上的關聯函式（associated function）沒有 <code>self</code> 參數時，當同個作用域下的兩個型別都實作同個特徵，除非使用「完全限定語法（fully qualified syntax）」，否則 Rusti 無法推斷你指涉哪個型別。舉例來說，範例 19-19 的 <code>Animal</code> 特徵有個對 <code>Dog</code> 實作 <code>Animal</code> 所得的關聯函式 <code>baby_name</code>，同時也有直接在 <code>Dog</code> 上實作的關聯函式 <code>baby_name</code>。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">範例 19-19: 一個特徵和一個型別分別擁有同名關聯函式，並且該型別實作了該特徵</span></p>
<p>這段給動物庇護所的程式碼想要將所有小狗崽命名為小不點，這個行為實作在 <code>Dog</code> 的 <code>baby_name</code> 關聯函式。這個 <code>Dog</code> 型別同時實作了 <code>Animal</code> 特徵，<code>Animal</code> 特徵則描述了所有動物都有的習性。我們會在實作了 <code>Animal</code> 特徵的 <code>Dog</code> 上，透過與 <code>Animal</code> 特徵關聯的 <code>baby_name</code> 函式中，表達幼犬被稱作小狗崽這一概念。</p>
<p>在 <code>main</code> 中我們呼叫 <code>Dog::baby_name</code> 函式，最終會直接呼叫 <code>Dog</code> 上的關聯函式。這段程式碼會印出：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54s
     Running `target/debug/traits-example`
幼犬被稱作小不點
</code></pre>
<p>這個輸出結果不符合我們預期。我們想呼叫的 <code>baby_name</code> 函式應該是我們在 <code>Dog</code> 上實作的 <code>Animal</code> 特徵，所以程式碼應該印出 <code>A baby dog is called a puppy</code>。我們在範例 19-18 所使用的指明特徵的技巧不適用於此，如果我們更改 <code>main</code> 成範例 19-20，會得到一個編譯錯誤：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;小不點&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;小狗崽&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;幼犬被稱為{}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">範例 19-20：嘗試呼叫 <code>Animal</code> 特徵上的 <code>baby_name</code> 函式，但 Rust 不知道該用哪個實作</span></p>
<p>因為 <code>Animal::baby_name</code> 不是方法而是關聯函式，因此沒有 <code>self</code> 參數，Rust 無法推斷出我們想要哪個 <code>Animal::baby_name</code> 實作。我們會得到這個編譯錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0283]: type annotations needed
  --&gt; src/main.rs:20:43
   |
2  |     fn baby_name() -&gt; String;
   |     ------------------------- required by `Animal::baby_name`
...
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type
   |
   = note: cannot resolve `_: Animal`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0283`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>欲消除歧義，告訴 Rust 我們想用實作了 <code>Animal</code> 的 <code>Dog</code>，必須使用完全限定語法。範例 19-21 展示了如何使用完全限定語法。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;小不點&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;小狗崽&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;幼犬被稱作{}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">範例 19-21：使用完全限定語法指定呼叫實作了 <code>Animal</code> 的 <code>Dog</code> 上的 <code>baby_name</code> 函式</span></p>
<p>我們提供一個用角括號包住的型別註解（type annotation），這個註解透過將此函式呼叫的 <code>Dog</code> 型別視為 <code>Animal</code>，來指明我們想要呼叫有實作 <code>Animal</code> 特徵的 <code>Dog</code> 上的 <code>baby_name</code> 方法。這段程式碼現在會印出我們所要的：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/traits-example`
幼犬被稱作小狗崽
</code></pre>
<p>普遍來說，完全限定語法定義如下：</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>對於關聯函式來說，不會有 <code>receiver</code>，只會有其他引數的列表。你可以在任何呼叫函式或方法之處使用完全限定語法。然而，你亦可在 Rust 能透過程式其他資訊推斷出的地方省略這個語法。只需要在有多個同名實作且需要協助 Rust 指定呼叫哪個實作時，才需要使用這囉嗦冗長的語法。</p>
<h3><a class="header" href="#使用超特徵要求在一個特徵內有另一特徵的功能" id="使用超特徵要求在一個特徵內有另一特徵的功能">使用超特徵要求在一個特徵內有另一特徵的功能</a></h3>
<p>有些時候，你會需要一個使用到其他特徵的功能的特徵。在這種情形下，相依的特徵也需要被實作，而你依賴的這個特徵就是你正在實作的特徵的「超特徵（supertrait）」。</p>
<p>假設我們想要建立一個 <code>OutlinePrint</code> 特徵，它有一個 <code>outline_print</code> 方法會印出一個被星號包圍的值。換句話說，給定一個實作 <code>Display</code> 而會產生 <code>(x, y)</code> 的 <code>Point</code> 結構體，當我們對 <code>x</code> 為 <code>1</code>，<code>y</code> 為 <code>3</code> 的 <code>Point</code> 實例呼叫 <code>outline_print</code>，它印出如下：</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>在這個 <code>outline_print</code> 實作中，我們想要使用到 <code>Display</code> 特徵的功能。因此，我們需要指明 <code>OutlinePrint</code> 特徵只會在型別同時實作 <code>Display</code> 且提供 <code>OutlinePrint</code> 所需功能時才會成功。這件事可以在特徵定義中做到，透過指明 <code>OutlinePrint: Display</code>。這項技巧很類似特徵上的特徵約束（trait bound）。範例 19-22 展示了 <code>OutlinePrint</code> 特徵的實作。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 19-22: 實作要求 <code>Display</code> 功能的 <code>OutlinePrint</code> 特徵</span></p>
<p>因為我們已指明 <code>OutlinePrint</code> 需要 <code>Display</code> 特徵，且只要有實作 <code>Display</code> 的型別都會自動實作 <code>to_string</code> 這個函式，所以我們可以使用 <code>to_string</code>。若我們嘗試使用 <code>to_string</code> 但並沒有在該特徵後加上冒號並指明 <code>Display</code>，會得到一個錯誤，告訴我們在當前作用域下的 <code>&amp;Self</code> 型別找不到名為 <code>to_string</code> 函數。</p>
<p>我們嘗試看看在一個沒有實作 <code>Display</code> 的型別上實作 <code>OutlinePrint</code>（如 <code>Point</code> 結構體）會發生什麼事：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre>
<p>於是得到 <code>Display</code> 為必須但沒實作的錯誤：</p>
<pre><code class="language-console">$ cargo run
   Compiling traits-example v0.1.0 (file:///projects/traits-example)
error[E0277]: `Point` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `traits-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>我們可以透過對 <code>Point</code> 實作 <code>Display</code> 並滿足 <code>OutlinePrint</code> 要求的約束（constraint），如下：</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait OutlinePrint: fmt::Display {
</span><span class="boring">    fn outline_print(&amp;self) {
</span><span class="boring">        let output = self.to_string();
</span><span class="boring">        let len = output.len();
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;* {} *&quot;, output);
</span><span class="boring">        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
</span><span class="boring">        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl OutlinePrint for Point {}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 1, y: 3 };
</span><span class="boring">    p.outline_print();
</span><span class="boring">}
</span></code></pre></pre>
<p>於是對 <code>Point</code> 實作 <code>OutlinePrint</code> 特徵就成功編譯，我們即可以對 <code>Point</code> 實例呼叫 <code>outline_print</code> 來顯示一個星號外框框住它。</p>
<h3><a class="header" href="#使用新型別模式替外部型別實作外部特徵" id="使用新型別模式替外部型別實作外部特徵">使用新型別模式替外部型別實作外部特徵</a></h3>
<p>在第十章<a href="ch10-02-traits.html#%E5%B0%8D%E5%9E%8B%E5%88%A5%E5%AF%A6%E4%BD%9C%E7%89%B9%E5%BE%B5">「對型別實作特徵」</a>一節中，我們提及孤兒規則（orphah rule），這個規則指出只要型別或特徵其一是在本地的 crate 中定義，就允許我們對該型別實作該特徵。使用<em>新型別模式（newtype pattern）</em>，即可繞過這項規則，此模式涉及建立一個元組結構體（tuple struct）型別（我們在<a href="ch05-01-defining-structs.html#%E4%BD%BF%E7%94%A8%E7%84%A1%E5%90%8D%E7%A8%B1%E6%AC%84%E4%BD%8D%E7%9A%84%E5%85%83%E7%B5%84%E7%B5%90%E6%A7%8B%E9%AB%94%E4%BE%86%E5%BB%BA%E7%AB%8B%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%88%A5">「使用無名稱欄位的元組結構體來建立不同型別」</a>說明了元組結構體）。元組結構體包含一個欄位（field），在我們想要實作該特徵的型別外作一層薄薄的封裝。這封裝型別對 crate 來說算作在本地定義，因此可以對該封裝實作該特徵。<em>新型別</em>是一個源自 Haskell 程式語言的術語。使用此模式不會有任何執行期（runtime）效能的耗損，這個封裝型別會在編譯期刪略。</p>
<p>舉個例子，我們想要對 <code>Vec&lt;T&gt;</code> 實作 <code>Display</code>，但孤兒規則限制我們不能這樣做，因為 <code>Display</code> 特徵與 <code>Vec&lt;T&gt;</code> 都是在我們的 crate 之外定義。我們可以建立一個 <code>Wrapper</code> 結構體，帶有一個 <code>Vec&lt;T&gt;</code> 實例，接下來再對 <code>Wrapper</code> 實作 <code>Display</code> 並使用 <code>Vec&lt;T&gt;</code> 之值，如範例 19-23 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">範例 19-23：建立一個 <code>Wrapper</code> 型別封裝 <code>Vec&lt;STring&gt;</code> 以實作 <code>Display</code></span></p>
<p>因為 <code>Wrapper</code> 是一個元組結構體而 <code>Vec&lt;T&gt;</code> 是該元組在索引 0 上的項目，所以該 <code>Display</code> 的實作使用 <code>self.0</code> 存取內部的 <code>Vec&lt;T&gt;</code>。我們就可以在 <code>Wrapper</code> 上使用 <code>Display</code> 的功能了。</p>
<p>使用這個技術的缺點是 <code>Wrapper</code> 是個新型別，並無它封裝的值所擁有的方法。我們不得不在 <code>Wapper</code> 上實作所有 <code>Vec&lt;T&gt;</code> 的方法，委派這些方法給 <code>self.0</code>，讓我們可以將 <code>Wrapper</code> 作為 <code>Vec&lt;T&gt;</code> 一樣對待。如果我們想要新型別得到所有內部型別擁有的所有方法，一個解法是透過對 <code>Wrapper</code> 實作 <code>Deref</code> 特徵（在第十五章<a href="ch15-02-deref.html#%E9%80%8F%E9%81%8E-deref-%E7%89%B9%E5%BE%B5%E5%B0%87%E6%99%BA%E6%85%A7%E6%8C%87%E6%A8%99%E8%A6%96%E7%82%BA%E4%B8%80%E8%88%AC%E5%BC%95%E7%94%A8">「透過 <code>Deref</code> 特徵將智慧指標視為一般引用」</a>一節有相應討論）並回傳內部型別。如果我們不想要 <code>Wrapper</code> 擁有所有內部型別的方法，例如限制 <code>Wrapper</code> 型別之行為，就僅須實作那些我們想要的方法。</p>
<p>現在，你知道如何將新型別模式與特徵相關聯，縱使不涉及特徵，新型別模式仍非常實用。接下來我們將目光轉移到其他與 Rust 型別系統互動的方法吧。</p>
<blockquote>
<ul>
<li>translators: [Weihang Lo <a href="mailto:me@weihanglo.tw">me@weihanglo.tw</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/1f8e2ec392b1d261acebda3fa9d81ea3f18c7e40/src/ch19-03-advanced-traits.md">1f8e2ec</a></li>
<li>updated: 2020-09-16</li>
</ul>
</blockquote>
<h2><a class="header" href="#進階型別" id="進階型別">進階型別</a></h2>
<p>我們提及 Rust 的型別系統有諸多特色，不過尚未深入討論。本章將從一般角度切入討論新型別（newtype）並檢驗為何作為型別來說，新型別非常好用。再來，接續看看型別別名（type alias）這個類似新型別但語意上不盡相同的特色。我們也會探討 <code>!</code> 型別與動態大小型別（dynamically sized type）。</p>
<blockquote>
<p>注意：接下來一節假定你已閱讀前面的章節 <a href="ch19-03-advanced-traits.html#%E4%BD%BF%E7%94%A8%E6%96%B0%E5%9E%8B%E5%88%A5%E6%A8%A1%E5%BC%8F%E6%9B%BF%E5%A4%96%E9%83%A8%E5%9E%8B%E5%88%A5%E5%AF%A6%E4%BD%9C%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%B5">「使用新型別模式替外部型別實作外部特徵」</a>。</p>
</blockquote>
<h3><a class="header" href="#透過新型別模式達成型別安全與抽象" id="透過新型別模式達成型別安全與抽象">透過新型別模式達成型別安全與抽象</a></h3>
<p>目前為止，我們討論過的任務中，新型別模式皆游刃有餘，包括靜態強制不讓值被混淆，同時能表示該值的單位。在範例 19-15 可以見到如何善用新型別表示該值的單位：回憶一下，<code>Millimeters</code> 與 <code>Meters</code> 將 <code>u32</code> 的值封裝在新型別內，若我們寫了一個函式需要型別為 <code>Millimeters</code> 的參數，我們不可能編譯出一支可以誤傳 <code>Meters</code> 型別或 <code>u32</code> 來呼叫這個函式的程式。</p>
<p>另一個新型別的使用情境是替一型別的實作細節建立抽象層：如果我們直接將新型別作為限制可用功能的手段，新型別就可以公開有別於私有內部型別的 API。</p>
<p>新型別也可以隱藏內部實作。例如，我們可以提供 <code>People</code> 型別，封裝用來儲存人們的 ID 與姓名之間的關聯的 <code>HashMap&lt;i32, String&gt;</code>。使用 <code>People</code> 的程式碼僅能與我們提供的公開 API 互動，例如透過一個方法替 <code>People</code> 集合添加名字字串，這段程式碼就不需知道內部會將 <code>i32</code> 作為 ID 並映射到姓名上。我們在第十七章的<a href="ch17-01-what-is-oo.html#%E9%9A%B1%E8%97%8F%E5%AF%A6%E4%BD%9C%E7%B4%B0%E7%AF%80%E7%9A%84%E5%B0%81%E8%A3%9D">「隱藏實作細節的封裝」</a>一節也曾提及，利用新型別模式來達到封裝與隱藏實作細節，不失為一種輕量的方法。</p>
<h3><a class="header" href="#透過型別別名建立型別同義詞" id="透過型別別名建立型別同義詞">透過型別別名建立型別同義詞</a></h3>
<p>此外，Rust 提供了替一個既有型別宣告型別別名的方式。對此我們會使用 <code>type</code> 關鍵字，例如我們可以建立 <code>i32</code> 的別名 <code>Kilometers</code>，如範例所示：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;
<span class="boring">
</span><span class="boring">    let x: i32 = 5;
</span><span class="boring">    let y: Kilometers = 5;
</span><span class="boring">
</span><span class="boring">    println!(&quot;x + y = {}&quot;, x + y);
</span><span class="boring">}
</span></code></pre></pre>
<p>現在，<code>Kilometers</code>  別名就是 <code>i32</code> 的<strong>同義詞</strong>。不像我們在範例 19-15 建立的 <code>Millimeters</code> 與 <code>Meters</code> 型別，<code>Kilometers</code> 並非獨立的新型別。型別為 <code>Kilometers</code> 的值會被當作型別是 <code>i32</code> 的值。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Kilometers = i32;

    let x: i32 = 5;
    let y: Kilometers = 5;

    println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>由於 <code>Kilometers</code> 與 <code>i32</code> 實際上是同個型別，所以兩者可以相加，我們也可以將 <code>Kilometers</code> 值傳入需要 <code>i32</code> 參數的函式。然而，這種作法並不像前面討論的新型別模式一樣有益於型別檢查。</p>
<p>型別同義詞的主要使用情境在於減少重複。例如我們有一個又臭又長的型別：</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<p>到處在函式簽名與型別註解寫這個型別既累人又容易失誤。想像你有一個專案的程式碼都長得像範例 19-24。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
        // --snip--
    }

    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-24：在多處使用很長的型別</span></p>
<p>使用型別別名減少重複，讓程式碼更可控。範例 19-25，我們替落落長的型別導入一個 <code>Trunk</code> 別名，所有用到該型別之處都能用短小的 <code>Thunk</code> 替代。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

    let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

    fn takes_long_type(f: Thunk) {
        // --snip--
    }

    fn returns_long_type() -&gt; Thunk {
        // --snip--
<span class="boring">        Box::new(|| ())
</span>    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-25：導入型別別名 <code>Thunk</code> 來減少重複</span></p>
<p>這段程式碼更容易讀寫了！選擇有意義的型別別名也有助於溝通傳達你的意圖（<strong>thunk</strong> 是一個表示會在未來對此程式碼求值，所以很適用表達儲存起來的閉包（closure））。</p>
<p>型別別名同樣十分常用在 <code>Result&lt;T, E&gt;</code> 來減少重複。試想標準函式庫的 <code>std::io</code> 模組，輸入輸出（I/O）操作通常會藉由回傳 <code>Result&lt;T, E&gt;</code> 來處理失敗的操作。標準函式庫有個 <code>std::io::Error</code> 結構體來表示所有可能的 I/O 錯誤。許多在 <code>std::io</code> 內的函式會回傳 <code>E</code> 為 <code>std::io::Error</code> 的 <code>Result&lt;T, E&gt;</code> ，例如這些 <code>Write</code> 特徵下的函式：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io::Error;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>這些 <code>Result&lt;..., Error</code>&gt; 不斷重複，有鑑於此，<code>std::io</code> 宣告了這個型別的別名：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">
</span><span class="boring">pub trait Write {
</span><span class="boring">    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
</span><span class="boring">    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;
</span><span class="boring">
</span><span class="boring">    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
</span><span class="boring">    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>由於這個宣告是在 <code>std::io</code> 模組內，因此我們可直接使用完全限定的別名 <code>std::io::Result&lt;T&gt;</code>，實際上就是 <code>E</code> 預先填入 <code>std::io::Error</code> 的 <code>Result&lt;T, E&gt;</code>。最終，<code>Write</code> 特徵的函式簽名就會長得這樣：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
</span><span class="boring">
</span>pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>型別別名有助於兩個面向：讓程式碼更容易撰寫，<strong>且</strong>對所有 <code>std::io</code> 提供一致的介面。因為它僅僅是別名，所以就是一個 <code>Result&lt;T, E&gt;</code> 而已，這意味著我們能使用任何可與 <code>Result&lt;T, E&gt;</code> 互動的方法，以及使用類似 <code>?</code> 運算子這種特殊語法。</p>
<h3><a class="header" href="#永不回傳的永不型別" id="永不回傳的永不型別">永不回傳的永不型別</a></h3>
<p>Rust 有一個特殊的型別叫做 <code>!</code>，由於它沒有任何值，在型別理論的行話中又稱為<strong>空型別（empty type）</strong>。不過我們更喜歡稱之為<strong>永不型別（never type）</strong>，因為當一個函式永遠不會回傳，永不型別將會替代原本的回傳型別。這裡來個範例:</p>
<pre><pre class="playground"><code class="language-rust">fn bar() -&gt; ! {
    // --snip--
<span class="boring">    panic!();
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>這段程式碼可讀作「函式 <code>bar</code> 永不回傳」。永不回傳的函數稱為<strong>發散函式（diverging function）</strong>，我們無法建立 <code>!</code> 型別，所以 <code>bar</code> 永遠無法回傳。</p>
<p>不過，若永遠無法替這個型別建立值，那要這個型別幹嘛呢？回想一下，範例 2-5 的程式碼，在我們的範例 19-26 又重現了。</p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span>        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };
<span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span><span class="boring">        // --snip--
</span><span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 19-26：<code>match</code> 其中一個分支結束在 <code>continue</code></span></p>
<p>當時我們跳過了這段程式碼的一些細節。在第六章<a href="ch06-02-match.html#match-%E6%8E%A7%E5%88%B6%E6%B5%81%E9%81%8B%E7%AE%97%E5%AD%90">「<code>match</code> 控制流運算子」</a>一節，我們探討了每個 <code>match</code> 分支必須回傳相同的型別，所以，例如以下程式碼就不能執行：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let guess = &quot;3&quot;;
</span>    let guess = match guess.trim().parse() {
        Ok(_) =&gt; 5,
        Err(_) =&gt; &quot;hello&quot;,
    };
<span class="boring">}
</span></code></pre>
<p>這段程式碼中 <code>guess</code> 的型別必須是<strong>同時是</strong>整數與字串，並且 Rust 要求 <code>guess</code> 只能是一種型別。那 <code>contiunue</code> 回傳了什麼？範例 19-26 中，為什麼允許一個分支回傳 <code>u32</code> 但同時有另一分支結束在 <code>continue</code>？</p>
<p>如你所猜，<code>continue</code> 具有 <code>!</code> 值。意即當 Rust 根據兩個分支來推算 <code>guess</code> 型別時，會觀察到前者會是 <code>u32</code>，而後者是 <code>!</code>。因為 <code>!</code> 永遠不會有值，Rust 於是決定 <code>guess</code> 的型別為 <code>u32</code>。</p>
<p>描述這種行為的正確方式是：<code>!</code> 型別的表達式能夠轉型為任意其他型別。我們允許 <code>match</code> 分支結束在 <code>continue</code> 就是因為 <code>continue</code> 不會回傳任何值，相反地，它將控制流移至迴圈的最上面，所以在 <code>Err</code> 的情況，我們不會對 <code>guess</code> 賦值。</p>
<p>永不型別在使用 <code>panic!</code> 巨集很實用。還記得當我們對 <code>Option&lt;T&gt;</code> 呼叫 <code>unwrap</code> 函式，會產生一個值或是恐慌嗎？這裡就是它的定義：</p>
<pre><code class="language-rust ignore"><span class="boring">enum Option&lt;T&gt; {
</span><span class="boring">    Some(T),
</span><span class="boring">    None,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::Option::*;
</span><span class="boring">
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>和範例 19-26 <code>match</code> 相同的情況，在這段程式碼再度上演：Rust 看到 <code>val</code> 的型別是 <code>T</code> 且 <code>panic</code> 是 <code>!</code> 型別，所以 <code>match</code> 表達式的總體結果是 <code>T</code>。這段程式碼可執行是因為 <code>panic!</code> 會結束程式而不會產生值。當遇上 <code>None</code> 的情形，我們不會從 <code>unwrap</code> 回傳任何值，所以這段程式碼合法有效。</p>
<p>最後一個具有 <code>!</code> 型別的表達式是 <code>loop</code>：</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    print!(&quot;forever &quot;);

    loop {
        print!(&quot;and ever &quot;);
    }
<span class="boring">}
</span></code></pre>
<p>這裡迴圈永不結束，所以 <code>!</code> 就是迴圈表達式的值。但當我們有一個 <code>break</code> 時，這就不成立了，因為迴圈會在抵達 <code>break</code> 時終止。</p>
<h3><a class="header" href="#動態大小型別與-sized-特徵" id="動態大小型別與-sized-特徵">動態大小型別與 <code>Sized</code> 特徵</a></h3>
<p>由於 Rust 需要了解特定細節，例如需替特定型別之值分配多少空間，導致其類型系統有個地方令人困惑，就是<strong>動態大小型別（dynamically sized type）<strong>的概念。 有時稱為</strong>DST</strong>或<strong>不定大小（unsize）型別</strong>，這些型別賦予我們寫出僅能在執行期（runtime）得知值的大小之程式碼。</p>
<p>讓我們深入研究一個貫穿全書到處使用的動態大小型別 <code>str</code> 的細節。你沒看錯，不是 <code>&amp;str</code> 而是 <code>str</code> 本身就是 DST。在執行期前我們無從得知字串多長，也就表示無法建立一個型別為 <code>str</code> 的變數，更不能將 <code>str</code> 型別作為引數。試想以下不能執行的程式碼：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1: str = &quot;Hello there!&quot;;
    let s2: str = &quot;How's it going?&quot;;
<span class="boring">}
</span></code></pre>
<p>Rust 必須知道該配置多少記憶體給特定型別之值，且所有該型別之值都會使用相同的記憶體量。若 Rust 允許我們寫出這種程式碼，代表這兩個 <code>str</code> 值會用相同的空間大小，但它們長度不同：<code>s1</code> 需要 12 位元組來儲存，而 <code>s2</code> 需要 15 位元組。這就是為什麼不可能建立一個持有動態大小型別的變數。</p>
<p>那我們該如何是好？這種情況下，你其實已經知道答案：將 <code>s1</code> 與 <code>s2</code> 的型別從 <code>str</code> 改成 <code>&amp;str</code>。回憶以下，第四章<a href="ch04-03-slices.html#%E5%AD%97%E4%B8%B2-slice">「字串 Slice」</a>一節我們說了，slice 資料結構會儲存該 slice 的開始位置與長度。</p>
<p>雖然 <code>&amp;T</code> 是單一的值，儲存了 <code>T</code> 所在的記憶體位址，<code>&amp;str</code> 卻儲存<strong>兩個</strong>值：<code>str</code> 的位址與它的長度。如此一來，無論 <code>&amp;str</code> 指向的字串有多長，我們都可以在編譯期得知 <code>&amp;str</code> 的大小。一般來說，這就是動態大小型別在 Rust 中的使用方式，通常具有額外的資料紀錄動態資訊的大小。動態大小型別的黃金法則即是我們必將動態大小型別的值放在指向某種指標之後。</p>
<p>我們將各種指標與 <code>str</code> 結合，例如 <code>Box&lt;str&gt;</code> 或 <code>Rc&lt;str&gt;</code>。事實上，你早已看過此類作法，不過是在其他動態大小型別上看過，那個型別就是特徵（trait）。每個特徵都是一個動態大小型別，我們可以透過使用特徵的名字來指涉它。在第十七章的<a href="ch17-02-trait-objects.html#%E5%85%81%E8%A8%B1%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%88%A5%E6%95%B8%E5%80%BC%E7%9A%84%E7%89%B9%E5%BE%B5%E7%89%A9%E4%BB%B6">「允許不同型別數值的特徵物件」</a>部分，我們提及欲將特徵做為特徵物件（trait object）來使用，必須將特徵放在指標之後，例如 <code>&amp;dyn Trait</code> 或 <code>Box&lt;dyn Trait&gt;</code>（<code>Rc&lt;dyn Trait&gt;</code> 也行）。</p>
<p>為了使用 DST，Rust 提供一個 <code>Sized</code> 特徵，來決定一個型別的大小可否在編譯期就確定下來。對於能在編譯期得知大小的所有東西，都會自動實作這個特徵。此外 Rust 自動替所有泛型函式隱含加上 <code>Sized</code> 的約束（bound）。也就是說若一泛型函數定義如下：</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>實際上就如同寫成這樣：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>預設情形下，泛型函式只能在編譯器得知大小的型別上使用。然而，你可以加上以下這個特殊語言來放寬這個限制：</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p><code>?Sized</code> 特徵約束與 <code>Sized</code> 特徵約束的效果相反：可以解讀為「<code>T</code> 可能是或不是 <code>Sized</code>」。這個語法只能用在 <code>Sized</code>，不適用於其他特徵。</p>
<p>也請注意，我們將參數 <code>t</code> 的型別由 <code>T</code> 轉為 <code>&amp;T</code>，是因為這個型別可能不是 <code>Sized</code>，所以我們需要將它放在指標之後才能使用之，而在這例子中，我們選擇將它放在引用之後。
接下來，我們會聊聊函式和閉包！</p>
<blockquote>
<ul>
<li>translators: [Weihang Lo <a href="mailto:me@weihanglo.tw">me@weihanglo.tw</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/5c71aac64380f74f34cd9a158cc2b1d9122b5ceb/src/ch19-04-advanced-types.md">5c71aac</a></li>
<li>updated: 2020-09-16</li>
</ul>
</blockquote>
<h2><a class="header" href="#進階函式與閉包" id="進階函式與閉包">進階函式與閉包</a></h2>
<p>接下來，我們會探索函式與閉包相關的進階特色，包括函式指標和回傳閉包。</p>
<h3><a class="header" href="#函式指標" id="函式指標">函式指標</a></h3>
<p>我們已探討過如何將閉包傳遞給函式，其實你還可以將一般的函式傳給函式！當你想要傳遞已經定義好的函式，而不是新的閉包時，就會凸顯這個技巧好用之處。有了函式指標，就可以將函式當作其他函式的引數，而這個作為引數的函式會轉型為 <code>fn</code> 型別（小寫的 f），別和閉包特徵的 <code>Fn</code> 搞混了。這個 <code>fn</code> 型別就稱為<strong>函式指標（function pointer）</strong>。其語法與閉包語法類似，可用於將函式指標作為參數的型別，如範例 19-27 所示。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;答案是：{}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">範例 19-27：藉由 <code>fn</code> 型別接收函式指標引數</span></p>
<p>這段程式碼會印出 <code>答案是：12</code>。我們可以指定 <code>do_twice</code> 的參數 <code>f</code> 是一個需要一個 <code>i32</code> 當參數的 <code>fn</code>，並會回傳 <code>i32</code>。接下來我們在 <code>do_twice</code> 內呼叫 <code>f</code>。在 <code>main</code> 中，我們就可將 <code>add_one</code> 函式作為 <code>do_twice</code> 第一個引數。</p>
<p>和閉包不同的是，<code>fn</code> 不是特徵而是一個型別，所以我們可以直接將 <code>fn</code> 作為參數型別，而不需要宣告一個以 <code>Fn</code> 特徵作為特徵限制的泛型型別參數。</p>
<p>函式指標將 三個閉包特徵（<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>）通通實作了，所以在預期要傳入閉包之處，你一定可以將函式指標作為引數傳進去。最佳的 做法是寫一個同時使用泛型型別和其中一個閉包特徵的函式，這樣無論是函式還是閉包，你的函式全都可以接收。</p>
<p>有個你只會想接收 <code>fn</code> 但不要閉包例子，就是當你在與外部那些沒有閉包的程式碼打交道的時候，比如 C 可以接收函式作為引數，但 C 並沒有閉包。</p>
<p>讓我們來看一下 <code>map</code> 的用法，<code>map</code> 就是可以用行內閉包（closure defined inline）或一個命名函式（named function）的例子。欲將數字的 vector 轉換成字串的 vector，我們可以使用閉包，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(|i| i.to_string()).collect();
<span class="boring">}
</span></code></pre></pre>
<p>或者，我們也可以將一個函式作為引數，代替閉包傳入 <code>map</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let list_of_numbers = vec![1, 2, 3];
    let list_of_strings: Vec&lt;String&gt; =
        list_of_numbers.iter().map(ToString::to_string).collect();
<span class="boring">}
</span></code></pre></pre>
<p>請注意，因為有多個可用的函式都叫做 <code>to_string</code>，所以我們必須使用先前在<a href="ch19-03-advanced-traits.html#%E9%80%B2%E9%9A%8E%E7%89%B9%E5%BE%B5">「進階特徵」</a>一節提及的完全限定語法。這裡，我們使用了在 <code>ToString</code> 特徵中定義的 <code>to_string</code> 函式，只要有實作 <code>Display</code> 的型別，標準函式庫都會提供 <code>ToString</code> 的實作。</p>
<p>另一個實用模式是深度利用元組結構體和在枚舉變體（enum variant）中的的元組結構體的實作細節。這些型別以 <code>()</code> 作為初始化語法，看起來就像函式呼叫。事實上這些初始化以函式來實作，這個函式接收引數來建立並回傳一個實例。我們可以將這些初始化函式當作實作了閉包特徵的函式指標，這就代表我們可以指定初始化函式作為引數，傳給需要閉包的方法，例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum Status {
        Value(u32),
        Stop,
    }

    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();
<span class="boring">}
</span></code></pre></pre>
<p>這裡，我們對一個範圍呼叫 <code>map</code>，並用每個 <code>u32</code> 值，透過 <code>Status::Value</code> 的初始化函式來建立 <code>Status::Value</code> 的實例。有些人更喜歡上述的作法，但有人偏好閉包。這兩者的編譯結果相同，所以選一個你覺得清晰的風格吧。</p>
<h3><a class="header" href="#回傳閉包" id="回傳閉包">回傳閉包</a></h3>
<p>閉包是用特徵來表示，言下之意是你不能直接回傳一個閉包。大多數的情況，當你想回傳一個特徵時，可以改回傳有實作該特徵的具體型別。但你並無法對閉包這樣做，因為它們根本沒有可供回傳的具體型別，比方說不允許你使用 <code>fn</code> 函式指標作為回傳型別。</p>
<p>接下來的程式碼嘗試直接回傳一個閉包，但它無法編譯：</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>編譯錯誤如下：</p>
<pre><code class="language-console">$ cargo build
   Compiling functions-example v0.1.0 (file:///projects/functions-example)
error[E0277]: the size for values of type `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)` cannot be known at compilation time
 --&gt; src/lib.rs:1:25
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)`
  = note: to learn more, visit &lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait&gt;
  = note: the return type of a function must have a statically known size

error[E0308]: mismatched types
 --&gt; src/lib.rs:2:5
  |
1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {
  |                         ------------------ expected `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)` because of return type
2 |     |x| x + 1
  |     ^^^^^^^^^ expected trait `std::ops::Fn`, found closure
  |
  = note: expected trait object `(dyn std::ops::Fn(i32) -&gt; i32 + 'static)`
                  found closure `[closure@src/lib.rs:2:5: 2:14]`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `functions-example`.

To learn more, run the command again with --verbose.
</code></pre>
<p>這個錯誤再度指出 <code>Sized</code> 特徵！Rust 不知道我們需要多少空間儲存這個閉包，我們之前看過這類問題的解法。可以使用特徵物件（trait object）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<p>這段程式碼恰巧能通過編譯。欲知更多特徵物件相關資訊，請查閱第十七章<a href="ch17-02-trait-objects.html#%E5%85%81%E8%A8%B1%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%88%A5%E6%95%B8%E5%80%BC%E7%9A%84%E7%89%B9%E5%BE%B5%E7%89%A9%E4%BB%B6">「允許不同型別數值的特徵物件」</a>部分。</p>
<p>接下來，一起來關注巨集吧！</p>
<blockquote>
<ul>
<li>translators: [Weihang Lo <a href="mailto:me@weihanglo.tw">me@weihanglo.tw</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch19-05-advanced-functions-and-closures.md">d44317c</a></li>
<li>updated: 2020-09-17</li>
</ul>
</blockquote>
<h2><a class="header" href="#巨集" id="巨集">巨集</a></h2>
<p>在本書中，我們到處使用像 <code>println!</code> 這類的巨集（macro），但尚未完全探索巨集究竟是何物，以及該如何駕馭。<strong>巨集</strong>指的是一整家族的 Rust 功能集合：使用 <code>macro_rules!</code> 的<strong>宣告式（declarative）巨集</strong>，以及另外三種<strong>程序式（procedural）巨集</strong>：</p>
<ul>
<li>客製化 <code>#[derive]</code> 巨集，可以將指定的程式碼加在使用 <code>derive</code> 屬性的結構體和枚舉</li>
<li>類屬性巨集，定義客製化，可以用在任何項目（item）的屬性</li>
<li>類函式巨集，看起來在呼叫函式但實際上將標記（token）當作引數來處理</li>
</ul>
<p>我們將會按照順序聊聊每種巨集，但首先，來看看為什麼我們已經有了函式，仍需要巨集呢？</p>
<h3><a class="header" href="#巨集與函式的差異" id="巨集與函式的差異">巨集與函式的差異</a></h3>
<p>基本上，巨集是一種透過寫程式碼來產生其他程式碼的手段，又稱作<strong>超程式設計（metaprogramming）</strong>。像是在附錄 C，我們探討的 <code>derive</code> 屬性，這個屬性會替你產生多種特徵的實作。還有在整本書中到處使用 <code>println!</code> 和 <code>vec!</code> 兩巨集。以上這些巨集都會<strong>展開</strong>來，產生比你自己手寫的還要多的程式碼。</p>
<p>超程式設計對減少撰寫和維護的程式碼量非常有幫助，這和函式扮演的角色相同，然而，巨集具有函式沒有的特殊本事。</p>
<p>一個函式簽名必須宣告該函式需要的參數型別與數量。反觀巨集可以接收變動數量的參數：我們可以用一個參數呼叫 <code>println!(&quot;hello&quot;)</code> ，也可以是兩個參數的 <code>println!(&quot;hello {}&quot;, name)</code>。另外，巨集會在編譯器開始翻譯程式碼的意義之前展開。例如可以使用巨集實作一個特徵。這種事函式便無法做到，因為函式會在執行期呼叫，而特徵需要在編譯期就實作。</p>
<p>選擇實作巨集而不用函式也有缺點，巨集的定義比函式更加複雜，因為你是在寫寫 Rust 程式碼的 Rust 程式碼。就是因為這種間接迂迴的關係，一般情況下，相較於函式來說巨集的定義都更加難以閱讀、理解與維護。</p>
<p>另一個巨集和函式之間的重要的的差異，在一個檔案中想呼叫巨集，必須在作用域（scope）內定義或是將巨集帶到這個作用域，而反過來函式可以在任何地方定義與呼叫。</p>
<h3><a class="header" href="#使用-macro_rules-宣告式巨集做普通的超程式設計" id="使用-macro_rules-宣告式巨集做普通的超程式設計">使用 <code>macro_rules!</code> 宣告式巨集做普通的超程式設計</a></h3>
<p>Rust 中最廣泛使用的巨集形式非<strong>宣告式巨集</strong>莫屬。這種巨集有時也稱為「巨集為例（macros by example）」、「<code>macro_rules!</code>」，或是直白的「巨集」。宣告式巨集的核心就是賦予你寫些類似 Rust <code>match</code> 表達式的東西。在第六章我們聊了 <code>match</code> 表達式是一種流程控制結構，會拿一個表達式，將其結果值與其他模式作比較，並執行匹配模式對應的程式碼。巨集同樣會拿一個值，與模式相比較，而這個模式又與特定程式碼相關聯：這種情況會是，傳入巨集的值就是一字一字刻出來 Rust 原始碼，而所謂模式則是比較原始碼的結構，當原始碼與模式相匹配，就會帶入與模式關聯的這段特定程式碼，取代原先傳入巨集的原始碼。這些都發生在編譯的期間。</p>
<p>你可以透過 <code>macro_rules!</code> 定義一個巨集。讓我們藉著閱讀 <code>vec!</code> 的定義來探索如何使用 <code>macro_rules!</code>。第八章我們介紹了如何使用 <code>vec!</code> 巨集來建立含有特定值的 vector。例如，下面的巨集會建立帶著三個整數的新 vector：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>我們也可利用 <code>vec!</code> 巨集產生兩個整數的 vector 或是五個字串的 slice。因為不能預先得知這些值的數量，所以我們無法透過函式做到這件事。</p>
<p>範例 19-28 展示了稍微簡化過的 <code>vec!</code> 巨集定義。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-28：<code>vec!</code> 巨集定義簡化版</span></p>
<blockquote>
<p>注意：在標準函式庫中真實的 <code>vec!</code> 巨集定義有預先配置正確記憶體用量的程式碼，因為這段程式碼是一種最佳化手段，為了簡化範例，並無將之包含其中。</p>
</blockquote>
<p>這個 <code>#[macro_export]</code> 標註（annotation）用來指明只要這個 crate 有在程式碼可見作用域中，就可以使用該巨集。若沒有這個標註，巨集就不能帶入該作用域內。</p>
<p>我們的巨集定義從 <code>macro_rules!</code> 和我們欲定義的巨集名稱<strong>去除</strong>驚嘆號開始。這個名稱，在我們例子裡是 <code>vec</code>，的後面接著花括號表示巨集定義的本體。</p>
<p>這個 <code>vec!</code> 本體的結構和 <code>match</code> 表達式的結構相似。這裡我們有一個 match 分支，帶著模式 <code>( $( $x:expr ),* )</code>，並接著 <code>=&gt;</code> 後面與該模式相關聯的程式碼區塊。這個分支是此巨集唯一一個模式，所以只有一個合法匹配方式；任何其他模式都會產生錯誤。更複雜的巨集會有多於一個分支。</p>
<p>合法的巨集定義模式語法和在第十八章的模式語法並不相同，巨集的模式並不跟值比較，而是與 Rust 程式碼的結構相互匹配。在範例 19-28 我們會走過一次這些模式的意義，至於完整的巨集模式語法，請閱讀<a href="../reference/macros-by-example.html">參考手冊</a>。</p>
<p>首先，一對圓括號包圍整個模式。在括號後面的錢字號（<code>$</code>）捕獲了在括號內匹配該模式的值，用來取代該段程式碼。在 <code>$()</code> 內的 <code>$x:expr</code> 會匹配任意 Rust 表達式，並給這個表達式一個 <code>$x</code> 名。</p>
<p>在 <code>$()</code> 後的逗號代表字面上的逗號分隔，可以選擇性地在匹配 <code>$()</code> 內的程式碼後出現。而 <code>*</code> 這指明，這個模式可以匹配零至多個在 <code>*</code> 之前的東西。</p>
<p>當我們的以 <code>vec![1, 2, 3]</code> 呼叫這個巨集，<code>$x</code> 模式會匹配到三次，分別為 <code>1</code>、<code>2</code> 和 <code>3</code> 三個表達式。</p>
<p>現在來看看這個模式分支的主體程式碼：在 <code>$()*</code> 內的 <code>temp_vec.push()</code> 會根據 <code>$()</code> 模式匹配了幾次而產生幾次。這個 <code>$x</code> 會被每個匹配的表達式取代。當我們使用 <code>vec![1, 2, 3]</code> 呼叫巨集時，這個取代巨集呼叫而產生出來的程式碼會是：</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<p>我們定義了一個巨集，接收任意數量任意型別的引數，並產生建立一個包含指定元素的 vector 的程式碼。</p>
<p>有鑑於 <code>macro_rules!</code> 仍有些詭異的邊界情況（edge case），未來 Rust 會有第二類宣告式巨集，會具有相似的工作流程，但會修復這些邊界情況。在該更新到來過後，<code>macro_rules!</code> 會即期棄用（deprecate）。考量到這點，加上以事實來說大多數 Rust 程式設計師<strong>使用</strong>巨集多過<strong>撰寫</strong>巨集，所以 <code>macro_rules!</code> 相關討論就此打住，想理解更多有關撰寫巨集之事，可查閱線上文件或其他資源，例如<a href="https://danielkeep.github.io/tlborm/book/index.html">「The Little Book of Rust Macros」</a>。</p>
<h3><a class="header" href="#使用程序式巨集從屬性產生程式碼" id="使用程序式巨集從屬性產生程式碼">使用程序式巨集從屬性產生程式碼</a></h3>
<p>第二種巨集形式是<strong>程序式巨集</strong>，其行為更像是函式（也是一種程序）。程序式巨集接受一些程式碼作為輸入，操作這些程式碼，然後輸出一些程式碼。和宣告式巨集去匹配模式和取代程式碼的方式不同。</p>
<p>三種程序式巨集（客製化 derive，類屬性、類函式）都有著相近的工作方式。</p>
<p>當建立一個程序式巨集時，該巨集必須放置在自己特殊的一種 crate 中。會這種是因為一些複雜的技術問題，我們希望在未來消弭這個情況。使用程序式巨集看起來就像範例 19-29，其中 <code>some_attribute</code> 是一個用來代表特定巨集的佔位符。</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<p><span class="caption">範例 19-29：使用程序式巨集</span></p>
<p>這個函式定義一個程序式巨集，接受輸入 <code>TokenStream</code>，並輸入 <code>TokenStream</code>。<code>TokenStream</code> 型別定義在 <code>proc_macro</code> crate 中，這個 crate 包含在 Rust 中，可以表示一連串的標記，這就是巨集的核心：巨集替來自輸入的 <code>TokenStream</code> 搽脂抹粉，而巨集產生的程式碼就是輸出的 <code>TokenStream</code>。上面例子中這個函式附加了一個屬性，指定我們要產生哪個程序式巨集。在同一個 crate 中我們可以使用多個不同的程序式巨集。</p>
<p>我們來看不同的程序式巨集吧。就從客製化 derive 巨集開始，逐步介紹它與其他種類巨集的細部差異。</p>
<h3><a class="header" href="#如何撰寫客製化的-derive-巨集" id="如何撰寫客製化的-derive-巨集">如何撰寫客製化的 <code>derive</code> 巨集</a></h3>
<p>我們建立一個 <code>hello_macro</code> crate，並定義 <code>HelloMacro</code> 特徵與它的 <code>hello_macro</code> 關聯函式。我們提供一個程序式巨集，讓使用者透過 <code>#[derive(HelloMacro)]</code> 標註它們的型別，來獲得預設的 <code>hello_macro</code> 函式的實作，而不需要使用者替每個型別手動實作 <code>HelloMacro</code> 特徵。這個預設的函式實作會印出 <code>你好，巨集，我叫作型別名稱！</code>，其中 <code>型別名稱</code> 是實作特徵那個型別的名字。換句話說，就是我們會寫出一個 crate，讓其他程式設計師用我們的 crate，以範例 19-30 的方式來寫程式。</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">範例 19-30：使用者使用我們的程序式巨集時，能夠寫出的程式碼</span></p>
<p>當我們完成後，這段程式碼會印出 <code>你好，巨集！我叫作鬆餅！</code>。第一步，先建立一個新的函式庫 crate：</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<p>接下來，我們會定義 <code>HelloMacro</code> 特徵與它的關聯函式：</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<p>我們有個特徵及其函式。至此，我們的 crate 使用者可以實作此特徵來達成他們想要的功能，例如：</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;你好，巨集！我叫作鬆餅！&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>然而，使用者必須自行替每個想使用 <code>hello_macro</code> 的型別分別撰寫實作區塊，我們想節約這些重複工作。</p>
<p>另外，我們尚未提供 <code>hello_macro</code> 函式的預設實作，這個預設實作將會印出實作該特徵的型別名稱，但 Rust 並沒有反射（reflection）這種功能，所以無法在執行期檢查型別，因此我們需要一個巨集在編譯期產生程式碼。</p>
<p>下一步是定義程序式巨集。在我們寫此章時，程序式巨集必須在自己的 crate 中定義，最終這個限制會解除。組織安排 crate 和巨集 crate 的慣例如下：有一個 crate <code>foo</code> 和一個客製化 derive 程序式巨集 crate <code>foo_derive</code>，讓我們在 <code>hello_macro</code> 專案中建立一個新的 crate <code>hello_macro_derive</code>：</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<p>由於我們的兩個 crate 高度關聯，所以會在 <code>hello_macro</code> crate 的目錄中建立一個程序式巨集 crate。若我們改變 <code>hello_macro</code> 中定義的特徵，就必須同時改變 <code>hello_macro_derive</code> 中的程序式巨集。這兩個 crate 必須各自發佈，且若程式設計師想要使用這些 crate，則必須將兩者都加入為依賴（dependency），並將之帶入作用域。當然，我們也可以讓 <code>hello_macro</code> 將 <code>hello_macro_derive</code> 作為一個依賴並重新導出（re-export）該程序式巨集。然而，我們這樣組織專案的方式就是想提供當程式設計師不想要 <code>derive</code> 功能時，也可以直接使用 <code>hello_macro</code>。</p>
<p>我們必須宣告 <code>hello_macro_derive</code> 為一個程序式巨集 crate。我們同時需要等會兒就會遇到的 <code>syn</code> 和 <code>quote</code> 這些 crate 的功能，所以先將他們加至依賴。至此，<code>hello_macro_derive</code> 的 <em>Cargo.toml</em> 會加入以下的程式碼：</p>
<p><span class="filename">檔案名稱：hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<p>欲開始定義程序式巨集，請將範例 19-31 的程式碼放入你的 <code>hello_macro_derive</code> crate 的 <em>src.lib.rs</em> 檔案中。注意，在我們定義 <code>impl_hello_macro</code> 函式之前，這段程式碼都無法編譯。</p>
<p><span class="filename">檔案名稱：hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}
</code></pre>
<p><span class="caption">範例 19-31：若要產生 Rust 程式碼，絕大部分程序式巨集 crate 都必須包含這段程式碼</span></p>
<p>留意到了嗎，我們將程式碼函式拆分，其中 <code>hello_macro_derive</code> 函式負責解析 <code>TokenStream</code>，而 <code>impl_hello_macro</code> 函式則用來轉換語法樹（syntax tree），這讓撰寫程序式巨集更為方便。外面這個函式的程式碼（在這例子是 <code>hello_macro_derive</code>）在每個你遇見或建立的程序式巨集裡看起來都幾乎一模一樣。而在裡面的函式（在這個例子是 <code>impl_hello_macro</code>）的本體則根據不同程序式巨集的目的而有所不同。</p>
<p>我們導入了三個新 crate：<code>proc_macro</code>，<a href="https://crates.io/crates/syn"><code>syn</code></a> 和 <a href="https://crates.io/crates/quote"><code>quote</code></a>。<code>proc_macro</code> 包含在 Rust 裡面，所以我們不需要將之加入 <em>Cargo.toml</em>。<code>proc_macro</code> crate 就是編譯器的 API，提供從我們的程式碼讀取和操作 Rust 程式碼。</p>
<p><code>syn</code> crate 負責從字串解析 Rust 程式碼，轉成我們可以操作的資料結構。而 <code>qoute</code> crate 則將 <code>syn</code> 的資料結構轉回 Rust 程式碼。撰寫完整的Rust 程式碼解析器並不是容易的工作，而這些 crate 讓解析任何 Rust 程式碼更為簡便。</p>
<p>當使用者在一個型別上指定 <code>#[derive(HelloMacro)]</code>，<code>hello_macro_derive</code> 函式就會被呼叫，這是由於我們使用 <code>proc_macro_derive</code> 和指定的 <code>HelloMacro</code> 名稱來標註 <code>hello_macro_derive</code> 函式，而其中的 <code>HelloMacro</code> 是我們的特徵名稱。以上就是大多數程序式巨集遵守的慣例。</p>
<p><code>hello_macro_derive</code> 函式會先將輸入 <code>input</code> 的 <code>TokenStream</code> 轉換成一個我們可以翻譯並執行操作的資料結構，這就是 <code>syn</code> 參與的部分，<code>syn</code> 的 <code>parse</code> 函式需要一個 <code>TokenStream</code> 並回傳一個 <code>DeriveInput</code> 結構體，代表解析過後的 Rust 程式碼。範例 19-32 展示了解析完 <code>struct Pancakes</code> 字串後所得的 <code>DeriveInput</code> 的部分：</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<p><span class="caption">範例 19-32：這是在範例 19-30 解析具有 macro 屬性的程式碼時所得的 <code>DeriveInput</code> 實例</span></p>
<p>這些結構體的欄位展示了解析過後的 Rust 程式碼是一個結構體，帶著 <code>ident</code>（識別字 identifier）。這裡其他結構體的欄位都在描述 Rust 程式碼，更多資訊請參考 <a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html"><code>syn</code> 有關 <code>DeriveInput</code> 的文件</a>。</p>
<p>我們很快就進入定義 <code>impl_hello_macro</code> 函式的環節，這個函式協助打造我們想要的新 Rust 程式碼。再動手做之前，注意我們的 derive 巨集輸出也是一個 <code>TokenStream</code>。回傳的 <code>TokenStream</code> 會添加到我們的 crate 使用者撰寫的程式碼中，因此，當他們編譯他們的 crate 時，會從我們提供的修編過的 <code>TokenStream</code> 中取得額外功能。</p>
<p>也許你注意到我們對 <code>hello_macro_derive</code> 呼叫 <code>unwrap</code> 讓 <code>sync::parse</code> 函式失敗時恐慌。由於我們需要符合 <code>proc_macro_derive</code> 程序式巨集的 API 定 義，回傳一個 <code>TokenStream</code> 而非 <code>Result</code>，所以我們的程序式巨集必須在錯誤時恐慌。這裡使用 <code>unwrap</code> 是為了簡化範例，在正式環境程式碼中，你應該透過 <code>panic!</code> 或 <code>expect</code> 提供更特定的錯誤訊息，告知什麼出錯了。</p>
<p>現在，被標註的 Rust 程式碼已經從一個 <code>TokenStream</code> 轉換成 <code>DeriveInput</code> 實例，現在來替被標註的型別產生實作 <code>HelloMacro</code> 特徵的程式碼，如範例 19-33。</p>
<p><span class="filename">檔案名稱：hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate proc_macro;
</span><span class="boring">
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;你好，巨集，我叫作{}！&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre>
<p><span class="caption">範例 19-33：利用解析過的 Rust 程式碼來實作 <code>HelloMacro</code> 特徵</span></p>
<p>我們從 <code>ast.ident</code> 取得 <code>Ident</code> 結構體實例，這個實例中帶有被標註的型別之名稱（識別字）。當我們執行在範例 19-30 程式碼中的 <code>impl_hello_macro</code> 函式，會獲得一個 <code>ident</code>，帶有一個值為 <code>&quot;Pancakes&quot;</code> 的 <code>ident</code> 欄位，就如同範例 19-30 所示。因此，在範例 19-33 的 <code>name</code> 變數會包含一個 <code>Ident</code> 結構體實例，當我們印之，會出現字串 <code>&quot;Pancakes&quot;</code>，也就是該結構體在範例 19-30 所示的名字。</p>
<p><code>quote!</code> 巨集提供我們定義想要回傳的 Rust 程式碼。編譯器期望接收到不同於 <code>quote!</code> 巨集執行後直接輸出的結果，所以我們需要將結果轉換為一個 <code>TokenStream</code>。我們透過呼叫 <code>into</code> 方法達成，這個方法會消耗中介碼（intermediate representation）並回傳一個型別為 <code>TokenStream</code> 之值。</p>
<p><code>quote!</code> 巨集也提供非常炫的模板機制：我們可以輸入 <code>#name</code>，而 <code>quote!</code> 會以變數 <code>name</code> 值取而代之。我們甚至可以做一些類似普通巨集的重複工作。閱讀 <a href="https://docs.rs/quote"><code>quote</code> crate 的文件</a>以獲得完整的介紹。</p>
<p>我們想要我們的程序式巨集對使用者標註的型別產生 <code>HelloMacro</code> 特徵的實作，這個標註的型別名稱可以從 <code>#name</code> 取得。這個特徵的實作有一個函式 <code>hello_macro</code>，函式本體包含我們想要的功能：印出 <code>你好，巨集，我叫作</code> 再加上被標註的型別的名稱。</p>
<p><code>stringify!</code> 巨集是 Rust 內建的，會將一個 Rust 表達式，例如 <code>1 + 2</code>，在編譯期轉換成字串字面值（string literal），例如 <code>&quot;1 + 2&quot;</code>。這和 <code>format!</code> 或 <code>println!</code> 巨集會對表達式求值並將結果轉為 <code>String</code> 不同。因為輸入的 <code>#name</code> 可能是一個表達式，但要直接照字面印出來，所以我們選擇使用 <code>stringify!</code>。使用 <code>stringify!</code> 也可以節省在編譯器因為轉換 <code>#name</code> 成為字串字面量所需的空間配置。</p>
<p>至此，<code>cargo build</code> 應該可以成功在 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 完成。我們在範例 19-30 來玩玩這些 crate 看看他們如何實際作用！先在你的<strong>專案</strong>目錄下，透過 <code>cargo new pancakes</code> 建立一個新的二進制專案。我們必須將 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 加入 <code>pancakes</code> 的 <em>Cargo.toml</em> 作為依賴。若你已經發佈自己的 <code>hello_macro</code> 和 <code>hello_macro_derive</code> 的版本到 <a href="https://crates.io/">crates.io</a>，他們就是普通的依賴；若無，你可以指定他們為 <code>path</code> 的依賴，如下：</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>將這段程式碼放到範例 19-30 的 <em>src/main.rs</em> 並執行 <code>cargo run</code>，他應該會印出 <code>你好，巨集！我叫作鬆餅！</code>。這個由程序式巨集實作的 <code>HelloMacro</code> 特徵，不需要 <code>pancakes</code> 自行手動實作，而是透過 <code>#[derive(HelloMacro)]</code> 將特徵的實作加上去。</p>
<p>接著，一起來探索其他種類的程序式巨集和客製化 derive 巨集有何不同。</p>
<h3><a class="header" href="#類屬性巨集" id="類屬性巨集">類屬性巨集</a></h3>
<p>類屬性巨集和客製化 derive 巨集相似，但並非只能透過 <code>derive</code> 屬性產生程式碼，類屬性巨集讓你可以建立新的屬性。它們更靈活：<code>derive</code> 只能用在結構體和枚舉，而屬性可以用在其他項目之上，例如函式。這裡有個類屬性巨集例子，是在使用一個網頁應用程式框架時，透過你的 <code>route</code> 屬性來標註一個函式：</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<p>這個 <code>#[route]</code> 屬性在該框架以程序式巨集定義之，其巨集定義函式的簽名如下：</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<p>這裡，我們有兩個 <code>TokenStream</code> 型別的參數，第一個是屬性的內容，也就是 <code>Get, &quot;/&quot;</code> 這部分。第二部分則是該屬性附著的項目本體：在這個例子就是 <code>fn index() {}</code> 及其函式本體。</p>
<p>除此之外，類屬性巨集的工作方式和客製化 derive 巨集一樣：透過 <code>proc-macro</code> crate 建立一個 crate，並實作一個函式替你產生程式碼！</p>
<h3><a class="header" href="#類函式巨集" id="類函式巨集">類函式巨集</a></h3>
<p>類函式巨集可以定義和函式呼叫很類似的巨集。和 <code>marco_rules!</code> 一樣，類函式巨集比函式更有靈活，例如可以接收未知長度的引數。然而，<code>macro_rules!</code> 巨集只能使用像 match 一樣的語法，如同早前在<a href="ch19-06-macros.html#%E4%BD%BF%E7%94%A8-macro_rules-%E5%AE%A3%E5%91%8A%E5%BC%8F%E5%B7%A8%E9%9B%86%E5%81%9A%E6%99%AE%E9%80%9A%E7%9A%84%E8%B6%85%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">「使用 <code>macro_rules!</code> 宣告式巨集做普通的超程式設計」</a>一節所述。而類函式巨集則可以拿 <code>TokenStream</code> 參數及其定義來操作 Rust 程式碼，和另外兩個程序式巨集所做的一模一樣。</p>
<p>舉個例子，一個 <code>sql!</code> 類函式巨集可能會被這樣呼叫：</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<p>這個巨集會解析他內部的 SQL 陳述句（statement），並檢查語法是否正確，這個過程比 <code>macro_rules!</code> 能做到的複雜太多。這個 <code>sql!</code> 巨集定義如下：</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>這個定義和客製化 derive 巨集簽名相似：我們接受在圓括號內的標記，並回傳想要產生的程式碼。</p>
<h2><a class="header" href="#小結" id="小結">小結</a></h2>
<p>太帥了！現在你的工具箱多了一些 Rust 特色功能，雖然不常用，但在特定情況下你會知道它們存在。我們介紹了許多複雜的主題，所以當你在錯誤訊息或是其他人的程式碼與它們相遇，你會有辦法辨認這些概念和語法。你可以將這章作為能引導找到解法的參考書。</p>
<p>接下來，我們會動手做另一個專案，實際運用本書所講的一切。</p>
<blockquote>
<ul>
<li>translators: [Weihang Lo <a href="mailto:me@weihanglo.tw">me@weihanglo.tw</a>]</li>
<li>commit: <a href="https://github.com/rust-lang/book/blob/d44317c3122b44fb713aba66cc295dee3453b24b/src/ch19-06-macros.md">d44317c</a></li>
<li>updated: 2020-09-20</li>
</ul>
</blockquote>
<h1><a class="header" href="#final-project-building-a-multithreaded-web-server" id="final-project-building-a-multithreaded-web-server">Final Project: Building a Multithreaded Web Server</a></h1>
<p>It’s been a long journey, but we’ve reached the end of the book. In this
chapter, we’ll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.</p>
<p>For our final project, we’ll make a web server that says “hello” and looks like
Figure 20-1 in a web browser.</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">圖示 20-1: Our final shared project</span></p>
<p>Here is the plan to build the web server:</p>
<ol>
<li>Learn a bit about TCP and HTTP.</li>
<li>Listen for TCP connections on a socket.</li>
<li>Parse a small number of HTTP requests.</li>
<li>Create a proper HTTP response.</li>
<li>Improve the throughput of our server with a thread pool.</li>
</ol>
<p>But before we get started, we should mention one detail: the method we’ll use
won’t be the best way to build a web server with Rust. A number of
production-ready crates are available on <a href="https://crates.io/">crates.io</a> that
provide more complete web server and thread pool implementations than we’ll
build.</p>
<p>However, our intention in this chapter is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we can choose the
level of abstraction we want to work with and can go to a lower level than is
possible or practical in other languages. We’ll write the basic HTTP server and
thread pool manually so you can learn the general ideas and techniques behind
the crates you might use in the future.</p>
<h2><a class="header" href="#building-a-single-threaded-web-server" id="building-a-single-threaded-web-server">Building a Single-Threaded Web Server</a></h2>
<p>We’ll start by getting a single-threaded web server working. Before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.</p>
<p>The two main protocols involved in web servers are the <em>Hypertext Transfer
Protocol</em> <em>(HTTP)</em> and the <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both
protocols are <em>request-response</em> protocols, meaning a <em>client</em> initiates
requests and a <em>server</em> listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.</p>
<p>TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’ll work with the
raw bytes of TCP and HTTP requests and responses.</p>
<h3><a class="header" href="#listening-to-the-tcp-connection" id="listening-to-the-tcp-connection">Listening to the TCP Connection</a></h3>
<p>Our web server needs to listen to a TCP connection, so that’s the first part
we’ll work on. The standard library offers a <code>std::net</code> module that lets us do
this. Let’s make a new project in the usual fashion:</p>
<pre><code class="language-console">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 20-1 in <em>src/main.rs</em> to start. This code will
listen at the address <code>127.0.0.1:7878</code> for incoming TCP streams. When it gets
an incoming stream, it will print <code>Connection established!</code>.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">範例 20-1: Listening for incoming streams and printing
a message when we receive a stream</span></p>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address
<code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn’t
represent the authors’ computer specifically), and <code>7878</code> is the port. We’ve
chosen this port for two reasons: HTTP is normally accepted on this port, and
7878 is <em>rust</em> typed on a telephone.</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it
will return a new <code>TcpListener</code> instance. The reason the function is called
<code>bind</code> is that in networking, connecting to a port to listen to is known as
“binding to a port.”</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1024), so if
we tried to connect to port 80 without being an administrator, binding wouldn’t
work. As another example, binding wouldn’t work if we ran two instances of our
program and so had two programs listening to the same port. Because we’re
writing a basic server just for learning purposes, we won’t worry about
handling these kinds of errors; instead, we use <code>unwrap</code> to stop the program if
errors happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, <code>TcpStream</code> will read from itself to see what
the client sent and then allow us to write our response to the stream. Overall,
this <code>for</code> loop will process each connection in turn and produce a series of
streams for us to handle.</p>
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate
our program if the stream has any errors; if there aren’t any errors, the
program prints a message. We’ll add more functionality for the success case in
the next listing. The reason we might receive errors from the <code>incoming</code> method
when a client connects to the server is that we’re not actually iterating over
connections. Instead, we’re iterating over <em>connection attempts</em>. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.</p>
<p>Let’s try running this code! Invoke <code>cargo run</code> in the terminal and then load
<em>127.0.0.1:7878</em> in a web browser. The browser should show an error message
like “Connection reset,” because the server isn’t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes, you’ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the <em>favicon.ico</em> icon that appears in the
browser tab.</p>
<p>It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When <code>stream</code> goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the <code>drop</code> implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that we’ve successfully gotten a handle to a TCP connection!</p>
<p>Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when you’re done running a particular version of the code. Then restart <code>cargo run</code> after you’ve made each set of code changes to make sure you’re running the
newest code.</p>
<h3><a class="header" href="#reading-the-request" id="reading-the-request">Reading the Request</a></h3>
<p>Let’s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new <code>handle_connection</code> function, we’ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">範例 20-2: Reading from the <code>TcpStream</code> and printing
the data</span></p>
<p>We bring <code>std::io::prelude</code> into scope to get access to certain traits that let
us read from and write to the stream. In the <code>for</code> loop in the <code>main</code> function,
instead of printing a message that says we made a connection, we now call the
new <code>handle_connection</code> function and pass the <code>stream</code> to it.</p>
<p>In the <code>handle_connection</code> function, we’ve made the <code>stream</code> parameter mutable.
The reason is that the <code>TcpStream</code> instance keeps track of what data it returns
to us internally. It might read more data than we asked for and save that data
for the next time we ask for data. It therefore needs to be <code>mut</code> because its
internal state might change; usually, we think of “reading” as not needing
mutation, but in this case we need the <code>mut</code> keyword.</p>
<p>Next, we need to actually read from the stream. We do this in two steps:
first, we declare a <code>buffer</code> on the stack to hold the data that is read in.
We’ve made the buffer 1024 bytes in size, which is big enough to hold the
data of a basic request and sufficient for our purposes in this chapter. If
we wanted to handle requests of an arbitrary size, buffer management would
need to be more complicated; we’ll keep it simple for now. We pass the buffer
to <code>stream.read</code>, which will read bytes from the <code>TcpStream</code> and put them in
the buffer.</p>
<p>Second, we convert the bytes in the buffer to a string and print that string.
The <code>String::from_utf8_lossy</code> function takes a <code>&amp;[u8]</code> and produces a <code>String</code>
from it. The “lossy” part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with <code>�</code>, the <code>U+FFFD REPLACEMENT CHARACTER</code>. You might see replacement
characters for characters in the buffer that aren’t filled by request data.</p>
<p>Let’s try this code! Start the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but our
program’s output in the terminal will now look similar to this:</p>
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>Depending on your browser, you might get slightly different output. Now that
we’re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after <code>Request: GET</code>. If the
repeated connections are all requesting <em>/</em>, we know the browser is trying to
fetch <em>/</em> repeatedly because it’s not getting a response from our program.</p>
<p>Let’s break down this request data to understand what the browser is asking of
our program.</p>
<h3><a class="header" href="#a-closer-look-at-an-http-request" id="a-closer-look-at-an-http-request">A Closer Look at an HTTP Request</a></h3>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the
client is requesting. The first part of the request line indicates the <em>method</em>
being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making
this request. Our client used a <code>GET</code> request.</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>Uniform Resource
Identifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite,
the same as a <em>Uniform Resource Locator</em> <em>(URL)</em>. The difference between URIs
and URLs isn’t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.</p>
<p>The last part is the HTTP version the client uses, and then the request line
ends in a <em>CRLF sequence</em>. (CRLF stands for <em>carriage return</em> and <em>line feed</em>,
which are terms from the typewriter days!) The CRLF sequence can also be
written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>Looking at the request line data we received from running our program so far,
we see that <code>GET</code> is the method, <em>/</em> is the request URI, and <code>HTTP/1.1</code> is the
version.</p>
<p>After the request line, the remaining lines starting from <code>Host:</code> onward are
headers. <code>GET</code> requests have no body.</p>
<p>Try making a request from a different browser or asking for a different
address, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>
<p>Now that we know what the browser is asking for, let’s send back some data!</p>
<h3><a class="header" href="#writing-a-response" id="writing-a-response">Writing a Response</a></h3>
<p>Now we’ll implement sending data in response to a client request. Responses
have the following format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.</p>
<p>Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request! From the <code>handle_connection</code> function, remove the
<code>println!</code> that was printing the request data and replace it with the code in
Listing 20-3.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 20-3: Writing a tiny successful HTTP response to
the stream</span></p>
<p>The first new line defines the <code>response</code> variable that holds the success
message’s data. Then we call <code>as_bytes</code> on our <code>response</code> to convert the string
data to bytes. The <code>write</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends those
bytes directly down the connection.</p>
<p>Because the <code>write</code> operation could fail, we use <code>unwrap</code> on any error result
as before. Again, in a real application you would add error handling here.
Finally, <code>flush</code> will wait and prevent the program from continuing until all
the bytes are written to the connection; <code>TcpStream</code> contains an internal
buffer to minimize calls to the underlying operating system.</p>
<p>With these changes, let’s run our code and make a request. We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should
get a blank page instead of an error. You’ve just hand-coded an HTTP request
and response!</p>
<h3><a class="header" href="#returning-real-html" id="returning-real-html">Returning Real HTML</a></h3>
<p>Let’s implement the functionality for returning more than a blank page. Create
a new file, <em>hello.html</em>, in the root of your project directory, not in the
<em>src</em> directory. You can input any HTML you want; Listing 20-4 shows one
possibility.</p>
<p><span class="filename">檔案名稱：hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">範例 20-4: A sample HTML file to return in a
response</span></p>
<p>This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we’ll modify <code>handle_connection</code> as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::fs;
// --snip--

<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let response = format!(
        &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
        contents.len(),
        contents
    );

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 20-5: Sending the contents of <em>hello.html</em> as the
body of the response</span></p>
<p>We’ve added a line at the top to bring the standard library’s filesystem module
into scope. The code for reading the contents of a file to a string should look
familiar; we used it in Chapter 12 when we read the contents of a file for our
I/O project in Listing 12-4.</p>
<p>Next, we use <code>format!</code> to add the file’s contents as the body of the success
response. To ensure a valid HTTP response, we add the <code>Content-Length</code> header
which is set to the size of our response body, in this case the size of <code>hello.html</code>.</p>
<p>Run this code with <code>cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you
should see your HTML rendered!</p>
<p>Currently, we’re ignoring the request data in <code>buffer</code> and just sending back
the contents of the HTML file unconditionally. That means if you try requesting
<em>127.0.0.1:7878/something-else</em> in your browser, you’ll still get back this
same HTML response. Our server is very limited and is not what most web servers
do. We want to customize our responses depending on the request and only send
back the HTML file for a well-formed request to <em>/</em>.</p>
<h3><a class="header" href="#validating-the-request-and-selectively-responding" id="validating-the-request-and-selectively-responding">Validating the Request and Selectively Responding</a></h3>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting <em>/</em> before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify <code>handle_connection</code>,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for <em>/</em> looks like and adds <code>if</code> and
<code>else</code> blocks to treat requests differently.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

        let response = format!(
            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
            contents.len(),
            contents
        );

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
</code></pre></pre>
<p><span class="caption">範例 20-6: Matching the request and handling requests
to <em>/</em> differently from other requests</span></p>
<p>First, we hardcode the data corresponding to the <em>/</em> request into the <code>get</code>
variable. Because we’re reading raw bytes into the buffer, we transform <code>get</code>
into a byte string by adding the <code>b&quot;&quot;</code> byte string syntax at the start of the
content data. Then we check whether <code>buffer</code> starts with the bytes in <code>get</code>. If
it does, it means we’ve received a well-formed request to <em>/</em>, which is the
success case we’ll handle in the <code>if</code> block that returns the contents of our
HTML file.</p>
<p>If <code>buffer</code> does <em>not</em> start with the bytes in <code>get</code>, it means we’ve received
some other request. We’ll add code to the <code>else</code> block in a moment to respond
to all other requests.</p>
<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in
<em>hello.html</em>. If you make any other request, such as
<em>127.0.0.1:7878/something-else</em>, you’ll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.</p>
<p>Now let’s add the code in Listing 20-7 to the <code>else</code> block to return a response
with the status code 404, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating the response to the end user.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    if buffer.starts_with(get) {
</span><span class="boring">        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">        let response = format!(
</span><span class="boring">            &quot;HTTP/1.1 200 OK\r\nContent-Length: {}\r\n\r\n{}&quot;,
</span><span class="boring">            contents.len(),
</span><span class="boring">            contents
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        stream.write(response.as_bytes()).unwrap();
</span><span class="boring">        stream.flush().unwrap();
</span>    // --snip--
    } else {
        let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
        let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();

        let response = format!(&quot;{}{}&quot;, status_line, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    }
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 20-7: Responding with status code 404 and an
error page if anything other than <em>/</em> was requested</span></p>
<p>Here, our response has a status line with status code 404 and the reason
phrase <code>NOT FOUND</code>. We’re still not returning headers, and the body of the
response will be the HTML in the file <em>404.html</em>. You’ll need to create a
<em>404.html</em> file next to <em>hello.html</em> for the error page; again feel free to use
any HTML you want or use the example HTML in Listing 20-8.</p>
<p><span class="filename">檔案名稱：404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">範例 20-8: Sample content for the page to send back
with any 404 response</span></p>
<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em>
should return the contents of <em>hello.html</em>, and any other request, like
<em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>
<h3><a class="header" href="#a-touch-of-refactoring" id="a-touch-of-refactoring">A Touch of Refactoring</a></h3>
<p>At the moment the <code>if</code> and <code>else</code> blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make the code more
concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large <code>if</code> and <code>else</code> blocks.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span>    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre></pre>
<p><span class="caption">範例 20-9: Refactoring the <code>if</code> and <code>else</code> blocks to
contain only the code that differs between the two cases</span></p>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code>
statement, as discussed in Chapter 18.</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and
uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.</p>
<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let’s examine how that can be a problem by simulating some
slow requests. Then we’ll fix it so our server can handle multiple requests at
once.</p>
<h2><a class="header" href="#turning-our-single-threaded-server-into-a-multithreaded-server" id="turning-our-single-threaded-server-into-a-multithreaded-server">Turning Our Single-Threaded Server into a Multithreaded Server</a></h2>
<p>Right now, the server will process each request in turn, meaning it won’t
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We’ll need to fix
this, but first, we’ll look at the problem in action.</p>
<h3><a class="header" href="#simulating-a-slow-request-in-the-current-server-implementation" id="simulating-a-slow-request-in-the-current-server-implementation">Simulating a Slow Request in the Current Server Implementation</a></h3>
<p>We’ll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to <em>/sleep</em> with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span>use std::thread;
use std::time::Duration;
// --snip--
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        handle_connection(stream);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn handle_connection(mut stream: TcpStream) {
    // --snip--

<span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span>    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --snip--
<span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span>}
</code></pre></pre>
<p><span class="caption">範例 20-10: Simulating a slow request by recognizing
<em>/sleep</em> and sleeping for 5 seconds</span></p>
<p>This code is a bit messy, but it’s good enough for simulation purposes. We
created a second request <code>sleep</code>, whose data our server recognizes. We added an
<code>else if</code> after the <code>if</code> block to check for the request to <em>/sleep</em>. When that
request is received, the server will sleep for 5 seconds before rendering the
successful HTML page.</p>
<p>You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!</p>
<p>Start the server using <code>cargo run</code>. Then open two browser windows: one for
<em>http://127.0.0.1:7878/</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If
you enter the <em>/</em> URI a few times, as before, you’ll see it respond quickly.
But if you enter <em>/sleep</em> and then load <em>/</em>, you’ll see that <em>/</em> waits until
<code>sleep</code> has slept for its full 5 seconds before loading.</p>
<p>There are multiple ways we could change how our web server works to avoid
having more requests back up behind a slow request; the one we’ll implement is
a thread pool.</p>
<h3><a class="header" href="#improving-throughput-with-a-thread-pool" id="improving-throughput-with-a-thread-pool">Improving Throughput with a Thread Pool</a></h3>
<p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it’s returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.</p>
<p>We’ll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our server’s resources and grinding
the processing of requests to a halt.</p>
<p>Rather than spawning unlimited threads, we’ll have a fixed number of threads
waiting in the pool. As requests come in, they’ll be sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process
<code>N</code> requests concurrently, where <code>N</code> is the number of threads. If each thread
is responding to a long-running request, subsequent requests can still back up
in the queue, but we’ve increased the number of long-running requests we can
handle before reaching that point.</p>
<p>This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model and the
single-threaded async I/O model. If you’re interested in this topic, you can
read more about other solutions and try to implement them in Rust; with a
low-level language like Rust, all of these options are possible.</p>
<p>Before we begin implementing a thread pool, let’s talk about what using the
pool should look like. When you’re trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it’s
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.</p>
<p>Similar to how we used test-driven development in the project in Chapter 12,
we’ll use compiler-driven development here. We’ll write the code that calls the
functions we want, and then we’ll look at errors from the compiler to determine
what we should change next to get the code to work.</p>
<h4><a class="header" href="#code-structure-if-we-could-spawn-a-thread-for-each-request" id="code-structure-if-we-could-spawn-a-thread-for-each-request">Code Structure If We Could Spawn a Thread for Each Request</a></h4>
<p>First, let’s explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn’t our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point. Listing 20-11 shows the changes to make to <code>main</code> to spawn a
new thread to handle each stream within the <code>for</code> loop.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 20-11: Spawning a new thread for each
stream</span></p>
<p>As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
<em>/sleep</em> in your browser, then <em>/</em> in two more browser tabs, you’ll indeed see
that the requests to <em>/</em> don’t have to wait for <em>/sleep</em> to finish. But as we
mentioned, this will eventually overwhelm the system because you’d be making
new threads without any limit.</p>
<h4><a class="header" href="#creating-a-similar-interface-for-a-finite-number-of-threads" id="creating-a-similar-interface-for-a-finite-number-of-threads">Creating a Similar Interface for a Finite Number of Threads</a></h4>
<p>We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesn’t require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a <code>ThreadPool</code>
struct we want to use instead of <code>thread::spawn</code>.</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-12: Our ideal <code>ThreadPool</code> interface</span></p>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number
of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a
similar interface as <code>thread::spawn</code> in that it takes a closure the pool should
run for each stream. We need to implement <code>pool.execute</code> so it takes the
closure and gives it to a thread in the pool to run. This code won’t yet
compile, but we’ll try so the compiler can guide us in how to fix it.</p>
<h4><a class="header" href="#building-the-threadpool-struct-using-compiler-driven-development" id="building-the-threadpool-struct-using-compiler-driven-development">Building the <code>ThreadPool</code> Struct Using Compiler Driven Development</a></h4>
<p>Make the changes in Listing 20-12 to <em>src/main.rs</em>, and then let’s use the
compiler errors from <code>cargo check</code> to drive our development. Here is the first
error we get:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve: use of undeclared type or module `ThreadPool`
  --&gt; src/main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^ use of undeclared type or module `ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0433`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Great! This error tells us we need a <code>ThreadPool</code> type or module, so we’ll
build one now. Our <code>ThreadPool</code> implementation will be independent of the kind
of work our web server is doing. So, let’s switch the <code>hello</code> crate from a
binary crate to a library crate to hold our <code>ThreadPool</code> implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.</p>
<p>Create a <em>src/lib.rs</em> that contains the following, which is the simplest
definition of a <code>ThreadPool</code> struct that we can have for now:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;
<span class="boring">}
</span></code></pre></pre>
<p>Then create a new directory, <em>src/bin</em>, and move the binary crate rooted in
<em>src/main.rs</em> into <em>src/bin/main.rs</em>. Doing so will make the library crate the
primary crate in the <em>hello</em> directory; we can still run the binary in
<em>src/bin/main.rs</em> using <code>cargo run</code>. After moving the <em>main.rs</em> file, edit it
to bring the library crate in and bring <code>ThreadPool</code> into scope by adding the
following code to the top of <em>src/bin/main.rs</em>:</p>
<p><span class="filename">檔案名稱：src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
<span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
</span><span class="boring">    let pool = ThreadPool::new(4);
</span><span class="boring">
</span><span class="boring">    for stream in listener.incoming() {
</span><span class="boring">        let stream = stream.unwrap();
</span><span class="boring">
</span><span class="boring">        pool.execute(|| {
</span><span class="boring">            handle_connection(stream);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p>This code still won’t work, but let’s check it again to get the next error that
we need to address:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:11:28
   |
11 |     let pool = ThreadPool::new(4);
   |                            ^^^ function or associated item not found in `hello::ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>This error indicates that next we need to create an associated function named
<code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter
that can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance.
Let’s implement the simplest <code>new</code> function that will have those
characteristics:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>We chose <code>usize</code> as the type of the <code>size</code> parameter, because we know that a
negative number of threads doesn’t make any sense. We also know we’ll use this
4 as the number of elements in a collection of threads, which is what the
<code>usize</code> type is for, as discussed in the <a href="ch03-02-data-types.html#integer-types">“Integer Types”</a><!--
ignore --> section of Chapter 3.</p>
<p>Let’s check the code again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:16:14
   |
16 |         pool.execute(|| {
   |              ^^^^^^^ method not found in `hello::ThreadPool`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Now the error occurs because we don’t have an <code>execute</code> method on <code>ThreadPool</code>.
Recall from the <a href="ch20-02-multithreaded.html#creating-a-similar-interface-for-a-finite-number-of-threads">“Creating a Similar Interface for a Finite Number of
Threads”</a><!--
ignore --> section that we decided our thread pool should have an interface
similar to <code>thread::spawn</code>. In addition, we’ll implement the <code>execute</code> function
so it takes the closure it’s given and gives it to an idle thread in the pool
to run.</p>
<p>We’ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a
parameter. Recall from the <a href="ch13-01-closures.html#storing-closures-using-generic-parameters-and-the-fn-traits">“Storing Closures Using Generic Parameters and the
<code>Fn</code> Traits”</a><!--
ignore --> section in Chapter 13 that we can take closures as parameters with
three different traits: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>. We need to decide which
kind of closure to use here. We know we’ll end up doing something similar to
the standard library <code>thread::spawn</code> implementation, so we can look at what
bounds the signature of <code>thread::spawn</code> has on its parameter. The documentation
shows us the following:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>The <code>F</code> type parameter is the one we’re concerned with here; the <code>T</code> type
parameter is related to the return value, and we’re not concerned with that. We
can see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code>. This is probably
what we want as well, because we’ll eventually pass the argument we get in
<code>execute</code> to <code>spawn</code>. We can be further confident that <code>FnOnce</code> is the trait we
want to use because the thread for running a request will only execute that
request’s closure one time, which matches the <code>Once</code> in <code>FnOnce</code>.</p>
<p>The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound
<code>'static</code>, which are useful in our situation: we need <code>Send</code> to transfer the
closure from one thread to another and <code>'static</code> because we don’t know how long
the thread will take to execute. Let’s create an <code>execute</code> method on
<code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        ThreadPool
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure
that takes no parameters and returns the unit type <code>()</code>. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.</p>
<p>Again, this is the simplest implementation of the <code>execute</code> method: it does
nothing, but we’re trying only to make our code compile. Let’s check it again:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
</code></pre>
<p>It compiles! But note that if you try <code>cargo run</code> and make a request in the
browser, you’ll see the errors in the browser that we saw at the beginning of
the chapter. Our library isn’t actually calling the closure passed to <code>execute</code>
yet!</p>
<blockquote>
<p>Note: A saying you might hear about languages with strict compilers, such as
Haskell and Rust, is “if the code compiles, it works.” But this saying is not
universally true. Our project compiles, but it does absolutely nothing! If we
were building a real, complete project, this would be a good time to start
writing unit tests to check that the code compiles <em>and</em> has the behavior we
want.</p>
</blockquote>
<h4><a class="header" href="#validating-the-number-of-threads-in-new" id="validating-the-number-of-threads-in-new">Validating the Number of Threads in <code>new</code></a></h4>
<p>We aren’t doing anything with the parameters to <code>new</code> and <code>execute</code>. Let’s
implement the bodies of these functions with the behavior we want. To start,
let’s think about <code>new</code>. Earlier we chose an unsigned type for the <code>size</code>
parameter, because a pool with a negative number of threads makes no sense.
However, a pool with zero threads also makes no sense, yet zero is a perfectly
valid <code>usize</code>. We’ll add code to check that <code>size</code> is greater than zero before
we return a <code>ThreadPool</code> instance and have the program panic if it receives a
zero by using the <code>assert!</code> macro, as shown in Listing 20-13.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct ThreadPool;
</span><span class="boring">
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 20-13: Implementing <code>ThreadPool::new</code> to panic if
<code>size</code> is zero</span></p>
<p>We’ve added some documentation for our <code>ThreadPool</code> with doc comments. Note
that we followed good documentation practices by adding a section that calls
out the situations in which our function can panic, as discussed in Chapter 14.
Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct to see what
the generated docs for <code>new</code> look like!</p>
<p>Instead of adding the <code>assert!</code> macro as we’ve done here, we could make <code>new</code>
return a <code>Result</code> like we did with <code>Config::new</code> in the I/O project in Listing
12-9. But we’ve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If you’re feeling
ambitious, try to write a version of <code>new</code> with the following signature to
compare both versions:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<h4><a class="header" href="#creating-space-to-store-the-threads" id="creating-space-to-store-the-threads">Creating Space to Store the Threads</a></h4>
<p>Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the <code>ThreadPool</code> struct
before returning it. But how do we “store” a thread? Let’s take another look at
the <code>thread::spawn</code> signature:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that the
closure returns. Let’s try using <code>JoinHandle</code> too and see what happens. In our
case, the closures we’re passing to the thread pool will handle the connection
and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p>The code in Listing 20-14 will compile but doesn’t create any threads yet.
We’ve changed the definition of <code>ThreadPool</code> to hold a vector of
<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of
<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and
returned a <code>ThreadPool</code> instance containing them.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool { threads }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
</code></pre>
<p><span class="caption">範例 20-14: Creating a vector for <code>ThreadPool</code> to hold
the threads</span></p>
<p>We’ve brought <code>std::thread</code> into scope in the library crate, because we’re
using <code>thread::JoinHandle</code> as the type of the items in the vector in
<code>ThreadPool</code>.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can
hold <code>size</code> items. We haven’t used the <code>with_capacity</code> function in this book
yet, which performs the same task as <code>Vec::new</code> but with an important
difference: it preallocates space in the vector. Because we know we need to
store <code>size</code> elements in the vector, doing this allocation up front is slightly
more efficient than using <code>Vec::new</code>, which resizes itself as elements are
inserted.</p>
<p>When you run <code>cargo check</code> again, you’ll get a few more warnings, but it should
succeed.</p>
<h4><a class="header" href="#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread" id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread">A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</a></h4>
<p>We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of
threads. Here, we’ll look at how we actually create threads. The standard
library provides <code>thread::spawn</code> as a way to create threads, and
<code>thread::spawn</code> expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them <em>wait</em> for code that we’ll send later. The standard library’s
implementation of threads doesn’t include any way to do that; we have to
implement it manually.</p>
<p>We’ll implement this behavior by introducing a new data structure between the
<code>ThreadPool</code> and the threads that will manage this new behavior. We’ll call
this data structure <code>Worker</code>, which is a common term in pooling
implementations. Think of people working in the kitchen at a restaurant: the
workers wait until orders come in from customers, and then they’re responsible
for taking those orders and filling them.</p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool,
we’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single
<code>JoinHandle&lt;()&gt;</code> instance. Then we’ll implement a method on <code>Worker</code> that will
take a closure of code to run and send it to the already running thread for
execution. We’ll also give each worker an <code>id</code> so we can distinguish between
the different workers in the pool when logging or debugging.</p>
<p>Let’s make the following changes to what happens when we create a <code>ThreadPool</code>.
We’ll implement the code that sends the closure to the thread after we have
<code>Worker</code> set up in this way:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a
<code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty
closure.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create
a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>
</ol>
<p>If you’re up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.</p>
<p>Ready? Here is Listing 20-15 with one way to make the preceding modifications.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker { id, thread }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code>
instances instead of holding threads directly</span></p>
<p>We’ve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code>
because it’s now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code>
instances. We use the counter in the <code>for</code> loop as an argument to
<code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>
<p>External code (like our server in <em>src/bin/main.rs</em>) doesn’t need to know the
implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>,
so we make the <code>Worker</code> struct and its <code>new</code> function private. The
<code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code>
instance that is created by spawning a new thread using an empty closure.</p>
<p>This code will compile and will store the number of <code>Worker</code> instances we
specified as an argument to <code>ThreadPool::new</code>. But we’re <em>still</em> not processing
the closure that we get in <code>execute</code>. Let’s look at how to do that next.</p>
<h4><a class="header" href="#sending-requests-to-threads-via-channels" id="sending-requests-to-threads-via-channels">Sending Requests to Threads via Channels</a></h4>
<p>Now we’ll tackle the problem that the closures given to <code>thread::spawn</code> do
absolutely nothing. Currently, we get the closure we want to execute in the
<code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we
create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>We want the <code>Worker</code> structs that we just created to fetch code to run from a
queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>
<p>In Chapter 16, you learned about <em>channels</em>—a simple way to communicate between
two threads—that would be perfect for this use case. We’ll use a channel to
function as the queue of jobs, and <code>execute</code> will send a job from the
<code>ThreadPool</code> to the <code>Worker</code> instances, which will send the job to its thread.
Here is the plan:</p>
<ol>
<li>The <code>ThreadPool</code> will create a channel and hold on to the sending side of
the channel.</li>
<li>Each <code>Worker</code> will hold on to the receiving side of the channel.</li>
<li>We’ll create a new <code>Job</code> struct that will hold the closures we want to send
down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute down the sending
side of the channel.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiving side of the channel
and execute the closures of any jobs it receives.</li>
</ol>
<p>Let’s start by creating a channel in <code>ThreadPool::new</code> and holding the sending
side in the <code>ThreadPool</code> instance, as shown in Listing 20-16. The <code>Job</code> struct
doesn’t hold anything for now but will be the type of item we’re sending down
the channel.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span>// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 20-16: Modifying <code>ThreadPool</code> to store the
sending end of a channel that sends <code>Job</code> instances</span></p>
<p>In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the
sending end. This will successfully compile, still with warnings.</p>
<p>Let’s try passing a receiving end of the channel into each worker as the thread
pool creates the channel. We know we want to use the receiving end in the
thread that the workers spawn, so we’ll reference the <code>receiver</code> parameter in
the closure. The code in Listing 20-17 won’t quite compile yet.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool { workers, sender }
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">範例 20-17: Passing the receiving end of the channel
to the workers</span></p>
<p>We’ve made some small and straightforward changes: we pass the receiving end of
the channel into <code>Worker::new</code>, and then we use it inside the closure.</p>
<p>When we try to check this code, we get this error:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
22 |         let (sender, receiver) = mpsc::channel();
   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
...
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here, in previous iteration of loop

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This
won’t work, as you’ll recall from Chapter 16: the channel implementation that
Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t
just clone the consuming end of the channel to fix this code. Even if we could,
that is not the technique we would want to use; instead, we want to distribute
the jobs across threads by sharing the single <code>receiver</code> among all the workers.</p>
<p>Additionally, taking a job off the channel queue involves mutating the
<code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>;
otherwise, we might get race conditions (as covered in Chapter 16).</p>
<p>Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple workers own the
receiver, and <code>Mutex</code> will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::thread;
</span>use std::sync::Arc;
use std::sync::Mutex;
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span>    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    // --snip--
<span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">    }
</span>}

// --snip--

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span>    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 20-18: Sharing the receiving end of the channel
among the workers using <code>Arc</code> and <code>Mutex</code></span></p>
<p>In <code>ThreadPool::new</code>, we put the receiving end of the channel in an <code>Arc</code> and a
<code>Mutex</code>. For each new worker, we clone the <code>Arc</code> to bump the reference count so
the workers can share ownership of the receiving end.</p>
<p>With these changes, the code compiles! We’re getting there!</p>
<h4><a class="header" href="#implementing-the-execute-method" id="implementing-the-execute-method">Implementing the <code>execute</code> Method</a></h4>
<p>Let’s finally implement the <code>execute</code> method on <code>ThreadPool</code>. We’ll also change
<code>Job</code> from a struct to a type alias for a trait object that holds the type of
closure that <code>execute</code> receives. As discussed in the <a href="ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">“Creating Type Synonyms
with Type Aliases”</a><!-- ignore -->
section of Chapter 19, type aliases allow us to make long types shorter. Look
at Listing 20-19.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--
<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span>
    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">            receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">範例 20-19: Creating a <code>Job</code> type alias for a <code>Box</code>
that holds each closure and then sending the job down the channel</span></p>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we
send that job down the sending end of the channel. We’re calling <code>unwrap</code> on
<code>send</code> for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can’t stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use <code>unwrap</code> is that we know the failure case won’t happen, but the
compiler doesn’t know that.</p>
<p>But we’re not quite done yet! In the worker, our closure being passed to
<code>thread::spawn</code> still only <em>references</em> the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let’s make the change
shown in Listing 20-20 to <code>Worker::new</code>.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {} got a job; executing.&quot;, id);

            job();
        });

        Worker { id, thread }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 20-20: Receiving and executing the jobs in the
worker’s thread</span></p>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we
call <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex
is in a <em>poisoned</em> state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
<code>unwrap</code> to have this thread panic is the correct action to take. Feel free to
change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to
you.</p>
<p>If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the
channel. A final <code>unwrap</code> moves past any errors here as well, which might occur
if the thread holding the sending side of the channel has shut down, similar to
how the <code>send</code> method returns <code>Err</code> if the receiving side shuts down.</p>
<p>The call to <code>recv</code> blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The <code>Mutex&lt;T&gt;</code> ensures that only one
<code>Worker</code> thread at a time is trying to request a job.</p>
<p>With the implementation of this trick, our thread pool is in a working state!
Give it a <code>cargo run</code> and make some requests:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-20
cargo run
make some requests to 127.0.0.1:7878
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never read: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: field is never read: `id`
  --&gt; src/lib.rs:48:5
   |
48 |     id: usize,
   |     ^^^^^^^^^

warning: field is never read: `thread`
  --&gt; src/lib.rs:49:5
   |
49 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    Finished dev [unoptimized + debuginfo] target(s) in 1.40s
     Running `target/debug/main`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won’t get
overloaded if the server receives a lot of requests. If we make a request to
<em>/sleep</em>, the server will be able to serve other requests by having another
thread run them.</p>
<blockquote>
<p>Note: if you open <em>/sleep</em> in multiple browser windows simultaneously, they
might load one at a time in 5 second intervals. Some web browsers execute
multiple instances of the same request sequentially for caching reasons. This
limitation is not caused by our web server.</p>
</blockquote>
<p>After learning about the <code>while let</code> loop in Chapter 18, you might be wondering
why we didn’t write the worker thread code as shown in Listing 20-21.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span>// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job();
            }
        });

        Worker { id, thread }
    }
}
</code></pre>
<p><span class="caption">範例 20-21: An alternative implementation of
<code>Worker::new</code> using <code>while let</code></span></p>
<p>This code compiles and runs but doesn’t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the <code>Mutex</code> struct has no public
<code>unlock</code> method because the ownership of the lock is based on the lifetime of
the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code>
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the
lock. But this implementation can also result in the lock being held longer
than intended if we don’t think carefully about the lifetime of the
<code>MutexGuard&lt;T&gt;</code>. Because the values in the <code>while let</code> expression remain in
scope for the duration of the block, the lock remains held for the duration of
the call to <code>job()</code>, meaning other workers cannot receive jobs.</p>
<p>By using <code>loop</code> instead and acquiring the lock without assigning to a variable,
the temporary <code>MutexGuard</code> returned from the <code>lock</code> method is dropped as soon
as the <code>let job</code> statement ends. This ensures that the lock is held during the
call to <code>recv</code>, but it is released before the call to <code>job()</code>, allowing
multiple requests to be serviced concurrently.</p>
<h2><a class="header" href="#graceful-shutdown-and-cleanup" id="graceful-shutdown-and-cleanup">Graceful Shutdown and Cleanup</a></h2>
<p>The code in Listing 20-20 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the <code>workers</code>,
<code>id</code>, and <code>thread</code> fields that we’re not using in a direct way that reminds us
we’re not cleaning up anything. When we use the less elegant <span
class="keystroke">ctrl-c</span> method to halt the main thread, all other
threads are stopped immediately as well, even if they’re in the middle of
serving a request.</p>
<p>Now we’ll implement the <code>Drop</code> trait to call <code>join</code> on each of the threads in
the pool so they can finish the requests they’re working on before closing.
Then we’ll implement a way to tell the threads they should stop accepting new
requests and shut down. To see this code in action, we’ll modify our server to
accept only two requests before gracefully shutting down its thread pool.</p>
<h3><a class="header" href="#implementing-the-drop-trait-on-threadpool" id="implementing-the-drop-trait-on-threadpool">Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></a></h3>
<p>Let’s start with implementing <code>Drop</code> on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 20-22 shows a first attempt at a <code>Drop</code> implementation; this code won’t
quite work yet.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} got a job; executing.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-22: Joining each thread when the thread pool
goes out of scope</span></p>
<p>First, we loop through each of the thread pool <code>workers</code>. We use <code>&amp;mut</code> for
this because <code>self</code> is a mutable reference, and we also need to be able to
mutate <code>worker</code>. For each worker, we print a message saying that this
particular worker is shutting down, and then we call <code>join</code> on that worker’s
thread. If the call to <code>join</code> fails, we use <code>unwrap</code> to make Rust panic and go
into an ungraceful shutdown.</p>
<p>Here is the error we get when we compile this code:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0507]: cannot move out of `worker.thread` which is behind a mutable reference
  --&gt; src/lib.rs:52:13
   |
52 |             worker.thread.join().unwrap();
   |             ^^^^^^^^^^^^^ move occurs because `worker.thread` has type `std::thread::JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait

error: aborting due to previous error

For more information about this error, try `rustc --explain E0507`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>The error tells us we can’t call <code>join</code> because we only have a mutable borrow
of each <code>worker</code> and <code>join</code> takes ownership of its argument. To solve this
issue, we need to move the thread out of the <code>Worker</code> instance that owns
<code>thread</code> so <code>join</code> can consume the thread. We did this in Listing 17-15: if
<code>Worker</code> holds an <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> instead, we can call the
<code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code> variant and
leave a <code>None</code> variant in its place. In other words, a <code>Worker</code> that is running
will have a <code>Some</code> variant in <code>thread</code>, and when we want to clean up a
<code>Worker</code>, we’ll replace <code>Some</code> with <code>None</code> so the <code>Worker</code> doesn’t have a
thread to run.</p>
<p>So we know we want to update the definition of <code>Worker</code> like this:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} got a job; executing.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker { id, thread }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Now let’s lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:</p>
<pre><code class="language-console">$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
error[E0599]: no method named `join` found for type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:52:27
   |
52 |             worker.thread.join().unwrap();
   |                           ^^^^ method not found in `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`

error[E0308]: mismatched types
  --&gt; src/lib.rs:72:22
   |
72 |         Worker { id, thread }
   |                      ^^^^^^
   |                      |
   |                      expected enum `std::option::Option`, found struct `std::thread::JoinHandle`
   |                      help: try using a variant of the expected enum: `Some(thread)`
   |
   = note: expected enum `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
            found struct `std::thread::JoinHandle&lt;_&gt;`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
error: could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Let’s address the second error, which points to the code at the end of
<code>Worker::new</code>; we need to wrap the <code>thread</code> value in <code>Some</code> when we create a
new <code>Worker</code>. Make the following changes to fix this error:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            worker.thread.join().unwrap();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

<span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} got a job; executing.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span>        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>The first error is in our <code>Drop</code> implementation. We mentioned earlier that we
intended to call <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code>.
The following changes will do so:</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} got a job; executing.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>As discussed in Chapter 17, the <code>take</code> method on <code>Option</code> takes the <code>Some</code>
variant out and leaves <code>None</code> in its place. We’re using <code>if let</code> to destructure
the <code>Some</code> and get the thread; then we call <code>join</code> on the thread. If a worker’s
thread is already <code>None</code>, we know that worker has already had its thread
cleaned up, so nothing happens in that case.</p>
<h3><a class="header" href="#signaling-to-the-threads-to-stop-listening-for-jobs" id="signaling-to-the-threads-to-stop-listening-for-jobs">Signaling to the Threads to Stop Listening for Jobs</a></h3>
<p>With all the changes we’ve made, our code compiles without any warnings. But
the bad news is this code doesn’t function the way we want it to yet. The key
is the logic in the closures run by the threads of the <code>Worker</code> instances: at
the moment, we call <code>join</code>, but that won’t shut down the threads because they
<code>loop</code> forever looking for jobs. If we try to drop our <code>ThreadPool</code> with our
current implementation of <code>drop</code>, the main thread will block forever waiting
for the first thread to finish.</p>
<p>To fix this problem, we’ll modify the threads so they listen for either a <code>Job</code>
to run or a signal that they should stop listening and exit the infinite loop.
Instead of <code>Job</code> instances, our channel will send one of these two enum
variants.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span>enum Message {
    NewJob(Job),
    Terminate,
}
<span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(job).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let job = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            println!(&quot;Worker {} got a job; executing.&quot;, id);
</span><span class="boring">
</span><span class="boring">            job();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>This <code>Message</code> enum will either be a <code>NewJob</code> variant that holds the <code>Job</code> the
thread should run, or it will be a <code>Terminate</code> variant that will cause the
thread to exit its loop and stop.</p>
<p>We need to adjust the channel to use values of type <code>Message</code> rather than type
<code>Job</code>, as shown in Listing 20-23.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span>pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

<span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NewJob(Job),
</span><span class="boring">    Terminate,
</span><span class="boring">}
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--

<span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

<span class="boring">impl Drop for ThreadPool {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        for worker in &amp;mut self.workers {
</span><span class="boring">            println!(&quot;Shutting down worker {}&quot;, worker.id);
</span><span class="boring">
</span><span class="boring">            if let Some(thread) = worker.thread.take() {
</span><span class="boring">                thread.join().unwrap();
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) =&gt; {
                    println!(&quot;Worker {} got a job; executing.&quot;, id);

                    job();
                }
                Message::Terminate =&gt; {
                    println!(&quot;Worker {} was told to terminate.&quot;, id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">範例 20-23: Sending and receiving <code>Message</code> values and
exiting the loop if a <code>Worker</code> receives <code>Message::Terminate</code></span></p>
<p>To incorporate the <code>Message</code> enum, we need to change <code>Job</code> to <code>Message</code> in two
places: the definition of <code>ThreadPool</code> and the signature of <code>Worker::new</code>. The
<code>execute</code> method of <code>ThreadPool</code> needs to send jobs wrapped in the
<code>Message::NewJob</code> variant. Then, in <code>Worker::new</code> where a <code>Message</code> is received
from the channel, the job will be processed if the <code>NewJob</code> variant is
received, and the thread will break out of the loop if the <code>Terminate</code> variant
is received.</p>
<p>With these changes, the code will compile and continue to function in the same
way as it did after Listing 20-20. But we’ll get a warning because we aren’t
creating any messages of the <code>Terminate</code> variety. Let’s fix this warning by
changing our <code>Drop</code> implementation to look like Listing 20-24.</p>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::sync::Mutex;
</span><span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Message&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;
</span><span class="boring">
</span><span class="boring">enum Message {
</span><span class="boring">    NewJob(Job),
</span><span class="boring">    Terminate,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadPool {
</span><span class="boring">    /// Create a new ThreadPool.
</span><span class="boring">    ///
</span><span class="boring">    /// The size is the number of threads in the pool.
</span><span class="boring">    ///
</span><span class="boring">    /// # Panics
</span><span class="boring">    ///
</span><span class="boring">    /// The `new` function will panic if the size is zero.
</span><span class="boring">    pub fn new(size: usize) -&gt; ThreadPool {
</span><span class="boring">        assert!(size &gt; 0);
</span><span class="boring">
</span><span class="boring">        let (sender, receiver) = mpsc::channel();
</span><span class="boring">
</span><span class="boring">        let receiver = Arc::new(Mutex::new(receiver));
</span><span class="boring">
</span><span class="boring">        let mut workers = Vec::with_capacity(size);
</span><span class="boring">
</span><span class="boring">        for id in 0..size {
</span><span class="boring">            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        ThreadPool { workers, sender }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">    where
</span><span class="boring">        F: FnOnce() + Send + 'static,
</span><span class="boring">    {
</span><span class="boring">        let job = Box::new(f);
</span><span class="boring">
</span><span class="boring">        self.sender.send(Message::NewJob(job)).unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(move || loop {
</span><span class="boring">            let message = receiver.lock().unwrap().recv().unwrap();
</span><span class="boring">
</span><span class="boring">            match message {
</span><span class="boring">                Message::NewJob(job) =&gt; {
</span><span class="boring">                    println!(&quot;Worker {} got a job; executing.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    job();
</span><span class="boring">                }
</span><span class="boring">                Message::Terminate =&gt; {
</span><span class="boring">                    println!(&quot;Worker {} was told to terminate.&quot;, id);
</span><span class="boring">
</span><span class="boring">                    break;
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread: Some(thread),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-24: Sending <code>Message::Terminate</code> to the
workers before calling <code>join</code> on each worker thread</span></p>
<p>We’re now iterating over the workers twice: once to send one <code>Terminate</code>
message for each worker and once to call <code>join</code> on each worker’s thread. If we
tried to send a message and <code>join</code> immediately in the same loop, we couldn’t
guarantee that the worker in the current iteration would be the one to get the
message from the channel.</p>
<p>To better understand why we need two separate loops, imagine a scenario with
two workers. If we used a single loop to iterate through each worker, on the
first iteration a terminate message would be sent down the channel and <code>join</code>
called on the first worker’s thread. If that first worker was busy processing a
request at that moment, the second worker would pick up the terminate message
from the channel and shut down. We would be left waiting on the first worker to
shut down, but it never would because the second thread picked up the terminate
message. Deadlock!</p>
<p>To prevent this scenario, we first put all of our <code>Terminate</code> messages on the
channel in one loop; then we join on all the threads in another loop. Each
worker will stop receiving requests on the channel once it gets a terminate
message. So, we can be sure that if we send the same number of terminate
messages as there are workers, each worker will receive a terminate message
before <code>join</code> is called on its thread.</p>
<p>To see this code in action, let’s modify <code>main</code> to accept only two requests
before gracefully shutting down the server, as shown in Listing 20-25.</p>
<p><span class="filename">檔案名稱：src/bin/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use hello::ThreadPool;
</span><span class="boring">use std::fs;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
<span class="boring">
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span><span class="boring">    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;
</span><span class="boring">
</span><span class="boring">    let (status_line, filename) = if buffer.starts_with(get) {
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else if buffer.starts_with(sleep) {
</span><span class="boring">        thread::sleep(Duration::from_secs(5));
</span><span class="boring">        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
</span><span class="boring">    } else {
</span><span class="boring">        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let contents = fs::read_to_string(filename).unwrap();
</span><span class="boring">
</span><span class="boring">    let response = format!(&quot;{}{}&quot;, status_line, contents);
</span><span class="boring">
</span><span class="boring">    stream.write(response.as_bytes()).unwrap();
</span><span class="boring">    stream.flush().unwrap();
</span><span class="boring">}
</span></code></pre>
<p><span class="caption">範例 20-25: Shut down the server after serving two
requests by exiting the loop</span></p>
<p>You wouldn’t want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.</p>
<p>The <code>take</code> method is defined in the <code>Iterator</code> trait and limits the iteration
to the first two items at most. The <code>ThreadPool</code> will go out of scope at the
end of <code>main</code>, and the <code>drop</code> implementation will run.</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request
should error, and in your terminal you should see output similar to this:</p>
<!-- manual-regeneration
cd listings/ch20-web-server/listing-20-25
cargo run
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
curl http://127.0.0.1:7878
third request will error because server will have shut down
copy output below
Can't automate because the output depends on making requests
-->
<pre><code class="language-console">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0s
     Running `target/debug/main`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You might see a different ordering of workers and messages printed. We can see
how this code works from the messages: workers 0 and 3 got the first two
requests, and then on the third request, the server stopped accepting
connections. When the <code>ThreadPool</code> goes out of scope at the end of <code>main</code>, its
<code>Drop</code> implementation kicks in, and the pool tells all workers to terminate.
The workers each print a message when they see the terminate message, and then
the thread pool calls <code>join</code> to shut down each worker thread.</p>
<p>Notice one interesting aspect of this particular execution: the <code>ThreadPool</code>
sent the terminate messages down the channel, and before any worker received
the messages, we tried to join worker 0. Worker 0 had not yet received the
terminate message, so the main thread blocked waiting for worker 0 to finish.
In the meantime, each of the workers received the termination messages. When
worker 0 finished, the main thread waited for the rest of the workers to
finish. At that point, they had all received the termination message and were
able to shut down.</p>
<p>Congrats! We’ve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. We’re able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.</p>
<p>Here’s the full code for reference:</p>
<p><span class="filename">檔案名稱：src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
use std::fs;
use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">檔案名稱：src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;
use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

type Job = Box&lt;dyn FnOnce() + Send + 'static&gt;;

enum Message {
    NewJob(Job),
    Terminate,
}

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool { workers, sender }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || loop {
            let message = receiver.lock().unwrap().recv().unwrap();

            match message {
                Message::NewJob(job) =&gt; {
                    println!(&quot;Worker {} got a job; executing.&quot;, id);

                    job();
                }
                Message::Terminate =&gt; {
                    println!(&quot;Worker {} was told to terminate.&quot;, id);

                    break;
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>We could do more here! If you want to continue enhancing this project, here are
some ideas:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods.</li>
<li>Add tests of the library’s functionality.</li>
<li>Change calls to <code>unwrap</code> to more robust error handling.</li>
<li>Use <code>ThreadPool</code> to perform some task other than serving web requests.</li>
<li>Find a thread pool crate on <a href="https://crates.io/">crates.io</a> and implement a
similar web server using the crate instead. Then compare its API and
robustness to the thread pool we implemented.</li>
</ul>
<h2><a class="header" href="#summary-3" id="summary-3">Summary</a></h2>
<p>Well done! You’ve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. You’re now ready to implement your own Rust
projects and help with other peoples’ projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.</p>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in your
Rust journey.</p>
<h2><a class="header" href="#appendix-a-keywords" id="appendix-a-keywords">Appendix A: Keywords</a></h2>
<p>The following list contains keywords that are reserved for current or future
use by the Rust language. As such, they cannot be used as identifiers (except
as raw identifiers as we’ll discuss in the “<a href="appendix-01-keywords.html#raw-identifiers">Raw
Identifiers</a><!-- ignore -->” section), including names of
functions, variables, parameters, struct fields, modules, crates, constants,
macros, static values, attributes, types, traits, or lifetimes.</p>
<h3><a class="header" href="#keywords-currently-in-use" id="keywords-currently-in-use">Keywords Currently in Use</a></h3>
<p>The following keywords currently have the functionality described.</p>
<ul>
<li><code>as</code> - perform primitive casting, disambiguate the specific trait containing
an item, or rename items in <code>use</code> and <code>extern crate</code> statements</li>
<li><code>async</code> -  return a <code>Future</code> instead of blocking the current thread</li>
<li><code>await</code> - suspend execution until the result of a <code>Future</code> is ready</li>
<li><code>break</code> - exit a loop immediately</li>
<li><code>const</code> - define constant items or constant raw pointers</li>
<li><code>continue</code> - continue to the next loop iteration</li>
<li><code>crate</code> - link an external crate or a macro variable representing the crate in
which the macro is defined</li>
<li><code>dyn</code> - dynamic dispatch to a trait object</li>
<li><code>else</code> - fallback for <code>if</code> and <code>if let</code> control flow constructs</li>
<li><code>enum</code> - define an enumeration</li>
<li><code>extern</code> - link an external crate, function, or variable</li>
<li><code>false</code> - Boolean false literal</li>
<li><code>fn</code> - define a function or the function pointer type</li>
<li><code>for</code> - loop over items from an iterator, implement a trait, or specify a
higher-ranked lifetime</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>impl</code> - implement inherent or trait functionality</li>
<li><code>in</code> - part of <code>for</code> loop syntax</li>
<li><code>let</code> - bind a variable</li>
<li><code>loop</code> - loop unconditionally</li>
<li><code>match</code> - match a value to patterns</li>
<li><code>mod</code> - define a module</li>
<li><code>move</code> - make a closure take ownership of all its captures</li>
<li><code>mut</code> - denote mutability in references, raw pointers, or pattern bindings</li>
<li><code>pub</code> - denote public visibility in struct fields, <code>impl</code> blocks, or modules</li>
<li><code>ref</code> - bind by reference</li>
<li><code>return</code> - return from function</li>
<li><code>Self</code> - a type alias for the type we are defining or implementing</li>
<li><code>self</code> - method subject or current module</li>
<li><code>static</code> - global variable or lifetime lasting the entire program execution</li>
<li><code>struct</code> - define a structure</li>
<li><code>super</code> - parent module of the current module</li>
<li><code>trait</code> - define a trait</li>
<li><code>true</code> - Boolean true literal</li>
<li><code>type</code> - define a type alias or associated type</li>
<li><code>union</code> - define a <a href="../reference/items/unions.html">union</a> and is only a keyword when used in a union declaration</li>
<li><code>unsafe</code> - denote unsafe code, functions, traits, or implementations</li>
<li><code>use</code> - bring symbols into scope</li>
<li><code>where</code> - denote clauses that constrain a type</li>
<li><code>while</code> - loop conditionally based on the result of an expression</li>
</ul>
<h3><a class="header" href="#keywords-reserved-for-future-use" id="keywords-reserved-for-future-use">Keywords Reserved for Future Use</a></h3>
<p>The following keywords do not have any functionality but are reserved by Rust
for potential future use.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3><a class="header" href="#raw-identifiers" id="raw-identifiers">Raw Identifiers</a></h3>
<p><em>Raw identifiers</em> are the syntax that lets you use keywords where they wouldn’t
normally be allowed. You use a raw identifier by prefixing a keyword with <code>r#</code>.</p>
<p>For example, <code>match</code> is a keyword. If you try to compile the following function
that uses <code>match</code> as its name:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>you’ll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>The error shows that you can’t use the keyword <code>match</code> as the function
identifier. To use <code>match</code> as a function name, you need to use the raw
identifier syntax, like this:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>This code will compile without any errors. Note the <code>r#</code> prefix on the function
name in its definition as well as where the function is called in <code>main</code>.</p>
<p>Raw identifiers allow you to use any word you choose as an identifier, even if
that word happens to be a reserved keyword. In addition, raw identifiers allow
you to use libraries written in a different Rust edition than your crate uses.
For example, <code>try</code> isn’t a keyword in the 2015 edition but is in the 2018
edition. If you depend on a library that’s written using the 2015 edition and
has a <code>try</code> function, you’ll need to use the raw identifier syntax, <code>r#try</code> in
this case, to call that function from your 2018 edition code. See <a href="appendix-05-editions.html">Appendix
E</a><!-- ignore --> for more information on editions.</p>
<h2><a class="header" href="#appendix-b-operators-and-symbols" id="appendix-b-operators-and-symbols">Appendix B: Operators and Symbols</a></h2>
<p>This appendix contains a glossary of Rust’s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.</p>
<h3><a class="header" href="#operators" id="operators">Operators</a></h3>
<p>Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.</p>
<p><span class="caption">Table B-1: Operators</span></p>
<table><thead><tr><th>Operator</th><th>Example</th><th>Explanation</th><th>Overloadable?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro expansion</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bitwise or logical complement</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>Nonequality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Arithmetic remainder</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Arithmetic remainder and assignment</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Borrow</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Borrowed pointer type</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitwise AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitwise AND and assignment</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Short-circuiting logical AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Arithmetic multiplication</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Arithmetic multiplication and assignment</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Dereference</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Raw pointer</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Compound type constraint</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Arithmetic addition</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Arithmetic addition and assignment</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Argument and element separator</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Arithmetic negation</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Arithmetic subtraction</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Arithmetic subtraction and assignment</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Function and closure return type</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Member access</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Right-exclusive range literal</td><td></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Right-inclusive range literal</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Struct literal update syntax</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>“And the rest” pattern binding</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>In a pattern: inclusive range pattern</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Arithmetic division</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Arithmetic division and assignment</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Constraints</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Struct field initializer</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Loop label</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Statement and item terminator</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Part of fixed-size array syntax</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Left-shift</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Left-shift and assignment</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Less than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Less than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Assignment/equivalence</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Equality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Part of match arm syntax</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Greater than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Greater than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Right-shift</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Right-shift and assignment</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Pattern binding</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitwise exclusive OR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitwise exclusive OR and assignment</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Pattern alternatives</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitwise OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitwise OR and assignment</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Short-circuiting logical OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Error propagation</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#non-operator-symbols" id="non-operator-symbols">Non-operator Symbols</a></h3>
<p>The following list contains all non-letters that don’t function as operators;
that is, they don’t behave like a function or method call.</p>
<p>Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.</p>
<p><span class="caption">Table B-2: Stand-Alone Syntax</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Named lifetime or loop label</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Numeric literal of specific type</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>String literal</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>Raw string literal, escape characters not processed</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>Byte string literal; constructs a <code>[u8]</code> instead of a string</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>Raw byte string literal, combination of raw and byte string literal</td></tr>
<tr><td><code>'...'</code></td><td>Character literal</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII byte literal</td></tr>
<tr><td><code>|...| expr</code></td><td>Closure</td></tr>
<tr><td><code>!</code></td><td>Always empty bottom type for diverging functions</td></tr>
<tr><td><code>_</code></td><td>“Ignored” pattern binding; also used to make integer literals readable</td></tr>
</tbody></table>
<p>Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.</p>
<p><span class="caption">Table B-3: Path-Related Syntax</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Namespace path</td></tr>
<tr><td><code>::path</code></td><td>Path relative to the crate root (i.e., an explicitly absolute path)</td></tr>
<tr><td><code>self::path</code></td><td>Path relative to the current module (i.e., an explicitly relative path).</td></tr>
<tr><td><code>super::path</code></td><td>Path relative to the parent of the current module</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Associated constants, functions, and types</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Associated item for a type that cannot be directly named (e.g., <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Disambiguating a method call by naming the trait that defines it</td></tr>
<tr><td><code>type::method(...)</code></td><td>Disambiguating a method call by naming the type for which it’s defined</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Disambiguating a method call by naming the trait and type</td></tr>
</tbody></table>
<p>Table B-4 shows symbols that appear in the context of using generic type
parameters.</p>
<p><span class="caption">Table B-4: Generics</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Specifies parameters to generic type in a type (e.g., <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Define generic function</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Define generic structure</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Define generic enumeration</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Define generic implementation</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Higher-ranked lifetime bounds</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>A generic type where one or more associated types have specific assignments (e.g., <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<p>Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.</p>
<p><span class="caption">Table B-5: Trait Bound Constraints</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Generic parameter <code>T</code> constrained to types that implement <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Generic type <code>T</code> must outlive lifetime <code>'a</code> (meaning the type cannot transitively contain any references with lifetimes shorter than <code>'a</code>)</td></tr>
<tr><td><code>T : 'static</code></td><td>Generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones</td></tr>
<tr><td><code>'b: 'a</code></td><td>Generic lifetime <code>'b</code> must outlive lifetime <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Allow generic type parameter to be a dynamically sized type</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Compound type constraint</td></tr>
</tbody></table>
<p>Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.</p>
<p><span class="caption">Table B-6: Macros and Attributes</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Outer attribute</td></tr>
<tr><td><code>#![meta]</code></td><td>Inner attribute</td></tr>
<tr><td><code>$ident</code></td><td>Macro substitution</td></tr>
<tr><td><code>$ident:kind</code></td><td>Macro capture</td></tr>
<tr><td><code>$(…)…</code></td><td>Macro repetition</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro invocation</td></tr>
</tbody></table>
<p>Table B-7 shows symbols that create comments.</p>
<p><span class="caption">Table B-7: Comments</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Line comment</td></tr>
<tr><td><code>//!</code></td><td>Inner line doc comment</td></tr>
<tr><td><code>///</code></td><td>Outer line doc comment</td></tr>
<tr><td><code>/*...*/</code></td><td>Block comment</td></tr>
<tr><td><code>/*!...*/</code></td><td>Inner block doc comment</td></tr>
<tr><td><code>/**...*/</code></td><td>Outer block doc comment</td></tr>
</tbody></table>
<p>Table B-8 shows symbols that appear in the context of using tuples.</p>
<p><span class="caption">Table B-8: Tuples</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Empty tuple (aka unit), both literal and type</td></tr>
<tr><td><code>(expr)</code></td><td>Parenthesized expression</td></tr>
<tr><td><code>(expr,)</code></td><td>Single-element tuple expression</td></tr>
<tr><td><code>(type,)</code></td><td>Single-element tuple type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Tuple expression</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tuple type</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Function call expression; also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Tuple indexing</td></tr>
</tbody></table>
<p>Table B-9 shows the contexts in which curly braces are used.</p>
<p><span class="caption">Table B-9: Curly Brackets</span></p>
<table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Block expression</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> literal</td></tr>
</tbody></table>
<p>Table B-10 shows the contexts in which square brackets are used.</p>
<p><span class="caption">Table B-10: Square Brackets</span></p>
<table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Array literal</td></tr>
<tr><td><code>[expr; len]</code></td><td>Array literal containing <code>len</code> copies of <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Array type containing <code>len</code> instances of <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Collection indexing. Overloadable (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, or <code>RangeFull</code> as the “index”</td></tr>
</tbody></table>
<h2><a class="header" href="#appendix-c-可推導的特徵" id="appendix-c-可推導的特徵">Appendix C: 可推導的特徵</a></h2>
<p>In various places in the book, we’ve discussed the <code>derive</code> attribute, which
you can apply to a struct or enum definition. The <code>derive</code> attribute generates
code that will implement a trait with its own default implementation on the
type you’ve annotated with the <code>derive</code> syntax.</p>
<p>In this appendix, we provide a reference of all the traits in the standard
library that you can use with <code>derive</code>. Each section covers:</p>
<ul>
<li>What operators and methods deriving this trait will enable</li>
<li>What the implementation of the trait provided by <code>derive</code> does</li>
<li>What implementing the trait signifies about the type</li>
<li>The conditions in which you’re allowed or not allowed to implement the trait</li>
<li>Examples of operations that require the trait</li>
</ul>
<p>If you want different behavior from that provided by the <code>derive</code> attribute,
consult the <a href="../std/index.html">standard library documentation</a><!-- ignore -->
for each trait for details of how to manually implement them.</p>
<p>The rest of the traits defined in the standard library can’t be implemented on
your types using <code>derive</code>. These traits don’t have sensible default behavior,
so it’s up to you to implement them in the way that makes sense for what you’re
trying to accomplish.</p>
<p>An example of a trait that can’t be derived is <code>Display</code>, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn’t have this insight, so
it can’t provide appropriate default behavior for you.</p>
<p>The list of 可推導的特徵 provided in this appendix is not comprehensive:
libraries can implement <code>derive</code> for their own traits, making the list of
traits you can use <code>derive</code> with truly open-ended. Implementing <code>derive</code>
involves using a procedural macro, which is covered in the
<a href="ch19-06-macros.html#macros">“Macros”</a><!-- ignore --> section of Chapter 19.</p>
<h3><a class="header" href="#debug-for-programmer-output" id="debug-for-programmer-output"><code>Debug</code> for Programmer Output</a></h3>
<p>The <code>Debug</code> trait enables debug formatting in format strings, which you
indicate by adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p>The <code>Debug</code> trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program’s execution.</p>
<p>The <code>Debug</code> trait is required, for example, in use of the <code>assert_eq!</code> macro.
This macro prints the values of instances given as arguments if the equality
assertion fails so programmers can see why the two instances weren’t equal.</p>
<h3><a class="header" href="#partialeq-and-eq-for-equality-comparisons" id="partialeq-and-eq-for-equality-comparisons"><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons</a></h3>
<p>The <code>PartialEq</code> trait allows you to compare instances of a type to check for
equality and enables use of the <code>==</code> and <code>!=</code> operators.</p>
<p>Deriving <code>PartialEq</code> implements the <code>eq</code> method. When <code>PartialEq</code> is derived on
structs, two instances are equal only if <em>all</em> fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.</p>
<p>The <code>PartialEq</code> trait is required, for example, with the use of the
<code>assert_eq!</code> macro, which needs to be able to compare two instances of a type
for equality.</p>
<p>The <code>Eq</code> trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The <code>Eq</code> trait can only be
applied to types that also implement <code>PartialEq</code>, although not all types that
implement <code>PartialEq</code> can implement <code>Eq</code>. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (<code>NaN</code>) value are not equal to each other.</p>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the
<code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</p>
<h3><a class="header" href="#partialord-and-ord-for-ordering-comparisons" id="partialord-and-ord-for-ordering-comparisons"><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons</a></h3>
<p>The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting
purposes. A type that implements <code>PartialOrd</code> can be used with the <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, and <code>&gt;=</code> operators. You can only apply the <code>PartialOrd</code> trait to types
that also implement <code>PartialEq</code>.</p>
<p>Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an
<code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don’t produce an
ordering. An example of a value that doesn’t produce an ordering, even though
most values of that type can be compared, is the not-a-number (<code>NaN</code>) floating
point value. Calling <code>partial_cmp</code> with any floating point number and the <code>NaN</code>
floating point value will return <code>None</code>.</p>
<p>When derived on structs, <code>PartialOrd</code> compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.</p>
<p>The <code>PartialOrd</code> trait is required, for example, for the <code>gen_range</code> method
from the <code>rand</code> crate that generates a random value in the range specified by a
low value and a high value.</p>
<p>The <code>Ord</code> trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The <code>Ord</code> trait implements the <code>cmp</code> method,
which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid
ordering will always be possible. You can only apply the <code>Ord</code> trait to types
that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>). When
derived on structs and enums, <code>cmp</code> behaves the same way as the derived
implementation for <code>partial_cmp</code> does with <code>PartialOrd</code>.</p>
<p>An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>,
a data structure that stores data based on the sort order of the values.</p>
<h3><a class="header" href="#clone-and-copy-for-duplicating-values" id="clone-and-copy-for-duplicating-values"><code>Clone</code> and <code>Copy</code> for Duplicating Values</a></h3>
<p>The <code>Clone</code> trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See the <a href="ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">“Ways Variables and Data Interact:
Clone”</a><!-- ignore --> section in
Chapter 4 for more information on <code>Clone</code>.</p>
<p>Deriving <code>Clone</code> implements the <code>clone</code> method, which when implemented for the
whole type, calls <code>clone</code> on each of the parts of the type. This means all the
fields or values in the type must also implement <code>Clone</code> to derive <code>Clone</code>.</p>
<p>An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a
slice. The slice doesn’t own the type instances it contains, but the vector
returned from <code>to_vec</code> will need to own its instances, so <code>to_vec</code> calls
<code>clone</code> on each item. Thus, the type stored in the slice must implement <code>Clone</code>.</p>
<p>The <code>Copy</code> trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See the <a href="ch04-01-what-is-ownership.html#stack-only-data-copy">“Stack-Only Data:
Copy”</a><!-- ignore --> section in Chapter 4 for more
information on <code>Copy</code>.</p>
<p>The <code>Copy</code> trait doesn’t define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.</p>
<p>You can derive <code>Copy</code> on any type whose parts all implement <code>Copy</code>. You can
only apply the <code>Copy</code> trait to types that also implement <code>Clone</code>, because a
type that implements <code>Copy</code> has a trivial implementation of <code>Clone</code> that
performs the same task as <code>Copy</code>.</p>
<p>The <code>Copy</code> trait is rarely required; types that implement <code>Copy</code> have
optimizations available, meaning you don’t have to call <code>clone</code>, which makes
the code more concise.</p>
<p>Everything possible with <code>Copy</code> you can also accomplish with <code>Clone</code>, but the
code might be slower or have to use <code>clone</code> in places.</p>
<h3><a class="header" href="#hash-for-mapping-a-value-to-a-value-of-fixed-size" id="hash-for-mapping-a-value-to-a-value-of-fixed-size"><code>Hash</code> for Mapping a Value to a Value of Fixed Size</a></h3>
<p>The <code>Hash</code> trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
<code>Hash</code> implements the <code>hash</code> method. The derived implementation of the <code>hash</code>
method combines the result of calling <code>hash</code> on each of the parts of the type,
meaning all fields or values must also implement <code>Hash</code> to derive <code>Hash</code>.</p>
<p>An example of when <code>Hash</code> is required is in storing keys in a <code>HashMap&lt;K, V&gt;</code>
to store data efficiently.</p>
<h3><a class="header" href="#default-for-default-values" id="default-for-default-values"><code>Default</code> for Default Values</a></h3>
<p>The <code>Default</code> trait allows you to create a default value for a type. Deriving
<code>Default</code> implements the <code>default</code> function. The derived implementation of the
<code>default</code> function calls the <code>default</code> function on each part of the type,
meaning all fields or values in the type must also implement <code>Default</code> to
derive <code>Default</code>.</p>
<p>The <code>Default::default</code> function is commonly used in combination with the struct
update syntax discussed in the <a href="ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">“Creating Instances From Other Instances With
Struct Update
Syntax”</a><!-- ignore -->
section in Chapter 5. You can customize a few fields of a struct and then
set and use a default value for the rest of the fields by using
<code>..Default::default()</code>.</p>
<p>The <code>Default</code> trait is required when you use the method <code>unwrap_or_default</code> on
<code>Option&lt;T&gt;</code> instances, for example. If the <code>Option&lt;T&gt;</code> is <code>None</code>, the method
<code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type
<code>T</code> stored in the <code>Option&lt;T&gt;</code>.</p>
<h2><a class="header" href="#appendix-d---useful-development-tools" id="appendix-d---useful-development-tools">Appendix D - Useful Development Tools</a></h2>
<p>In this appendix, we talk about some useful development tools that the Rust
project provides. We’ll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.</p>
<h3><a class="header" href="#automatic-formatting-with-rustfmt" id="automatic-formatting-with-rustfmt">Automatic Formatting with <code>rustfmt</code></a></h3>
<p>The <code>rustfmt</code> tool reformats your code according to the community code style.
Many collaborative projects use <code>rustfmt</code> to prevent arguments about which
style to use when writing Rust: everyone formats their code using the tool.</p>
<p>To install <code>rustfmt</code>, enter the following:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>This command gives you <code>rustfmt</code> and <code>cargo-fmt</code>, similar to how Rust gives you
both <code>rustc</code> and <code>cargo</code>. To format any Cargo project, enter the following:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics. For more information
on <code>rustfmt</code>, see <a href="https://github.com/rust-lang/rustfmt">its documentation</a>.</p>
<h3><a class="header" href="#fix-your-code-with-rustfix" id="fix-your-code-with-rustfix">Fix Your Code with <code>rustfix</code></a></h3>
<p>The rustfix tool is included with Rust installations and can automatically fix
some compiler warnings. If you’ve written code in Rust, you’ve probably seen
compiler warnings. For example, consider this code:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Here, we’re calling the <code>do_something</code> function 100 times, but we never use the
variable <code>i</code> in the body of the <code>for</code> loop. Rust warns us about that:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>The warning suggests that we use <code>_i</code> as a name instead: the underscore
indicates that we intend for this variable to be unused. We can automatically
apply that suggestion using the <code>rustfix</code> tool by running the command <code>cargo fix</code>:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>When we look at <em>src/main.rs</em> again, we’ll see that <code>cargo fix</code> has changed the
code:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>The <code>for</code> loop variable is now named <code>_i</code>, and the warning no longer appears.</p>
<p>You can also use the <code>cargo fix</code> command to transition your code between
different Rust editions. Editions are covered in Appendix E.</p>
<h3><a class="header" href="#more-lints-with-clippy" id="more-lints-with-clippy">More Lints with Clippy</a></h3>
<p>The Clippy tool is a collection of lints to analyze your code so you can catch
common mistakes and improve your Rust code.</p>
<p>To install Clippy, enter the following:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>To run Clippy’s lints on any Cargo project, enter the following:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>For example, say you write a program that uses an approximation of a
mathematical constant, such as pi, as this program does:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Running <code>cargo clippy</code> on this project results in this error:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>This error lets you know that Rust has this constant defined more precisely and
that your program would be more correct if you used the constant instead. You
would then change your code to use the <code>PI</code> constant. The following code
doesn’t result in any errors or warnings from Clippy:</p>
<p><span class="filename">檔案名稱：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>For more information on Clippy, see <a href="https://github.com/rust-lang/rust-clippy">its documentation</a>.</p>
<h3><a class="header" href="#ide-integration-using-the-rust-language-server" id="ide-integration-using-the-rust-language-server">IDE Integration Using the Rust Language Server</a></h3>
<p>To help IDE integration, the Rust project distributes the <em>Rust Language
Server</em> (<code>rls</code>). This tool speaks the <a href="http://langserver.org/">Language Server
Protocol</a>, which is a specification for IDEs and programming
languages to communicate with each other. Different clients can use the <code>rls</code>,
such as <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">the Rust plug-in for Visual Studio Code</a>.</p>
<p>To install the <code>rls</code>, enter the following:</p>
<pre><code class="language-console">$ rustup component add rls
</code></pre>
<p>Then install the language server support in your particular IDE; you’ll gain
abilities such as autocompletion, jump to definition, and inline errors.</p>
<p>For more information on the <code>rls</code>, see <a href="https://github.com/rust-lang/rls">its documentation</a>.</p>
<h2><a class="header" href="#appendix-e---editions" id="appendix-e---editions">Appendix E - Editions</a></h2>
<p>In Chapter 1, you saw that <code>cargo new</code> adds a bit of metadata to your
<em>Cargo.toml</em> file about an edition. This appendix talks about what that means!</p>
<p>The Rust language and compiler have a six-week release cycle, meaning users get
a constant stream of new features. Other programming languages release larger
changes less often; Rust releases smaller updates more frequently. After a
while, all of these tiny changes add up. But from release to release, it can be
difficult to look back and say, “Wow, between Rust 1.10 and Rust 1.31, Rust has
changed a lot!”</p>
<p>Every two or three years, the Rust team produces a new Rust <em>edition</em>. Each
edition brings together the features that have landed into a clear package with
fully updated documentation and tooling. New editions ship as part of the usual
six-week release process.</p>
<p>Editions serve different purposes for different people:</p>
<ul>
<li>For active Rust users, a new edition brings together incremental changes into
an easy-to-understand package.</li>
<li>For non-users, a new edition signals that some major advancements have
landed, which might make Rust worth another look.</li>
<li>For those developing Rust, a new edition provides a rallying point for the
project as a whole.</li>
</ul>
<p>At the time of this writing, two Rust editions are available: Rust 2015 and
Rust 2018. This book is written using Rust 2018 edition idioms.</p>
<p>The <code>edition</code> key in <em>Cargo.toml</em> indicates which edition the compiler should
use for your code. If the key doesn’t exist, Rust uses <code>2015</code> as the edition
value for backward compatibility reasons.</p>
<p>Each project can opt in to an edition other than the default 2015 edition.
Editions can contain incompatible changes, such as including a new keyword that
conflicts with identifiers in code. However, unless you opt in to those
changes, your code will continue to compile even as you upgrade the Rust
compiler version you use.</p>
<p>All Rust compiler versions support any edition that existed prior to that
compiler’s release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if you’re using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.</p>
<p>To be clear: most features will be available on all editions. Developers using
any Rust edition will continue to see improvements as new stable releases are
made. However, in some cases, mainly when new keywords are added, some new
features might only be available in later editions. You will need to switch
editions if you want to take advantage of such features.</p>
<p>For more details, the <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition
Guide</em></a> is a complete book
about editions that enumerates the differences between editions and explains
how to automatically upgrade your code to a new edition via <code>cargo fix</code>.</p>
<h2><a class="header" href="#appendix-f-translations-of-the-book" id="appendix-f-translations-of-the-book">Appendix F: Translations of the Book</a></h2>
<p>For resources in languages other than English. Most are still in progress; see
<a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">the Translations label</a> to help or let us know about a new translation!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
<li><a href="https://github.com/RustDili/dokuman/tree/master/ceviriler">Turkish</a>, <a href="https://rustdili.github.io/">online</a></li>
</ul>
<h2><a class="header" href="#appendix-g---how-rust-is-made-and-nightly-rust" id="appendix-g---how-rust-is-made-and-nightly-rust">Appendix G - How Rust is Made and “Nightly Rust”</a></h2>
<p>This appendix is about how Rust is made and how that affects you as a Rust
developer.</p>
<h3><a class="header" href="#stability-without-stagnation" id="stability-without-stagnation">Stability Without Stagnation</a></h3>
<p>As a language, Rust cares a <em>lot</em> about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can’t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.</p>
<p>Our solution to this problem is what we call “stability without stagnation”,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.</p>
<h3><a class="header" href="#choo-choo-release-channels-and-riding-the-trains" id="choo-choo-release-channels-and-riding-the-trains">Choo, Choo! Release Channels and Riding the Trains</a></h3>
<p>Rust development operates on a <em>train schedule</em>. That is, all development is
done on the <code>master</code> branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three <em>release channels</em> for Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.</p>
<p>Here’s an example of how the development and release process works: let’s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the <code>master</code>
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Every six weeks, it’s time to prepare a new release! The <code>beta</code> branch of the
Rust repository branches off from the <code>master</code> branch used by nightly. Now,
there are two releases:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there’s still a nightly release every night:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Let’s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to <code>master</code>, so that nightly is fixed, and then the fix is backported to the
<code>beta</code> branch, and a new release of beta is produced:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Six weeks after the first beta was created, it’s time for a stable release! The
<code>stable</code> branch is produced from the <code>beta</code> branch:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the <em>next</em> version of Rust, 1.6.
So after <code>stable</code> branches off of <code>beta</code>, the next version of <code>beta</code> branches
off of <code>nightly</code> again:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>This is called the “train model” because every six weeks, a release “leaves the
station”, but still has to take a journey through the beta channel before it
arrives as a stable release.</p>
<p>Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it’s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there’s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.</p>
<p>Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it’s easy to upgrade to: if a beta release doesn’t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
<code>rustc</code> is still a piece of software, and bugs do exist.</p>
<h3><a class="header" href="#unstable-features" id="unstable-features">Unstable Features</a></h3>
<p>There’s one more catch with this release model: unstable features. Rust uses a
technique called “feature flags” to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
<code>master</code>, and therefore, in nightly, but behind a <em>feature flag</em>. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.</p>
<p>If you’re using a beta or stable release of Rust, you can’t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won’t break. Stability without stagnation.</p>
<p>This book only contains information about stable features, as in-progress
features are still changing, and surely they’ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.</p>
<h3><a class="header" href="#rustup-and-the-role-of-rust-nightly" id="rustup-and-the-role-of-rust-nightly">Rustup and the Role of Rust Nightly</a></h3>
<p>Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you’ll have stable Rust installed. To
install nightly, for example:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>You can see all of the <em>toolchains</em> (releases of Rust and associated
components) you have installed with <code>rustup</code> as well. Here’s an example on one
of your authors’ Windows computer:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use <code>rustup override</code> in that project’s directory to set the
nightly toolchain as the one <code>rustup</code> should use when you’re in that directory:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Now, every time you call <code>rustc</code> or <code>cargo</code> inside of
<em>~/projects/needs-nightly</em>, <code>rustup</code> will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!</p>
<h3><a class="header" href="#the-rfc-process-and-teams" id="the-rfc-process-and-teams">The RFC Process and Teams</a></h3>
<p>So how do you learn about these new features? Rust’s development model follows
a <em>Request For Comments (RFC) process</em>. If you’d like an improvement in Rust,
you can write up a proposal, called an RFC.</p>
<p>Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There’s
a full list of the teams <a href="https://www.rust-lang.org/governance">on Rust’s
website</a>, which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there’s consensus to accept or reject the feature.</p>
<p>If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the <code>master</code> branch behind a feature gate, as we discussed
in the <a href="appendix-07-nightly-rust.html#unstable-features">“Unstable Features”</a><!-- ignore --> section.</p>
<p>After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it’s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.</p>
<h1><a class="header" href="#中英術語對照表" id="中英術語對照表">中英術語對照表</a></h1>
<p>以下爲本書所使用到的常用術語：</p>
<table><thead><tr><th>English 英文</th><th>Traditional Chinese 正體中文</th><th>Note 備註</th></tr></thead><tbody>
<tr><td>Abstract Syntax Tree</td><td>抽象語法樹</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">維基百科</a></td></tr>
<tr><td>ahead-of-time compiled</td><td>預先編譯</td><td></td></tr>
<tr><td>annotations</td><td>詮釋</td><td></td></tr>
<tr><td>argument</td><td>引數</td><td></td></tr>
<tr><td>arity</td><td>元數</td><td>所需運算元的數量。參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%85%83%E6%95%B0">維基百科</a></td></tr>
<tr><td>array</td><td>陣列</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B0%E7%BB%84">維基百科</a></td></tr>
<tr><td>assignment</td><td>賦值</td><td></td></tr>
<tr><td>associated function</td><td>關聯函式</td><td></td></tr>
<tr><td>benchmarking</td><td>基準化分析法</td><td></td></tr>
<tr><td>best-practice</td><td>最佳做法</td><td></td></tr>
<tr><td>bit</td><td>位元</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%BD%8D%E5%85%83">維基百科</a></td></tr>
<tr><td>block</td><td>區塊</td><td></td></tr>
<tr><td>boolean</td><td>布林</td><td>參考：<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E7%88%BE_(%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B)">維基百科</a></td></tr>
<tr><td>bounds-check</td><td>邊界檢查</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5">維基百科</a></td></tr>
<tr><td>borrowing</td><td>借用</td><td></td></tr>
<tr><td>borrow checker</td><td>借用檢查器</td><td></td></tr>
<tr><td>bug</td><td>程式錯誤</td><td></td></tr>
<tr><td>Builder Pattern</td><td>生成器模式</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F">維基百科</a></td></tr>
<tr><td>byte</td><td>位元組</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%97%E8%8A%82">維基百科</a></td></tr>
<tr><td>camel case</td><td>駝峰式大小寫</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">維基百科</a></td></tr>
<tr><td>clone</td><td>克隆</td><td></td></tr>
<tr><td>coerce</td><td>強制</td><td></td></tr>
<tr><td>collection</td><td>集合</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>command line</td><td>命令列</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">維基百科</a></td></tr>
<tr><td>commit</td><td>提交</td><td></td></tr>
<tr><td>concurrency</td><td>並行</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97">維基百科</a></td></tr>
<tr><td>conditional</td><td>條件運算</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%A2%9D%E4%BB%B6%E9%81%8B%E7%AE%97%E5%BC%8F">維基百科</a></td></tr>
<tr><td>configuration</td><td>配置</td><td></td></tr>
<tr><td>constant</td><td>常數</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B8%B8%E6%95%B0">維基百科</a></td></tr>
<tr><td>constructor</td><td>建構子</td><td></td></tr>
<tr><td>copy</td><td>拷貝</td><td></td></tr>
<tr><td>crash</td><td>當機</td><td></td></tr>
<tr><td>dangling pointer</td><td>迷途指標</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88">維基百科</a></td></tr>
<tr><td>data race</td><td>資料競爭</td><td></td></tr>
<tr><td>declaration statements</td><td>宣告陳述式</td><td></td></tr>
<tr><td>dependencies</td><td>依賴</td><td></td></tr>
<tr><td>deque</td><td>雙向佇列</td><td>Double-ended queue</td></tr>
<tr><td>dereference</td><td>取值</td><td>即 <code>*</code> 運算子</td></tr>
<tr><td>dispatch</td><td>分派</td><td>參考：<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%88%86%E6%B4%BE">維基百科</a></td></tr>
<tr><td>diverging functions</td><td>發散函式</td><td>不回傳值的函式</td></tr>
<tr><td>enumerate</td><td>枚舉</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%9E%9A%E4%B8%BE">維基百科</a></td></tr>
<tr><td>equality</td><td>等式</td><td></td></tr>
<tr><td>executable</td><td>執行檔</td><td></td></tr>
<tr><td>expression</td><td>表達式</td><td></td></tr>
<tr><td>expression-oriented</td><td>表達式導向</td><td></td></tr>
<tr><td>expression statements</td><td>表達陳述式</td><td></td></tr>
<tr><td>filename extension</td><td>副檔名</td><td></td></tr>
<tr><td>handle</td><td>控制代碼</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8F%A5%E6%9F%84">維基百科</a>、<a href="https://msdn.microsoft.com/zh-tw/library/yk97tc08.aspx">MSDN</a></td></tr>
<tr><td>heap</td><td>堆積</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">維基百科</a></td></tr>
<tr><td>fault</td><td>錯誤</td><td></td></tr>
<tr><td>formalization</td><td>正規化</td><td></td></tr>
<tr><td>function</td><td>函式</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%90%E7%A8%8B%E5%BA%8F">維基百科</a></td></tr>
<tr><td>generics</td><td>泛型</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%B3%9B%E5%9E%8B">維基百科</a></td></tr>
<tr><td>hash</td><td>雜湊</td><td></td></tr>
<tr><td>hash map</td><td>雜湊映射</td><td></td></tr>
<tr><td>identifier</td><td>標識符</td><td>參考：<a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E8%AD%98%E7%AC%A6">維基百科</a></td></tr>
<tr><td>import</td><td>匯入</td><td></td></tr>
<tr><td>index</td><td>索引</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%B4%A2%E5%BC%95">維基百科</a></td></tr>
<tr><td>instance</td><td>實體</td><td></td></tr>
<tr><td>iterative</td><td>疊代</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%AD%E4%BB%A3">維基百科</a></td></tr>
<tr><td>iterator</td><td>疊代器</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BF%AD%E4%BB%A3%E5%99%A8">維基百科</a></td></tr>
<tr><td>immutable</td><td>不可變</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6">維基百科</a></td></tr>
<tr><td>inheritance</td><td>繼承　</td><td></td></tr>
<tr><td>keyword</td><td>關鍵字</td><td></td></tr>
<tr><td>language feature</td><td>語言特徵</td><td>參考：<a href="http://www.iicm.org.tw/term/termb_L.htm">中華民國資訊學會</a></td></tr>
<tr><td>library</td><td>函式庫</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%87%BD%E5%BC%8F%E5%BA%AB">維基百科</a></td></tr>
<tr><td>lifetimes</td><td>生命週期</td><td></td></tr>
<tr><td>linker</td><td>連結器</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E9%93%BE%E6%8E%A5%E5%99%A8">維基百科</a></td></tr>
<tr><td>literal</td><td>字面值</td><td></td></tr>
<tr><td>loop</td><td>迴圈、循環</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B#.E8.BF.B4.E5.9C.88">維基百科</a></td></tr>
<tr><td>macro</td><td>巨集</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%B7%A8%E9%9B%86">維基百科</a></td></tr>
<tr><td>main function</td><td>主函式</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%BB%E5%87%BD%E5%BC%8F">維基百科</a></td></tr>
<tr><td>metadata</td><td>詮釋資料</td><td></td></tr>
<tr><td>method</td><td>方法</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">維基百科</a></td></tr>
<tr><td>module</td><td>模組</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%A8%A1%E7%B5%84_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">維基百科</a></td></tr>
<tr><td>monomorphism</td><td>單型</td><td></td></tr>
<tr><td>mutable</td><td>可變</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6">維基百科</a></td></tr>
<tr><td>mutability</td><td>可變性</td><td></td></tr>
<tr><td>mutation</td><td>可變數</td><td></td></tr>
<tr><td>namespace</td><td>命名空間</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">維基百科</a></td></tr>
<tr><td>nested</td><td>巢狀</td><td></td></tr>
<tr><td>operators</td><td>運算子</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/C%E5%92%8CC%2B%2B%E9%81%8B%E7%AE%97%E5%AD%90">維基百科</a></td></tr>
<tr><td>overloading</td><td>重載</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">維基百科</a></td></tr>
<tr><td>ownership</td><td>所有權</td><td></td></tr>
<tr><td>package</td><td>套件</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%BD%AF%E4%BB%B6%E5%8C%85">維基百科</a></td></tr>
<tr><td>panic</td><td>恐慌</td><td></td></tr>
<tr><td>parse</td><td>分析、分析語法</td><td></td></tr>
<tr><td>parser</td><td>語法分析器</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%AA%9E%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">維基百科</a></td></tr>
<tr><td>pattern</td><td>模式</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">維基百科</a></td></tr>
<tr><td>pattern matching</td><td>模式配對</td><td>參考：<a href="http://www.iicm.org.tw/term/termb_P.htm">中華民國資訊學會</a></td></tr>
<tr><td>placeholder</td><td>佔位符</td><td></td></tr>
<tr><td>plugins</td><td>外掛</td><td></td></tr>
<tr><td>pointer</td><td>指標</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">維基百科</a></td></tr>
<tr><td>polymorphism</td><td>多型</td><td>參考：<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>primitive type</td><td>基本型別</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8E%9F%E5%A7%8B%E5%9E%8B%E5%88%A5">維基百科</a></td></tr>
<tr><td>profile</td><td>設定檔</td><td></td></tr>
<tr><td>reference</td><td>參照、參考</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%8F%83%E7%85%A7">維基百科</a></td></tr>
<tr><td>round bracket</td><td>圓括號</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8B%AC%E5%8F%B7">維基百科</a></td></tr>
<tr><td>runtime</td><td>執行時</td><td></td></tr>
<tr><td>scalar</td><td>純量</td><td></td></tr>
<tr><td>scope</td><td>有效範圍</td><td></td></tr>
<tr><td>section</td><td>段落</td><td></td></tr>
<tr><td>semantics</td><td>語意</td><td></td></tr>
<tr><td>segment</td><td>區段</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%98%E6%86%B6%E9%AB%94%E5%88%86%E6%AE%B5">維基百科</a></td></tr>
<tr><td>segmentation fault</td><td>記憶體區段錯誤</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4">維基百科</a></td></tr>
<tr><td>shadowing</td><td>遮蔽</td><td></td></tr>
<tr><td>sibling</td><td>同輩</td><td></td></tr>
<tr><td>signed integer</td><td>帶號整數</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B4%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>square bracket</td><td>方括號</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%8B%AC%E5%8F%B7">維基百科</a></td></tr>
<tr><td>stack</td><td>堆疊</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%A0%86%E6%A0%88">維基百科</a></td></tr>
<tr><td>statements</td><td>陳述式</td><td></td></tr>
<tr><td>string</td><td>字串</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E5%AD%97%E7%AC%A6%E4%B8%B2">維基百科</a></td></tr>
<tr><td>string interpolation</td><td>字串插值</td><td>參考：<a href="https://msdn.microsoft.com/zh-tw/library/dn961160.aspx">MSDN</a></td></tr>
<tr><td>struct</td><td>結構體</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/C%2B%2B%E7%B1%BB">維基百科</a>、<a href="https://zh.wikipedia.org/zh-tw/%E7%BB%93%E6%9E%84%E4%BD%93_(C%E8%AF%AD%E8%A8%80)">維基百科</a></td></tr>
<tr><td>subscript</td><td>下標</td><td>指的是 <code>a[1]</code> 中的 <code>[1]</code></td></tr>
<tr><td>symbols</td><td>符號</td><td></td></tr>
<tr><td>syntax</td><td>語法</td><td></td></tr>
<tr><td>thread</td><td>執行緒</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%BA%BF%E7%A8%8B">維基百科</a></td></tr>
<tr><td>trait</td><td>特徵</td><td>參考：<a href="https://zh.wikipedia.org/wiki/Traits_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29">維基百科</a></td></tr>
<tr><td>tuple</td><td>元組</td><td></td></tr>
<tr><td>two’s complement</td><td>二補數</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E4%BA%8C%E8%A3%9C%E6%95%B8">維基百科</a></td></tr>
<tr><td>type</td><td>型別</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B">維基百科</a></td></tr>
<tr><td>type inference</td><td>型別推斷</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA">維基百科</a></td></tr>
<tr><td>unsigned integer</td><td>非帶號整數</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%B4%E6%95%B0_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">維基百科</a></td></tr>
<tr><td>values</td><td>值、數值</td><td></td></tr>
<tr><td>variables</td><td>變數</td><td></td></tr>
<tr><td>variant</td><td>變體</td><td></td></tr>
<tr><td>view</td><td>視圖</td><td>參考：<a href="https://zh.wikipedia.org/zh-tw/%E8%A7%86%E5%9B%BE">維基百科</a></td></tr>
<tr><td>wildcard</td><td>通配符</td><td></td></tr>
<tr><td>workspaces</td><td>工作空間</td><td></td></tr>
<tr><td>zero-cost abstractions</td><td>無成本抽象化</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#未翻譯" id="未翻譯">未翻譯</a></h2>
<table><thead><tr><th>English 英文</th><th>Traditional Chinese 正體中文</th><th>Note 備註</th></tr></thead><tbody>
<tr><td>alignment</td><td></td><td></td></tr>
<tr><td>backtrace</td><td></td><td></td></tr>
<tr><td>bootstrap</td><td></td><td></td></tr>
<tr><td>build</td><td></td><td>名詞，例：create a &quot;build&quot;</td></tr>
<tr><td>closures</td><td></td><td></td></tr>
<tr><td>crates</td><td></td><td></td></tr>
<tr><td>fully-strict</td><td></td><td></td></tr>
<tr><td>linking</td><td></td><td></td></tr>
<tr><td>map</td><td></td><td></td></tr>
<tr><td>master</td><td></td><td>git branch</td></tr>
<tr><td>mata</td><td></td><td></td></tr>
<tr><td>metaprogramming</td><td></td><td></td></tr>
<tr><td>non-strict</td><td></td><td></td></tr>
<tr><td>patches</td><td></td><td></td></tr>
<tr><td>prelude</td><td></td><td>預先載入的函式庫</td></tr>
<tr><td>regression</td><td></td><td></td></tr>
<tr><td>repository</td><td></td><td></td></tr>
<tr><td>root</td><td></td><td></td></tr>
<tr><td>Rustaceans</td><td></td><td>Rust 開發者稱呼自己的常用稱號</td></tr>
<tr><td>shell</td><td></td><td></td></tr>
<tr><td>slices</td><td></td><td>其他資料結構的參考</td></tr>
<tr><td>tabs</td><td></td><td></td></tr>
<tr><td>target triple</td><td></td><td></td></tr>
<tr><td>vector</td><td></td><td></td></tr>
<tr><td>work stealing</td><td></td><td></td></tr>
</tbody></table>
<blockquote>
<p>TODO：持續整理中⋯</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
